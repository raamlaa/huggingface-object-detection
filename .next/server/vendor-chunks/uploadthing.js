"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uploadthing";
exports.ids = ["vendor-chunks/uploadthing"];
exports.modules = {

/***/ "(rsc)/./node_modules/uploadthing/internal/types.js":
/*!****************************************************!*\
  !*** ./node_modules/uploadthing/internal/types.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UTFiles: () => (/* binding */ UTFiles),\n/* harmony export */   VALID_ACTION_TYPES: () => (/* binding */ VALID_ACTION_TYPES)\n/* harmony export */ });\n/**\n * Marker used to append a `customId` to the incoming file data in `.middleware()`\n * @example\n * ```ts\n * .middleware((opts) => {\n *   return {\n *     [UTFiles]: opts.files.map((file) => ({\n *       ...file,\n *       customId: generateId(),\n *     }))\n *   };\n * })\n * ```\n */ const UTFiles = Symbol(\"uploadthing-custom-id-symbol\");\n/**\n * Valid options for the `?actionType` query param\n */ const VALID_ACTION_TYPES = [\n    \"upload\",\n    \"failure\",\n    \"multipart-complete\"\n];\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvaW50ZXJuYWwvdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QyIsInNvdXJjZXMiOlsid2VicGFjazovL29iamVjdC1kZXRlY3Rpb24vLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvaW50ZXJuYWwvdHlwZXMuanM/OTBhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1hcmtlciB1c2VkIHRvIGFwcGVuZCBhIGBjdXN0b21JZGAgdG8gdGhlIGluY29taW5nIGZpbGUgZGF0YSBpbiBgLm1pZGRsZXdhcmUoKWBcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogLm1pZGRsZXdhcmUoKG9wdHMpID0+IHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBbVVRGaWxlc106IG9wdHMuZmlsZXMubWFwKChmaWxlKSA9PiAoe1xuICogICAgICAgLi4uZmlsZSxcbiAqICAgICAgIGN1c3RvbUlkOiBnZW5lcmF0ZUlkKCksXG4gKiAgICAgfSkpXG4gKiAgIH07XG4gKiB9KVxuICogYGBgXG4gKi8gY29uc3QgVVRGaWxlcyA9IFN5bWJvbChcInVwbG9hZHRoaW5nLWN1c3RvbS1pZC1zeW1ib2xcIik7XG4vKipcbiAqIFZhbGlkIG9wdGlvbnMgZm9yIHRoZSBgP2FjdGlvblR5cGVgIHF1ZXJ5IHBhcmFtXG4gKi8gY29uc3QgVkFMSURfQUNUSU9OX1RZUEVTID0gW1xuICAgIFwidXBsb2FkXCIsXG4gICAgXCJmYWlsdXJlXCIsXG4gICAgXCJtdWx0aXBhcnQtY29tcGxldGVcIlxuXTtcblxuZXhwb3J0IHsgVVRGaWxlcywgVkFMSURfQUNUSU9OX1RZUEVTIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uploadthing/internal/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/uploadthing/server/index.js":
/*!**************************************************!*\
  !*** ./node_modules/uploadthing/server/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INTERNAL_DO_NOT_USE_createRouteHandlerCore: () => (/* binding */ INTERNAL_DO_NOT_USE_createRouteHandlerCore),\n/* harmony export */   UTApi: () => (/* binding */ UTApi),\n/* harmony export */   UTFile: () => (/* binding */ UTFile),\n/* harmony export */   UTFiles: () => (/* reexport safe */ uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles),\n/* harmony export */   UploadThingError: () => (/* reexport safe */ _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError),\n/* harmony export */   createRouteHandler: () => (/* binding */ createRouteHandler),\n/* harmony export */   createServerHandler: () => (/* binding */ createServerHandler),\n/* harmony export */   createUploadthing: () => (/* binding */ createUploadthing),\n/* harmony export */   extractRouterConfig: () => (/* binding */ extractRouterConfig)\n/* harmony export */ });\n/* harmony import */ var _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @uploadthing/shared */ \"(rsc)/./node_modules/@uploadthing/shared/dist/index.js\");\n/* harmony import */ var std_env__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! std-env */ \"(rsc)/./node_modules/std-env/dist/index.mjs\");\n/* harmony import */ var consola_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! consola/core */ \"(rsc)/./node_modules/consola/dist/core.mjs\");\n/* harmony import */ var uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! uploadthing/internal/types */ \"(rsc)/./node_modules/uploadthing/internal/types.js\");\n/* harmony import */ var _uploadthing_mime_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @uploadthing/mime-types */ \"(rsc)/./node_modules/@uploadthing/mime-types/dist/index.js\");\n\n\n\n\n\n\n\n\nvar version = \"6.7.0\";\n\nfunction defaultErrorFormatter(error) {\n    return {\n        message: error.message\n    };\n}\nfunction formatError(error, router) {\n    const errorFormatter = router[Object.keys(router)[0]]?._def.errorFormatter ?? defaultErrorFormatter;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return errorFormatter(error);\n}\n\nconst colorize = (str, level)=>{\n    // TODO: Maybe check is shell supports colors\n    switch(level){\n        case \"error\":\n        case \"fatal\":\n            return `\\x1b[41m\\x1b[30m${str}\\x1b[0m`;\n        case \"warn\":\n            return `\\x1b[43m\\x1b[30m${str}\\x1b[0m`;\n        case \"info\":\n        case \"log\":\n            return `\\x1b[44m\\x1b[30m${str}\\x1b[0m`;\n        case \"debug\":\n            return `\\x1b[47m\\x1b[30m${str}\\x1b[0m`;\n        case \"trace\":\n            return `\\x1b[47m\\x1b[30m${str}\\x1b[0m`;\n        case \"success\":\n            return `\\x1b[42m\\x1b[30m${str}\\x1b[0m`;\n        default:\n            return str;\n    }\n};\nconst icons = {\n    fatal: \"⨯\",\n    error: \"⨯\",\n    warn: \"⚠️\",\n    info: \"ℹ\",\n    log: \"ℹ\",\n    debug: \"⚙\",\n    trace: \"→\",\n    success: \"✓\"\n};\nfunction formatStack(stack) {\n    const cwd = \"cwd\" in std_env__WEBPACK_IMPORTED_MODULE_4__.process && typeof std_env__WEBPACK_IMPORTED_MODULE_4__.process.cwd === \"function\" ? std_env__WEBPACK_IMPORTED_MODULE_4__.process.cwd() : \"__UnknownCWD__\";\n    return \"  \" + stack.split(\"\\n\").splice(1).map((l)=>l.trim().replace(\"file://\", \"\").replace(cwd + \"/\", \"\")).join(\"\\n  \");\n}\nfunction formatArgs(args) {\n    const fmtArgs = args.map((arg)=>{\n        if ((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(arg) && typeof arg.stack === \"string\") {\n            return arg.message + \"\\n\" + formatStack(arg.stack);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return arg;\n    });\n    return fmtArgs.map((arg)=>{\n        if (typeof arg === \"string\") {\n            return arg;\n        }\n        return JSON.stringify(arg, null, 4);\n    });\n}\nconst logger = (0,consola_core__WEBPACK_IMPORTED_MODULE_1__.createConsola)({\n    reporters: [\n        {\n            log: (logObj)=>{\n                const { type, tag, date, args } = logObj;\n                const icon = icons[type];\n                const logPrefix = colorize(` ${icon} ${tag} ${date.toLocaleTimeString()} `, type);\n                const lines = formatArgs(args).join(\" \") // concat all arguments to one space-separated string (like console does)\n                .split(\"\\n\") // split all the newlines (e.g. from logged JSON.stringified objects)\n                .map((l)=>logPrefix + \" \" + l) // prepend the log prefix to each line\n                .join(\"\\n\"); // join all the lines back together\n                // eslint-disable-next-line no-console\n                console.log(lines);\n            }\n        }\n    ],\n    defaults: {\n        tag: \"UPLOADTHING\"\n    }\n});\nconst initLogger = (level)=>{\n    // logger.wrapConsole();\n    logger.level = consola_core__WEBPACK_IMPORTED_MODULE_1__.LogLevels[level ?? \"info\"];\n};\n\nconst isValidResponse = (response)=>{\n    if (!response.ok) return false;\n    if (response.status >= 400) return false;\n    if (!response.headers.has(\"x-uploadthing-version\")) return false;\n    return true;\n};\nconst conditionalDevServer = async (opts)=>{\n    const fileData = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.pollForFileData)({\n        url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(`/api/pollUpload/${opts.fileKey}`),\n        apiKey: opts.apiKey,\n        sdkVersion: version,\n        fetch: opts.fetch\n    }, async (json)=>{\n        const file = json.fileData;\n        let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;\n        if (!callbackUrl.startsWith(\"http\")) callbackUrl = \"http://\" + callbackUrl;\n        logger.info(\"SIMULATING FILE UPLOAD WEBHOOK CALLBACK\", callbackUrl);\n        const payload = JSON.stringify({\n            status: \"uploaded\",\n            metadata: JSON.parse(file.metadata ?? \"{}\"),\n            file: {\n                url: `https://utfs.io/f/${encodeURIComponent(opts.fileKey)}`,\n                key: opts.fileKey,\n                name: file.fileName,\n                size: file.fileSize,\n                type: file.fileType,\n                customId: file.customId\n            }\n        });\n        const signature = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.signPayload)(payload, opts.apiKey);\n        try {\n            const response = await opts.fetch(callbackUrl, {\n                method: \"POST\",\n                body: payload,\n                headers: {\n                    \"uploadthing-hook\": \"callback\",\n                    \"x-uploadthing-signature\": signature\n                }\n            });\n            if (isValidResponse(response)) {\n                logger.success(\"Successfully simulated callback for file\", opts.fileKey);\n            } else {\n                throw new Error(\"Invalid response\");\n            }\n        } catch (e) {\n            logger.error(`Failed to simulate callback for file '${opts.fileKey}'. Is your webhook configured correctly?`);\n            logger.error(`  - Make sure the URL '${callbackUrl}' is accessible without any authentication. You can verify this by running 'curl -X POST ${callbackUrl}' in your terminal`);\n            logger.error(`  - Still facing issues? Read https://docs.uploadthing.com/faq for common issues`);\n        }\n        return file;\n    });\n    if (fileData !== undefined) return fileData;\n    logger.error(`Failed to simulate callback for file ${opts.fileKey}`);\n    throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n        code: \"UPLOAD_FAILED\",\n        message: \"File took too long to upload\"\n    });\n};\n\nfunction getParseFn(parser) {\n    if (typeof parser.parse === \"function\") {\n        return parser.parse;\n    }\n    throw new Error(\"Invalid parser\");\n}\n\n/**\n * Creates a wrapped fetch that will always forward a few headers to the server.\n */ const createUTFetch = (apiKey, fetch, fePackage, beAdapter)=>{\n    return async (endpoint, payload)=>{\n        const response = await fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(endpoint), {\n            method: \"POST\",\n            body: JSON.stringify(payload),\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"x-uploadthing-api-key\": apiKey,\n                \"x-uploadthing-version\": version,\n                \"x-uploadthing-fe-package\": fePackage,\n                \"x-uploadthing-be-adapter\": beAdapter\n            }\n        });\n        return response;\n    };\n};\nconst fileCountLimitHit = (files, routeConfig)=>{\n    const counts = {};\n    files.forEach((file)=>{\n        const type = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getTypeFromFileName)(file.name, (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.objectKeys)(routeConfig));\n        if (!counts[type]) {\n            counts[type] = 1;\n        } else {\n            counts[type] += 1;\n        }\n    });\n    for(const _key in counts){\n        const key = _key;\n        const count = counts[key];\n        const limit = routeConfig[key]?.maxFileCount;\n        if (!limit) {\n            logger.error(routeConfig, key);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"Invalid config during file count\",\n                cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`\n            });\n        }\n        if (count > limit) {\n            return {\n                limitHit: true,\n                type: key,\n                limit,\n                count\n            };\n        }\n    }\n    return {\n        limitHit: false\n    };\n};\nconst buildRequestHandler = (opts, adapter)=>{\n    return async (input)=>{\n        const isDev = opts.config?.isDev ?? std_env__WEBPACK_IMPORTED_MODULE_4__.isDevelopment;\n        const fetch = opts.config?.fetch ?? globalThis.fetch;\n        if (isDev) {\n            logger.info(\"UploadThing dev server is now running!\");\n        }\n        const { router, config } = opts;\n        const preferredOrEnvSecret = config?.uploadthingSecret ?? std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET;\n        const req = input.req;\n        const url = new URL(req.url);\n        // Get inputs from query and params\n        const params = url.searchParams;\n        const uploadthingHook = req.headers.get(\"uploadthing-hook\") ?? undefined;\n        const slug = params.get(\"slug\") ?? undefined;\n        const actionType = params.get(\"actionType\") ?? undefined;\n        const utFrontendPackage = req.headers.get(\"x-uploadthing-package\") ?? \"unknown\";\n        const clientVersion = req.headers.get(\"x-uploadthing-version\");\n        if (clientVersion != null && clientVersion !== version) {\n            logger.error(\"Client version mismatch\");\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"Client version mismatch\",\n                cause: `Server version: ${version}, Client version: ${clientVersion}`\n            });\n        }\n        // Validate inputs\n        if (!slug) {\n            logger.error(\"No slug provided in params:\", params);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"No slug provided in params\"\n            });\n        }\n        if (slug && typeof slug !== \"string\") {\n            const msg = `Expected slug to be of type 'string', got '${typeof slug}'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`slug` must be a string\",\n                cause: msg\n            });\n        }\n        if (actionType && typeof actionType !== \"string\") {\n            const msg = `Expected actionType to be of type 'string', got '${typeof actionType}'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`actionType` must be a string\",\n                cause: msg\n            });\n        }\n        if (uploadthingHook && typeof uploadthingHook !== \"string\") {\n            const msg = `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`;\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`uploadthingHook` must be a string\",\n                cause: msg\n            });\n        }\n        if (!preferredOrEnvSecret) {\n            const msg = `No secret provided, please set UPLOADTHING_SECRET in your env file or in the config`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"MISSING_ENV\",\n                message: `No secret provided`,\n                cause: msg\n            });\n        }\n        if (!preferredOrEnvSecret.startsWith(\"sk_\")) {\n            const msg = `Invalid secret provided, UPLOADTHING_SECRET must start with 'sk_'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"MISSING_ENV\",\n                message: \"Invalid API key. API keys must start with 'sk_'.\",\n                cause: msg\n            });\n        }\n        if (utFrontendPackage && typeof utFrontendPackage !== \"string\") {\n            const msg = `Expected x-uploadthing-package to be of type 'string', got '${typeof utFrontendPackage}'`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                message: \"`x-uploadthing-package` must be a string. eg. '@uploadthing/react'\",\n                cause: msg\n            });\n        }\n        const uploadable = router[slug];\n        if (!uploadable) {\n            const msg = `No file route found for slug ${slug}`;\n            logger.error(msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"NOT_FOUND\",\n                message: msg\n            });\n        }\n        const utFetch = createUTFetch(preferredOrEnvSecret, fetch, utFrontendPackage, adapter);\n        logger.debug(\"All request input is valid\", {\n            slug,\n            actionType,\n            uploadthingHook\n        });\n        if (uploadthingHook === \"callback\") {\n            // This is when we receive the webhook from uploadthing\n            const maybeReqBody = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n            logger.debug(\"Handling callback request with input:\", maybeReqBody);\n            if (maybeReqBody instanceof Error) {\n                logger.error(\"Invalid request body\", maybeReqBody);\n                return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"Invalid request body\",\n                    cause: maybeReqBody\n                });\n            }\n            const verified = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.verifySignature)(JSON.stringify(maybeReqBody), req.headers.get(\"x-uploadthing-signature\"), preferredOrEnvSecret);\n            logger.debug(\"Signature verified:\", verified);\n            if (!verified) {\n                logger.error(\"Invalid signature\");\n                return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"Invalid signature\"\n                });\n            }\n            const resolverArgs = {\n                file: maybeReqBody.file,\n                metadata: maybeReqBody.metadata\n            };\n            logger.debug(\"Running 'onUploadComplete' callback with input:\", resolverArgs);\n            const res = await uploadable.resolver(resolverArgs);\n            const payload = {\n                fileKey: maybeReqBody.file.key,\n                callbackData: res ?? null\n            };\n            logger.debug(\"'onUploadComplete' callback finished. Sending response to UploadThing:\", payload);\n            const callbackResponse = await utFetch(\"/api/serverCallback\", payload);\n            logger.debug(\"UploadThing responded with status:\", callbackResponse.status);\n            return {\n                status: 200,\n                body: null\n            };\n        }\n        if (!actionType || !uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.VALID_ACTION_TYPES.includes(actionType)) {\n            // This would either be someone spamming or the AWS webhook\n            const msg = `Expected ${uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.VALID_ACTION_TYPES.map((x)=>`\"${x}\"`).join(\", \").replace(/,(?!.*,)/, \" or\")} but got \"${actionType}\"`;\n            logger.error(\"Invalid action type.\", msg);\n            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"BAD_REQUEST\",\n                cause: `Invalid action type ${actionType}`,\n                message: msg\n            });\n        }\n        switch(actionType){\n            case \"upload\":\n                {\n                    const maybeInput = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n                    if (maybeInput instanceof Error) {\n                        logger.error(\"Invalid request body\", maybeInput);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid request body\",\n                            cause: maybeInput\n                        });\n                    }\n                    logger.debug(\"Handling upload request with input:\", maybeInput);\n                    const { files, input: userInput } = maybeInput;\n                    // Validate without Zod (for now)\n                    if (!Array.isArray(files) || !files.every((f)=>(0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(f) && typeof f.name === \"string\" && typeof f.size === \"number\" && typeof f.type === \"string\")) {\n                        const msg = `Expected files to be of type '{name:string, size:number, type:string}[]', got '${JSON.stringify(files)}'`;\n                        logger.error(msg);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Files must be an array of objects with name and size\",\n                            cause: msg\n                        });\n                    }\n                    // validate the input\n                    let parsedInput = {};\n                    try {\n                        logger.debug(\"Parsing input\");\n                        const inputParser = uploadable._def.inputParser;\n                        parsedInput = await getParseFn(inputParser)(userInput);\n                        logger.debug(\"Input parsed successfully\", parsedInput);\n                    } catch (error) {\n                        logger.error(\"An error occurred trying to parse input:\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid input.\",\n                            cause: error\n                        });\n                    }\n                    let metadata = {};\n                    try {\n                        logger.debug(\"Running middleware\");\n                        metadata = await uploadable._def.middleware({\n                            ...input.middlewareArgs,\n                            input: parsedInput,\n                            files\n                        });\n                        logger.debug(\"Middleware finished successfully with:\", metadata);\n                    } catch (error) {\n                        logger.error(\"An error occurred in your middleware function:\", error);\n                        if (error instanceof _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError) return error;\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"INTERNAL_SERVER_ERROR\",\n                            message: \"Failed to run middleware.\",\n                            cause: error\n                        });\n                    }\n                    if (metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles] && metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles].length !== files.length) {\n                        const msg = `Expected files override to have the same length as original files, got ${metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles].length} but expected ${files.length}`;\n                        logger.error(msg);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Files override must have the same length as files\",\n                            cause: msg\n                        });\n                    }\n                    // Attach customIds from middleware to the files\n                    const filesWithCustomIds = files.map((file, idx)=>{\n                        const theirs = metadata[uploadthing_internal_types__WEBPACK_IMPORTED_MODULE_2__.UTFiles]?.[idx];\n                        if (theirs && theirs.size !== file.size) {\n                            logger.warn(\"File size mismatch. Reverting to original size\");\n                        }\n                        return {\n                            name: theirs?.name ?? file.name,\n                            size: file.size,\n                            customId: theirs?.customId\n                        };\n                    });\n                    // FILL THE ROUTE CONFIG so the server only has one happy path\n                    let parsedConfig;\n                    try {\n                        logger.debug(\"Parsing route config\", uploadable._def.routerConfig);\n                        parsedConfig = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fillInputRouteConfig)(uploadable._def.routerConfig);\n                        logger.debug(\"Route config parsed successfully\", parsedConfig);\n                    } catch (error) {\n                        logger.error(\"Invalid route config\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid config.\",\n                            cause: error\n                        });\n                    }\n                    try {\n                        logger.debug(\"Checking file count limit\", files);\n                        const { limitHit, count, limit, type } = fileCountLimitHit(files, parsedConfig);\n                        if (limitHit) {\n                            const msg = `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`;\n                            logger.error(msg);\n                            return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: \"BAD_REQUEST\",\n                                message: \"File limit exceeded\",\n                                cause: msg\n                            });\n                        }\n                        logger.debug(\"File count limit check passed\");\n                    } catch (error) {\n                        logger.error(\"Invalid route config\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid config.\",\n                            cause: error\n                        });\n                    }\n                    const callbackUrl = resolveCallbackUrl({\n                        config,\n                        req,\n                        url,\n                        isDev\n                    });\n                    logger.debug(\"Retrieving presigned URLs from UploadThing. Callback URL is:\", callbackUrl.href);\n                    const uploadthingApiResponse = await utFetch(\"/api/prepareUpload\", {\n                        files: filesWithCustomIds,\n                        routeConfig: parsedConfig,\n                        metadata,\n                        callbackUrl: callbackUrl.origin + callbackUrl.pathname,\n                        callbackSlug: slug\n                    });\n                    // This is when we send the response back to the user's form so they can submit the files\n                    const parsedResponse = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(uploadthingApiResponse);\n                    if (!uploadthingApiResponse.ok || parsedResponse instanceof Error) {\n                        logger.error(\"Unable to get presigned URLs\", parsedResponse);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"URL_GENERATION_FAILED\",\n                            message: \"Unable to get presigned urls\",\n                            cause: parsedResponse\n                        });\n                    }\n                    logger.debug(\"UploadThing responded with:\", parsedResponse);\n                    logger.debug(\"Sending presigned URLs to client\");\n                    // This is when we send the response back to the user's form so they can submit the files\n                    let promise = undefined;\n                    if (isDev) {\n                        promise = Promise.all(parsedResponse.map((file)=>conditionalDevServer({\n                                fileKey: file.key,\n                                apiKey: preferredOrEnvSecret,\n                                fetch\n                            }).catch((error)=>{\n                                logger.error(\"Err\", error);\n                            })));\n                    }\n                    return {\n                        cleanup: promise,\n                        body: parsedResponse,\n                        status: 200\n                    };\n                }\n            case \"multipart-complete\":\n                {\n                    const maybeReqBody = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n                    if (maybeReqBody instanceof Error) {\n                        logger.error(\"Invalid request body\", maybeReqBody);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid request body\",\n                            cause: maybeReqBody\n                        });\n                    }\n                    logger.debug(\"Handling multipart-complete request with input:\", maybeReqBody);\n                    logger.debug(\"Notifying UploadThing that multipart upload is complete\");\n                    const completeRes = await utFetch(\"/api/completeMultipart\", {\n                        fileKey: maybeReqBody.fileKey,\n                        uploadId: maybeReqBody.uploadId,\n                        etags: maybeReqBody.etags\n                    });\n                    if (!completeRes.ok) {\n                        logger.error(\"Failed to notify UploadThing that multipart upload is complete\");\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"UPLOAD_FAILED\",\n                            message: \"Failed to complete multipart upload\",\n                            cause: completeRes\n                        });\n                    }\n                    logger.debug(\"UploadThing responded with:\", completeRes.status);\n                    return {\n                        status: 200,\n                        body: null\n                    };\n                }\n            case \"failure\":\n                {\n                    const maybeReqBody = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(req);\n                    if (maybeReqBody instanceof Error) {\n                        logger.error(\"Invalid request body\", maybeReqBody);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"BAD_REQUEST\",\n                            message: \"Invalid request body\",\n                            cause: maybeReqBody\n                        });\n                    }\n                    const { fileKey, uploadId } = maybeReqBody;\n                    logger.debug(\"Handling failure request with input:\", maybeReqBody);\n                    logger.debug(\"Notifying UploadThing that upload failed\");\n                    // Tell uploadthing to mark the upload as failed\n                    const uploadthingApiResponse = await utFetch(\"/api/failureCallback\", {\n                        fileKey,\n                        uploadId\n                    });\n                    if (!uploadthingApiResponse.ok) {\n                        const parsedResponse = await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)(uploadthingApiResponse);\n                        logger.error(\"Failed to mark upload as failed\", parsedResponse);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"INTERNAL_SERVER_ERROR\",\n                            message: \"Unable to mark upload as failed\",\n                            cause: parsedResponse\n                        });\n                    }\n                    logger.debug(\"UploadThing responded with:\", uploadthingApiResponse);\n                    logger.debug(\"Running 'onUploadError' callback\");\n                    try {\n                        // Run the onUploadError callback\n                        uploadable._def.onUploadError({\n                            error: new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                                code: \"UPLOAD_FAILED\",\n                                message: `Upload failed for ${fileKey}`\n                            }),\n                            fileKey\n                        });\n                    } catch (error) {\n                        logger.error(\"Failed to run onUploadError callback. You probably shouldn't be throwing errors in your callback.\", error);\n                        return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                            code: \"INTERNAL_SERVER_ERROR\",\n                            message: \"Failed to run onUploadError callback\",\n                            cause: error\n                        });\n                    }\n                    return {\n                        status: 200,\n                        body: null\n                    };\n                }\n            default:\n                {\n                    // This should never happen\n                    return new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                        code: \"BAD_REQUEST\",\n                        message: `Invalid action type`\n                    });\n                }\n        }\n    };\n};\nfunction resolveCallbackUrl(opts) {\n    let callbackUrl = opts.url;\n    if (opts.config?.callbackUrl) {\n        callbackUrl = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(opts.config.callbackUrl);\n    } else if (std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_URL) {\n        callbackUrl = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_URL);\n    }\n    if (opts.isDev || !callbackUrl.host.includes(\"localhost\")) {\n        return callbackUrl;\n    }\n    // Production builds have to have a public URL so UT can send webhook\n    // Parse the URL from the headers\n    const headers = opts.req.headers;\n    let parsedFromHeaders = headers.get(\"origin\") ?? headers.get(\"referer\") ?? headers.get(\"host\") ?? headers.get(\"x-forwarded-host\");\n    if (parsedFromHeaders && !parsedFromHeaders.includes(\"http\")) {\n        parsedFromHeaders = (headers.get(\"x-forwarded-proto\") ?? \"https\") + \"://\" + parsedFromHeaders;\n    }\n    if (!parsedFromHeaders || parsedFromHeaders.includes(\"localhost\")) {\n        // Didn't find a valid URL in the headers, log a warning and use the original url anyway\n        logger.warn(\"You are using a localhost callback url in production which is not supported.\", \"Read more and learn how to fix it here: https://docs.uploadthing.com/faq#my-callback-runs-in-development-but-not-in-production\");\n        return callbackUrl;\n    }\n    return (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.resolveMaybeUrlArg)(parsedFromHeaders);\n}\nconst buildPermissionsInfoHandler = (opts)=>{\n    return ()=>{\n        const r = opts.router;\n        const permissions = Object.keys(r).map((k)=>{\n            const route = r[k];\n            const config = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.fillInputRouteConfig)(route._def.routerConfig);\n            return {\n                slug: k,\n                config\n            };\n        });\n        return permissions;\n    };\n};\n\nfunction incompatibleNodeGuard() {\n    if (typeof std_env__WEBPACK_IMPORTED_MODULE_4__.process === \"undefined\") return;\n    let major;\n    let minor;\n    const maybeNodeVersion = std_env__WEBPACK_IMPORTED_MODULE_4__.process.versions?.node?.split(\".\");\n    if (maybeNodeVersion) {\n        [major, minor] = maybeNodeVersion.map((v)=>parseInt(v, 10));\n    }\n    const maybeNodePath = std_env__WEBPACK_IMPORTED_MODULE_4__.process.env?.NODE;\n    if (!major && maybeNodePath) {\n        const nodeVersion = /v(\\d+)\\.(\\d+)\\.(\\d+)/.exec(maybeNodePath)?.[0];\n        if (nodeVersion) {\n            [major, minor] = nodeVersion.substring(1).split(\".\").map((v)=>parseInt(v, 10));\n        }\n    }\n    if (!major || !minor) return;\n    // Require ^18.13.0\n    if (major > 18) return;\n    if (major === 18 && minor >= 13) return;\n    logger.fatal(`YOU ARE USING A LEGACY (${major}.${minor}) NODE VERSION WHICH ISN'T OFFICIALLY SUPPORTED. PLEASE UPGRADE TO NODE ^18.13.`);\n    // Kill the process if it isn't going to work correctly anyway\n    // If we've gotten this far we know we have a Node.js runtime so exit is defined. Override std-env type.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n    std_env__WEBPACK_IMPORTED_MODULE_4__.process.exit?.(1);\n}\n\nfunction internalCreateBuilder(initDef = {}) {\n    const _def = {\n        // Default router config\n        routerConfig: {\n            image: {\n                maxFileSize: \"4MB\"\n            }\n        },\n        inputParser: {\n            parse: ()=>undefined,\n            _input: undefined,\n            _output: undefined\n        },\n        middleware: ()=>({}),\n        onUploadError: ()=>({}),\n        errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,\n        // Overload with properties passed in\n        ...initDef\n    };\n    return {\n        input (userParser) {\n            return internalCreateBuilder({\n                ..._def,\n                inputParser: userParser\n            });\n        },\n        middleware (userMiddleware) {\n            return internalCreateBuilder({\n                ..._def,\n                middleware: userMiddleware\n            });\n        },\n        onUploadComplete (userUploadComplete) {\n            return {\n                _def,\n                resolver: userUploadComplete\n            };\n        },\n        onUploadError (userOnUploadError) {\n            return internalCreateBuilder({\n                ..._def,\n                onUploadError: userOnUploadError\n            });\n        }\n    };\n}\nfunction createBuilder(opts) {\n    return (input)=>{\n        return internalCreateBuilder({\n            routerConfig: input,\n            ...opts\n        });\n    };\n}\n\nconst maybeParseResponseXML = (maybeXml)=>{\n    const codeMatch = maybeXml.match(/<Code>(.*?)<\\/Code>/s);\n    const messageMatch = maybeXml.match(/<Message>(.*?)<\\/Message>/s);\n    const code = codeMatch?.[1];\n    const message = messageMatch?.[1];\n    if (!code || !message) return null;\n    return {\n        code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE,\n        message\n    };\n};\n/**\n * Map S3 error codes to UploadThing error codes\n *\n * This is a subset of the S3 error codes, based on what seemed most likely to\n * occur in uploadthing. For a full list of S3 error codes, see:\n * https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html\n */ const DEFAULT_ERROR_CODE = \"UPLOAD_FAILED\";\nconst s3CodeToUploadThingCode = {\n    AccessDenied: \"FORBIDDEN\",\n    EntityTooSmall: \"TOO_SMALL\",\n    EntityTooLarge: \"TOO_LARGE\",\n    ExpiredToken: \"FORBIDDEN\",\n    IncorrectNumberOfFilesInPostRequest: \"TOO_MANY_FILES\",\n    InternalError: \"INTERNAL_SERVER_ERROR\",\n    KeyTooLongError: \"KEY_TOO_LONG\",\n    MaxMessageLengthExceeded: \"TOO_LARGE\"\n};\n\n/**\n * Used by server uploads where progress is not needed.\n * Uses normal fetch API.\n */ async function uploadPart(opts, retryCount = 0) {\n    const s3Res = await opts.fetch(opts.url, {\n        method: \"PUT\",\n        body: opts.chunk,\n        headers: {\n            \"Content-Type\": opts.contentType,\n            \"Content-Disposition\": (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.contentDisposition)(opts.contentDisposition, opts.fileName)\n        }\n    });\n    if (s3Res.ok) {\n        const etag = s3Res.headers.get(\"Etag\");\n        if (!etag) {\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"UPLOAD_FAILED\",\n                message: \"Missing Etag header from uploaded part\"\n            });\n        }\n        return etag.replace(/\"/g, \"\");\n    }\n    if (retryCount < opts.maxRetries) {\n        // Retry after exponential backoff\n        const delay = 2 ** retryCount * 1000;\n        await new Promise((r)=>setTimeout(r, delay));\n        return uploadPart(opts, retryCount++);\n    }\n    // Max retries exceeded, tell UT server that upload failed\n    await opts.fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(\"/api/failureCallback\"), {\n        method: \"POST\",\n        body: JSON.stringify({\n            fileKey: opts.key\n        }),\n        headers: opts.utRequestHeaders\n    });\n    const text = await s3Res.text();\n    const parsed = maybeParseResponseXML(text);\n    if (parsed?.message) {\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: parsed.message\n        });\n    }\n    throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n        code: \"UPLOAD_FAILED\",\n        message: \"Failed to upload file to storage provider\",\n        cause: s3Res\n    });\n}\n\nfunction guardServerOnly() {\n    if (typeof window !== \"undefined\") {\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"The `utapi` can only be used on the server.\"\n        });\n    }\n}\nfunction getApiKeyOrThrow(apiKey) {\n    if (apiKey) return apiKey;\n    if (std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET) return std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET;\n    throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n        code: \"MISSING_ENV\",\n        message: \"Missing `UPLOADTHING_SECRET` env variable.\"\n    });\n}\nconst uploadFilesInternal = async (data, opts)=>{\n    // Request presigned URLs for each file\n    const fileData = data.files.map((file)=>({\n            name: file.name ?? \"unnamed-blob\",\n            type: file.type,\n            size: file.size,\n            ...\"customId\" in file ? {\n                customId: file.customId\n            } : {}\n        }));\n    logger.debug(\"Getting presigned URLs for files\", fileData);\n    const res = await opts.fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(\"/api/uploadFiles\"), {\n        method: \"POST\",\n        headers: opts.utRequestHeaders,\n        cache: \"no-store\",\n        body: JSON.stringify({\n            files: fileData,\n            metadata: data.metadata,\n            contentDisposition: data.contentDisposition,\n            acl: data.acl\n        })\n    });\n    if (!res.ok) {\n        const error = await _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.fromResponse(res);\n        logger.debug(\"Failed getting presigned URLs:\", error);\n        throw error;\n    }\n    const json = await res.json();\n    logger.debug(\"Got presigned URLs:\", json.data);\n    logger.debug(\"Starting uploads...\");\n    // Upload each file to S3 in chunks using multi-part uploads\n    const uploads = await Promise.allSettled(data.files.map(async (file, i)=>{\n        const presigned = json.data[i];\n        if (!presigned) {\n            logger.error(\"Failed to generate presigned URL for file:\", file, presigned);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"URL_GENERATION_FAILED\",\n                message: \"Failed to generate presigned URL\",\n                cause: JSON.stringify(presigned)\n            });\n        }\n        if (\"urls\" in presigned) {\n            await uploadMultipart(file, presigned, {\n                ...opts\n            });\n        } else {\n            await uploadPresignedPost(file, presigned, {\n                ...opts\n            });\n        }\n        // Poll for file to be available\n        logger.debug(\"Polling for file data...\");\n        await (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.pollForFileData)({\n            url: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(`/api/pollUpload/${presigned.key}`),\n            apiKey: opts.utRequestHeaders[\"x-uploadthing-api-key\"],\n            sdkVersion: version,\n            fetch: opts.fetch\n        });\n        logger.debug(\"Polling complete.\");\n        return {\n            key: presigned.key,\n            url: presigned.fileUrl,\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            customId: \"customId\" in file ? file.customId ?? null : null\n        };\n    }));\n    logger.debug(\"All uploads complete, aggregating results...\");\n    return uploads.map((upload)=>{\n        if (upload.status === \"fulfilled\") {\n            const data = upload.value;\n            return {\n                data,\n                error: null\n            };\n        }\n        // We only throw UploadThingErrors, so this is safe\n        const reason = upload.reason;\n        const error = _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.toObject(reason);\n        return {\n            data: null,\n            error\n        };\n    });\n};\nasync function uploadMultipart(file, presigned, opts) {\n    logger.debug(\"Uploading file\", file.name, \"with\", presigned.urls.length, \"chunks of size\", presigned.chunkSize, \"bytes each\");\n    const etags = await Promise.all(presigned.urls.map(async (url, index)=>{\n        const offset = presigned.chunkSize * index;\n        const end = Math.min(offset + presigned.chunkSize, file.size);\n        const chunk = file.slice(offset, end);\n        const etag = await uploadPart({\n            fetch: opts.fetch,\n            url,\n            chunk: chunk,\n            contentDisposition: presigned.contentDisposition,\n            contentType: file.type,\n            fileName: file.name,\n            maxRetries: 10,\n            key: presigned.key,\n            utRequestHeaders: opts.utRequestHeaders\n        });\n        logger.debug(\"Part\", index + 1, \"uploaded successfully:\", etag);\n        return {\n            tag: etag,\n            partNumber: index + 1\n        };\n    }));\n    logger.debug(\"File\", file.name, \"uploaded successfully. Notifying UploadThing to complete multipart upload.\");\n    // Complete multipart upload\n    const completionRes = await opts.fetch((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(\"/api/completeMultipart\"), {\n        method: \"POST\",\n        body: JSON.stringify({\n            fileKey: presigned.key,\n            uploadId: presigned.uploadId,\n            etags\n        }),\n        headers: opts.utRequestHeaders\n    });\n    logger.debug(\"UploadThing responsed with status:\", completionRes.status);\n}\nasync function uploadPresignedPost(file, presigned, opts) {\n    logger.debug(\"Uploading file\", file.name, \"using presigned POST URL\");\n    const formData = new FormData();\n    Object.entries(presigned.fields).forEach(([k, v])=>formData.append(k, v));\n    formData.append(\"file\", file); // File data **MUST GO LAST**\n    const res = await opts.fetch(presigned.url, {\n        method: \"POST\",\n        body: formData,\n        headers: new Headers({\n            Accept: \"application/xml\"\n        })\n    });\n    if (!res.ok) {\n        const text = await res.text();\n        logger.error(\"Failed to upload file:\", text);\n        throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n            code: \"UPLOAD_FAILED\",\n            message: \"Failed to upload file\",\n            cause: text\n        });\n    }\n    logger.debug(\"File\", file.name, \"uploaded successfully\");\n}\nfunction parseTimeToSeconds(time) {\n    const match = time.toString().split(/(\\d+)/).filter(Boolean);\n    const num = Number(match[0]);\n    const unit = (match[1] ?? \"s\").trim().slice(0, 1);\n    const multiplier = {\n        s: 1,\n        m: 60,\n        h: 3600,\n        d: 86400\n    }[unit];\n    return num * multiplier;\n}\n\n/**\n * Extension of the Blob class that simplifies setting the `name` and `customId` properties,\n * similar to the built-in File class from Node > 20.\n */ class UTFile extends Blob {\n    constructor(parts, name, options){\n        const optionsWithDefaults = {\n            ...options,\n            type: options?.type ?? ((0,_uploadthing_mime_types__WEBPACK_IMPORTED_MODULE_3__.lookup)(name) || undefined),\n            lastModified: options?.lastModified ?? Date.now()\n        };\n        super(parts, optionsWithDefaults);\n        this.name = name;\n        this.customId = optionsWithDefaults.customId;\n        this.lastModified = optionsWithDefaults.lastModified;\n    }\n}\nclass UTApi {\n    constructor(opts){\n        /**\n   * Request to delete files from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * await deleteFiles(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   *\n   * @example\n   * await deleteFiles([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   *\n   * @example\n   * await deleteFiles(\"myCustomIdentifier\", { keyType: \"customId\" })\n   */ this.deleteFiles = async (keys, opts)=>{\n            guardServerOnly();\n            const { keyType = this.defaultKeyType } = opts ?? {};\n            return this.requestUploadThing(\"/api/deleteFile\", keyType === \"fileKey\" ? {\n                fileKeys: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            } : {\n                customIds: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            }, \"An unknown error occurred while deleting files.\");\n        };\n        /**\n   * Request file URLs from UploadThing storage.\n   * @param {string | string[]} fileKeys\n   *\n   * @example\n   * const data = await getFileUrls(\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\");\n   * console.log(data); // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\"}]\n   *\n   * @example\n   * const data = await getFileUrls([\"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\",\"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"])\n   * console.log(data) // [{key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", url: \"https://uploadthing.com/f/2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\" },{key: \"1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\", url: \"https://uploadthing.com/f/1649353b-04ea-48a2-9db7-31de7f562c8d_image2.jpg\"}]\n   */ this.getFileUrls = async (keys, opts)=>{\n            guardServerOnly();\n            const { keyType = this.defaultKeyType } = opts ?? {};\n            const json = await this.requestUploadThing(\"/api/getFileUrl\", keyType === \"fileKey\" ? {\n                fileKeys: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            } : {\n                customIds: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(keys)\n            }, \"An unknown error occurred while retrieving file URLs.\");\n            return json.data;\n        };\n        /**\n   * Request file list from UploadThing storage.\n   * @param {object} opts\n   * @param {number} opts.limit The maximum number of files to return\n   * @param {number} opts.offset The number of files to skip\n   *\n   * @example\n   * const data = await listFiles({ limit: 1 });\n   * console.log(data); // { key: \"2e0fdb64-9957-4262-8e45-f372ba903ac8_image.jpg\", id: \"2e0fdb64-9957-4262-8e45-f372ba903ac8\" }\n   */ this.listFiles = async (opts)=>{\n            guardServerOnly();\n            const json = await this.requestUploadThing(\"/api/listFiles\", {\n                ...opts\n            }, \"An unknown error occurred while listing files.\");\n            return json.files;\n        };\n        this.renameFiles = async (updates)=>{\n            guardServerOnly();\n            return this.requestUploadThing(\"/api/renameFiles\", {\n                updates: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(updates)\n            }, \"An unknown error occurred while renaming files.\");\n        };\n        /** @deprecated Use {@link renameFiles} instead. */ this.renameFile = this.renameFiles;\n        this.getUsageInfo = async ()=>{\n            guardServerOnly();\n            return this.requestUploadThing(\"/api/getUsageInfo\", {}, \"An unknown error occurred while getting usage info.\");\n        };\n        /** Request a presigned url for a private file(s) */ this.getSignedURL = async (key, opts)=>{\n            guardServerOnly();\n            const expiresIn = opts?.expiresIn ? parseTimeToSeconds(opts.expiresIn) : undefined;\n            const { keyType = this.defaultKeyType } = opts ?? {};\n            if (opts?.expiresIn && isNaN(expiresIn)) {\n                throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"expiresIn must be a valid time string, for example '1d', '2 days', or a number of seconds.\"\n                });\n            }\n            if (expiresIn && expiresIn > 86400 * 7) {\n                throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"expiresIn must be less than 7 days (604800 seconds).\"\n                });\n            }\n            const json = await this.requestUploadThing(\"/api/requestFileAccess\", keyType === \"fileKey\" ? {\n                fileKey: key,\n                expiresIn\n            } : {\n                customId: key,\n                expiresIn\n            }, \"An unknown error occurred while retrieving presigned URLs.\");\n            return json.url;\n        };\n        this.fetch = opts?.fetch ?? globalThis.fetch;\n        this.apiKey = opts?.apiKey ?? std_env__WEBPACK_IMPORTED_MODULE_4__.process.env.UPLOADTHING_SECRET;\n        this.defaultHeaders = {\n            \"Content-Type\": \"application/json\",\n            \"x-uploadthing-api-key\": this.apiKey,\n            \"x-uploadthing-version\": version,\n            \"x-uploadthing-be-adapter\": \"server-sdk\"\n        };\n        this.defaultKeyType = opts?.defaultKeyType ?? \"fileKey\";\n        initLogger(opts?.logLevel);\n        // Assert some stuff\n        guardServerOnly();\n        getApiKeyOrThrow(this.apiKey);\n        if (!this.apiKey?.startsWith(\"sk_\")) {\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"MISSING_ENV\",\n                message: \"Invalid API key. API keys must start with `sk_`.\"\n            });\n        }\n        incompatibleNodeGuard();\n    }\n    async requestUploadThing(pathname, body, fallbackErrorMessage) {\n        const url = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.generateUploadThingURL)(pathname);\n        logger.debug(\"Requesting UploadThing:\", {\n            url,\n            body,\n            headers: this.defaultHeaders\n        });\n        const res = await this.fetch(url, {\n            method: \"POST\",\n            cache: \"no-store\",\n            headers: this.defaultHeaders,\n            body: JSON.stringify(body)\n        });\n        logger.debug(\"UploadThing responsed with status:\", res.status);\n        const json = await res.json();\n        if (!res.ok || \"error\" in json) {\n            logger.error(\"Error:\", json);\n            throw new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                code: \"INTERNAL_SERVER_ERROR\",\n                message: \"error\" in json && typeof json.error === \"string\" ? json.error : fallbackErrorMessage\n            });\n        }\n        logger.debug(\"UploadThing response:\", json);\n        return json;\n    }\n    async uploadFiles(files, opts) {\n        guardServerOnly();\n        const uploads = await uploadFilesInternal({\n            files: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(files),\n            metadata: opts?.metadata ?? {},\n            contentDisposition: opts?.contentDisposition ?? \"inline\",\n            acl: opts?.acl\n        }, {\n            fetch: this.fetch,\n            utRequestHeaders: this.defaultHeaders\n        });\n        const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];\n        logger.debug(\"Finished uploading:\", uploadFileResponse);\n        return uploadFileResponse;\n    }\n    async uploadFilesFromUrl(urls, opts) {\n        guardServerOnly();\n        const formData = new FormData();\n        formData.append(\"metadata\", JSON.stringify(opts?.metadata ?? {}));\n        const downloadErrors = {};\n        const files = await Promise.all((0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(urls).map(async (_url, index)=>{\n            let url = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(_url) ? _url.url : _url;\n            if (typeof url === \"string\") {\n                // since dataurls will result in name being too long, tell the user\n                // to use uploadFiles instead.\n                if (url.startsWith(\"data:\")) {\n                    downloadErrors[index] = _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.toObject(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                        code: \"BAD_REQUEST\",\n                        message: \"Please use uploadFiles() for data URLs. uploadFilesFromUrl() is intended for use with remote URLs only.\"\n                    }));\n                    return undefined;\n                }\n                url = new URL(url);\n            }\n            const { name = url.pathname.split(\"/\").pop() ?? \"unknown-filename\", customId = undefined } = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.isObject)(_url) ? _url : {};\n            // Download the file on the user's server to avoid egress charges\n            logger.debug(\"Downloading file:\", url);\n            const fileResponse = await this.fetch(url);\n            if (!fileResponse.ok) {\n                downloadErrors[index] = _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError.toObject(new _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError({\n                    code: \"BAD_REQUEST\",\n                    message: \"Failed to download requested file.\",\n                    cause: fileResponse\n                }));\n                return undefined;\n            }\n            logger.debug(\"Finished downloading file. Reading blob...\");\n            const blob = await fileResponse.blob();\n            logger.debug(\"Finished reading blob.\");\n            return new UTFile([\n                blob\n            ], name, {\n                customId\n            });\n        })).then((files)=>files.filter((x)=>x !== undefined));\n        logger.debug(\"Uploading files:\", files);\n        const uploads = await uploadFilesInternal({\n            files,\n            metadata: opts?.metadata ?? {},\n            contentDisposition: opts?.contentDisposition ?? \"inline\",\n            acl: opts?.acl\n        }, {\n            fetch: this.fetch,\n            utRequestHeaders: this.defaultHeaders\n        });\n        /** Put it all back together, preserve the order of files */ const responses = (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.asArray)(urls).map((_, index)=>{\n            if (downloadErrors[index]) {\n                return {\n                    data: null,\n                    error: downloadErrors[index]\n                };\n            }\n            return uploads.shift();\n        });\n        /** Return single object or array based on input urls */ const uploadFileResponse = Array.isArray(urls) ? responses : responses[0];\n        logger.debug(\"Finished uploading:\", uploadFileResponse);\n        return uploadFileResponse;\n    }\n}\n\nconst createUploadthing = (opts)=>createBuilder(opts);\n/** @internal */ const INTERNAL_DO_NOT_USE_createRouteHandlerCore = (opts, adapter)=>{\n    initLogger(opts.config?.logLevel);\n    incompatibleNodeGuard();\n    const requestHandler = buildRequestHandler(opts, adapter);\n    const getBuildPerms = buildPermissionsInfoHandler(opts);\n    const POST = async (request)=>{\n        const req = request instanceof Request ? request : request.request;\n        const response = await requestHandler({\n            req,\n            middlewareArgs: {\n                req,\n                res: undefined,\n                event: undefined\n            }\n        });\n        if (response instanceof _uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.UploadThingError) {\n            return new Response(JSON.stringify(formatError(response, opts.router)), {\n                status: (0,_uploadthing_shared__WEBPACK_IMPORTED_MODULE_0__.getStatusCodeFromError)(response),\n                headers: {\n                    \"x-uploadthing-version\": version\n                }\n            });\n        }\n        if (response.status !== 200) {\n            // We messed up - this should never happen\n            return new Response(\"An unknown error occurred\", {\n                status: 500,\n                headers: {\n                    \"x-uploadthing-version\": version\n                }\n            });\n        }\n        const res = new Response(JSON.stringify(response.body), {\n            status: response.status,\n            headers: {\n                \"x-uploadthing-version\": version\n            }\n        });\n        // @ts-expect-error - this is a custom property\n        res.cleanup = response.cleanup;\n        return res;\n    };\n    const GET = (request)=>{\n        return new Response(JSON.stringify(getBuildPerms()), {\n            status: 200,\n            headers: {\n                \"x-uploadthing-version\": version\n            }\n        });\n    };\n    return {\n        GET,\n        POST\n    };\n};\nconst createRouteHandler = (opts)=>INTERNAL_DO_NOT_USE_createRouteHandlerCore(opts, \"server\");\nconst extractRouterConfig = (router)=>buildPermissionsInfoHandler({\n        router\n    })();\n/**\n * @deprecated Use {@link createRouteHandler} instead\n */ const createServerHandler = createRouteHandler;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvc2VydmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVSO0FBQ2hPO0FBQ047QUFDTztBQUNpQjtBQUNwQjtBQUNKOztBQUVqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQSxzQ0FBc0MsSUFBSTtBQUMxQztBQUNBLHNDQUFzQyxJQUFJO0FBQzFDO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFnQixXQUFXLDRDQUFPLHNCQUFzQiw0Q0FBTztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWUsMkRBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBLCtDQUErQyxNQUFNLEVBQUUsS0FBSyxFQUFFLDJCQUEyQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFTO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9FQUFlO0FBQzFDLGFBQWEsMkVBQXNCLG9CQUFvQixhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQSx3Q0FBd0MsaUVBQWdCLGNBQWMsaUVBQWdCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUZBQXVGLDREQUFPO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdDQUFnQyxpRUFBZ0I7QUFDaEQ7QUFDQSx3QkFBd0IsMkVBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDOztBQUVzSiIsInNvdXJjZXMiOlsid2VicGFjazovL29iamVjdC1kZXRlY3Rpb24vLi9ub2RlX21vZHVsZXMvdXBsb2FkdGhpbmcvc2VydmVyL2luZGV4LmpzPzAxM2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNPYmplY3QsIHBvbGxGb3JGaWxlRGF0YSwgZ2VuZXJhdGVVcGxvYWRUaGluZ1VSTCwgc2lnblBheWxvYWQsIFVwbG9hZFRoaW5nRXJyb3IsIGZpbGxJbnB1dFJvdXRlQ29uZmlnLCBzYWZlUGFyc2VKU09OLCB2ZXJpZnlTaWduYXR1cmUsIHJlc29sdmVNYXliZVVybEFyZywgZ2V0VHlwZUZyb21GaWxlTmFtZSwgb2JqZWN0S2V5cywgY29udGVudERpc3Bvc2l0aW9uLCBhc0FycmF5LCBnZXRTdGF0dXNDb2RlRnJvbUVycm9yIH0gZnJvbSAnQHVwbG9hZHRoaW5nL3NoYXJlZCc7XG5leHBvcnQgeyBVcGxvYWRUaGluZ0Vycm9yIH0gZnJvbSAnQHVwbG9hZHRoaW5nL3NoYXJlZCc7XG5pbXBvcnQgeyBwcm9jZXNzLCBpc0RldmVsb3BtZW50IH0gZnJvbSAnc3RkLWVudic7XG5pbXBvcnQgeyBjcmVhdGVDb25zb2xhLCBMb2dMZXZlbHMgfSBmcm9tICdjb25zb2xhL2NvcmUnO1xuaW1wb3J0IHsgVkFMSURfQUNUSU9OX1RZUEVTLCBVVEZpbGVzIH0gZnJvbSAndXBsb2FkdGhpbmcvaW50ZXJuYWwvdHlwZXMnO1xuZXhwb3J0IHsgVVRGaWxlcyB9IGZyb20gJ3VwbG9hZHRoaW5nL2ludGVybmFsL3R5cGVzJztcbmltcG9ydCB7IGxvb2t1cCB9IGZyb20gJ0B1cGxvYWR0aGluZy9taW1lLXR5cGVzJztcblxudmFyIHZlcnNpb24gPSBcIjYuNy4wXCI7XG5cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckZvcm1hdHRlcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xufVxuZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXJyb3IsIHJvdXRlcikge1xuICAgIGNvbnN0IGVycm9yRm9ybWF0dGVyID0gcm91dGVyW09iamVjdC5rZXlzKHJvdXRlcilbMF1dPy5fZGVmLmVycm9yRm9ybWF0dGVyID8/IGRlZmF1bHRFcnJvckZvcm1hdHRlcjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICByZXR1cm4gZXJyb3JGb3JtYXR0ZXIoZXJyb3IpO1xufVxuXG5jb25zdCBjb2xvcml6ZSA9IChzdHIsIGxldmVsKT0+e1xuICAgIC8vIFRPRE86IE1heWJlIGNoZWNrIGlzIHNoZWxsIHN1cHBvcnRzIGNvbG9yc1xuICAgIHN3aXRjaChsZXZlbCl7XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICBjYXNlIFwiZmF0YWxcIjpcbiAgICAgICAgICAgIHJldHVybiBgXFx4MWJbNDFtXFx4MWJbMzBtJHtzdHJ9XFx4MWJbMG1gO1xuICAgICAgICBjYXNlIFwid2FyblwiOlxuICAgICAgICAgICAgcmV0dXJuIGBcXHgxYls0M21cXHgxYlszMG0ke3N0cn1cXHgxYlswbWA7XG4gICAgICAgIGNhc2UgXCJpbmZvXCI6XG4gICAgICAgIGNhc2UgXCJsb2dcIjpcbiAgICAgICAgICAgIHJldHVybiBgXFx4MWJbNDRtXFx4MWJbMzBtJHtzdHJ9XFx4MWJbMG1gO1xuICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIHJldHVybiBgXFx4MWJbNDdtXFx4MWJbMzBtJHtzdHJ9XFx4MWJbMG1gO1xuICAgICAgICBjYXNlIFwidHJhY2VcIjpcbiAgICAgICAgICAgIHJldHVybiBgXFx4MWJbNDdtXFx4MWJbMzBtJHtzdHJ9XFx4MWJbMG1gO1xuICAgICAgICBjYXNlIFwic3VjY2Vzc1wiOlxuICAgICAgICAgICAgcmV0dXJuIGBcXHgxYls0Mm1cXHgxYlszMG0ke3N0cn1cXHgxYlswbWA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn07XG5jb25zdCBpY29ucyA9IHtcbiAgICBmYXRhbDogXCLiqK9cIixcbiAgICBlcnJvcjogXCLiqK9cIixcbiAgICB3YXJuOiBcIuKaoO+4j1wiLFxuICAgIGluZm86IFwi4oS5XCIsXG4gICAgbG9nOiBcIuKEuVwiLFxuICAgIGRlYnVnOiBcIuKamVwiLFxuICAgIHRyYWNlOiBcIuKGklwiLFxuICAgIHN1Y2Nlc3M6IFwi4pyTXCJcbn07XG5mdW5jdGlvbiBmb3JtYXRTdGFjayhzdGFjaykge1xuICAgIGNvbnN0IGN3ZCA9IFwiY3dkXCIgaW4gcHJvY2VzcyAmJiB0eXBlb2YgcHJvY2Vzcy5jd2QgPT09IFwiZnVuY3Rpb25cIiA/IHByb2Nlc3MuY3dkKCkgOiBcIl9fVW5rbm93bkNXRF9fXCI7XG4gICAgcmV0dXJuIFwiICBcIiArIHN0YWNrLnNwbGl0KFwiXFxuXCIpLnNwbGljZSgxKS5tYXAoKGwpPT5sLnRyaW0oKS5yZXBsYWNlKFwiZmlsZTovL1wiLCBcIlwiKS5yZXBsYWNlKGN3ZCArIFwiL1wiLCBcIlwiKSkuam9pbihcIlxcbiAgXCIpO1xufVxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gICAgY29uc3QgZm10QXJncyA9IGFyZ3MubWFwKChhcmcpPT57XG4gICAgICAgIGlmIChpc09iamVjdChhcmcpICYmIHR5cGVvZiBhcmcuc3RhY2sgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmcubWVzc2FnZSArIFwiXFxuXCIgKyBmb3JtYXRTdGFjayhhcmcuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH0pO1xuICAgIHJldHVybiBmbXRBcmdzLm1hcCgoYXJnKT0+e1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnLCBudWxsLCA0KTtcbiAgICB9KTtcbn1cbmNvbnN0IGxvZ2dlciA9IGNyZWF0ZUNvbnNvbGEoe1xuICAgIHJlcG9ydGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBsb2c6IChsb2dPYmopPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0eXBlLCB0YWcsIGRhdGUsIGFyZ3MgfSA9IGxvZ09iajtcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uID0gaWNvbnNbdHlwZV07XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nUHJlZml4ID0gY29sb3JpemUoYCAke2ljb259ICR7dGFnfSAke2RhdGUudG9Mb2NhbGVUaW1lU3RyaW5nKCl9IGAsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gZm9ybWF0QXJncyhhcmdzKS5qb2luKFwiIFwiKSAvLyBjb25jYXQgYWxsIGFyZ3VtZW50cyB0byBvbmUgc3BhY2Utc2VwYXJhdGVkIHN0cmluZyAobGlrZSBjb25zb2xlIGRvZXMpXG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpIC8vIHNwbGl0IGFsbCB0aGUgbmV3bGluZXMgKGUuZy4gZnJvbSBsb2dnZWQgSlNPTi5zdHJpbmdpZmllZCBvYmplY3RzKVxuICAgICAgICAgICAgICAgIC5tYXAoKGwpPT5sb2dQcmVmaXggKyBcIiBcIiArIGwpIC8vIHByZXBlbmQgdGhlIGxvZyBwcmVmaXggdG8gZWFjaCBsaW5lXG4gICAgICAgICAgICAgICAgLmpvaW4oXCJcXG5cIik7IC8vIGpvaW4gYWxsIHRoZSBsaW5lcyBiYWNrIHRvZ2V0aGVyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhsaW5lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdLFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIHRhZzogXCJVUExPQURUSElOR1wiXG4gICAgfVxufSk7XG5jb25zdCBpbml0TG9nZ2VyID0gKGxldmVsKT0+e1xuICAgIC8vIGxvZ2dlci53cmFwQ29uc29sZSgpO1xuICAgIGxvZ2dlci5sZXZlbCA9IExvZ0xldmVsc1tsZXZlbCA/PyBcImluZm9cIl07XG59O1xuXG5jb25zdCBpc1ZhbGlkUmVzcG9uc2UgPSAocmVzcG9uc2UpPT57XG4gICAgaWYgKCFyZXNwb25zZS5vaykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFyZXNwb25zZS5oZWFkZXJzLmhhcyhcIngtdXBsb2FkdGhpbmctdmVyc2lvblwiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGNvbmRpdGlvbmFsRGV2U2VydmVyID0gYXN5bmMgKG9wdHMpPT57XG4gICAgY29uc3QgZmlsZURhdGEgPSBhd2FpdCBwb2xsRm9yRmlsZURhdGEoe1xuICAgICAgICB1cmw6IGdlbmVyYXRlVXBsb2FkVGhpbmdVUkwoYC9hcGkvcG9sbFVwbG9hZC8ke29wdHMuZmlsZUtleX1gKSxcbiAgICAgICAgYXBpS2V5OiBvcHRzLmFwaUtleSxcbiAgICAgICAgc2RrVmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgZmV0Y2g6IG9wdHMuZmV0Y2hcbiAgICB9LCBhc3luYyAoanNvbik9PntcbiAgICAgICAgY29uc3QgZmlsZSA9IGpzb24uZmlsZURhdGE7XG4gICAgICAgIGxldCBjYWxsYmFja1VybCA9IGZpbGUuY2FsbGJhY2tVcmwgKyBgP3NsdWc9JHtmaWxlLmNhbGxiYWNrU2x1Z31gO1xuICAgICAgICBpZiAoIWNhbGxiYWNrVXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSBjYWxsYmFja1VybCA9IFwiaHR0cDovL1wiICsgY2FsbGJhY2tVcmw7XG4gICAgICAgIGxvZ2dlci5pbmZvKFwiU0lNVUxBVElORyBGSUxFIFVQTE9BRCBXRUJIT09LIENBTExCQUNLXCIsIGNhbGxiYWNrVXJsKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHN0YXR1czogXCJ1cGxvYWRlZFwiLFxuICAgICAgICAgICAgbWV0YWRhdGE6IEpTT04ucGFyc2UoZmlsZS5tZXRhZGF0YSA/PyBcInt9XCIpLFxuICAgICAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgICAgIHVybDogYGh0dHBzOi8vdXRmcy5pby9mLyR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdHMuZmlsZUtleSl9YCxcbiAgICAgICAgICAgICAgICBrZXk6IG9wdHMuZmlsZUtleSxcbiAgICAgICAgICAgICAgICBuYW1lOiBmaWxlLmZpbGVOYW1lLFxuICAgICAgICAgICAgICAgIHNpemU6IGZpbGUuZmlsZVNpemUsXG4gICAgICAgICAgICAgICAgdHlwZTogZmlsZS5maWxlVHlwZSxcbiAgICAgICAgICAgICAgICBjdXN0b21JZDogZmlsZS5jdXN0b21JZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc2lnblBheWxvYWQocGF5bG9hZCwgb3B0cy5hcGlLZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvcHRzLmZldGNoKGNhbGxiYWNrVXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBib2R5OiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJ1cGxvYWR0aGluZy1ob29rXCI6IFwiY2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXNpZ25hdHVyZVwiOiBzaWduYXR1cmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnN1Y2Nlc3MoXCJTdWNjZXNzZnVsbHkgc2ltdWxhdGVkIGNhbGxiYWNrIGZvciBmaWxlXCIsIG9wdHMuZmlsZUtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVzcG9uc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHNpbXVsYXRlIGNhbGxiYWNrIGZvciBmaWxlICcke29wdHMuZmlsZUtleX0nLiBJcyB5b3VyIHdlYmhvb2sgY29uZmlndXJlZCBjb3JyZWN0bHk/YCk7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYCAgLSBNYWtlIHN1cmUgdGhlIFVSTCAnJHtjYWxsYmFja1VybH0nIGlzIGFjY2Vzc2libGUgd2l0aG91dCBhbnkgYXV0aGVudGljYXRpb24uIFlvdSBjYW4gdmVyaWZ5IHRoaXMgYnkgcnVubmluZyAnY3VybCAtWCBQT1NUICR7Y2FsbGJhY2tVcmx9JyBpbiB5b3VyIHRlcm1pbmFsYCk7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoYCAgLSBTdGlsbCBmYWNpbmcgaXNzdWVzPyBSZWFkIGh0dHBzOi8vZG9jcy51cGxvYWR0aGluZy5jb20vZmFxIGZvciBjb21tb24gaXNzdWVzYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfSk7XG4gICAgaWYgKGZpbGVEYXRhICE9PSB1bmRlZmluZWQpIHJldHVybiBmaWxlRGF0YTtcbiAgICBsb2dnZXIuZXJyb3IoYEZhaWxlZCB0byBzaW11bGF0ZSBjYWxsYmFjayBmb3IgZmlsZSAke29wdHMuZmlsZUtleX1gKTtcbiAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgIGNvZGU6IFwiVVBMT0FEX0ZBSUxFRFwiLFxuICAgICAgICBtZXNzYWdlOiBcIkZpbGUgdG9vayB0b28gbG9uZyB0byB1cGxvYWRcIlxuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gZ2V0UGFyc2VGbihwYXJzZXIpIHtcbiAgICBpZiAodHlwZW9mIHBhcnNlci5wYXJzZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2U7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyc2VyXCIpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB3cmFwcGVkIGZldGNoIHRoYXQgd2lsbCBhbHdheXMgZm9yd2FyZCBhIGZldyBoZWFkZXJzIHRvIHRoZSBzZXJ2ZXIuXG4gKi8gY29uc3QgY3JlYXRlVVRGZXRjaCA9IChhcGlLZXksIGZldGNoLCBmZVBhY2thZ2UsIGJlQWRhcHRlcik9PntcbiAgICByZXR1cm4gYXN5bmMgKGVuZHBvaW50LCBwYXlsb2FkKT0+e1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGdlbmVyYXRlVXBsb2FkVGhpbmdVUkwoZW5kcG9pbnQpLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLWFwaS1rZXlcIjogYXBpS2V5LFxuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCI6IHZlcnNpb24sXG4gICAgICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLWZlLXBhY2thZ2VcIjogZmVQYWNrYWdlLFxuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1iZS1hZGFwdGVyXCI6IGJlQWRhcHRlclxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH07XG59O1xuY29uc3QgZmlsZUNvdW50TGltaXRIaXQgPSAoZmlsZXMsIHJvdXRlQ29uZmlnKT0+e1xuICAgIGNvbnN0IGNvdW50cyA9IHt9O1xuICAgIGZpbGVzLmZvckVhY2goKGZpbGUpPT57XG4gICAgICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlRnJvbUZpbGVOYW1lKGZpbGUubmFtZSwgb2JqZWN0S2V5cyhyb3V0ZUNvbmZpZykpO1xuICAgICAgICBpZiAoIWNvdW50c1t0eXBlXSkge1xuICAgICAgICAgICAgY291bnRzW3R5cGVdID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50c1t0eXBlXSArPSAxO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZm9yKGNvbnN0IF9rZXkgaW4gY291bnRzKXtcbiAgICAgICAgY29uc3Qga2V5ID0gX2tleTtcbiAgICAgICAgY29uc3QgY291bnQgPSBjb3VudHNba2V5XTtcbiAgICAgICAgY29uc3QgbGltaXQgPSByb3V0ZUNvbmZpZ1trZXldPy5tYXhGaWxlQ291bnQ7XG4gICAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihyb3V0ZUNvbmZpZywga2V5KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGNvbmZpZyBkdXJpbmcgZmlsZSBjb3VudFwiLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBgRXhwZWN0ZWQgcm91dGUgY29uZmlnIHRvIGhhdmUgYSBtYXhGaWxlQ291bnQgZm9yIGtleSAke2tleX0gYnV0IG5vbmUgd2FzIGZvdW5kLmBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IGxpbWl0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxpbWl0SGl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHR5cGU6IGtleSxcbiAgICAgICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgICAgICBjb3VudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsaW1pdEhpdDogZmFsc2VcbiAgICB9O1xufTtcbmNvbnN0IGJ1aWxkUmVxdWVzdEhhbmRsZXIgPSAob3B0cywgYWRhcHRlcik9PntcbiAgICByZXR1cm4gYXN5bmMgKGlucHV0KT0+e1xuICAgICAgICBjb25zdCBpc0RldiA9IG9wdHMuY29uZmlnPy5pc0RldiA/PyBpc0RldmVsb3BtZW50O1xuICAgICAgICBjb25zdCBmZXRjaCA9IG9wdHMuY29uZmlnPy5mZXRjaCA/PyBnbG9iYWxUaGlzLmZldGNoO1xuICAgICAgICBpZiAoaXNEZXYpIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiVXBsb2FkVGhpbmcgZGV2IHNlcnZlciBpcyBub3cgcnVubmluZyFcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyByb3V0ZXIsIGNvbmZpZyB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgcHJlZmVycmVkT3JFbnZTZWNyZXQgPSBjb25maWc/LnVwbG9hZHRoaW5nU2VjcmV0ID8/IHByb2Nlc3MuZW52LlVQTE9BRFRISU5HX1NFQ1JFVDtcbiAgICAgICAgY29uc3QgcmVxID0gaW5wdXQucmVxO1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuICAgICAgICAvLyBHZXQgaW5wdXRzIGZyb20gcXVlcnkgYW5kIHBhcmFtc1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICAgICAgICBjb25zdCB1cGxvYWR0aGluZ0hvb2sgPSByZXEuaGVhZGVycy5nZXQoXCJ1cGxvYWR0aGluZy1ob29rXCIpID8/IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2x1ZyA9IHBhcmFtcy5nZXQoXCJzbHVnXCIpID8/IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgYWN0aW9uVHlwZSA9IHBhcmFtcy5nZXQoXCJhY3Rpb25UeXBlXCIpID8/IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdXRGcm9udGVuZFBhY2thZ2UgPSByZXEuaGVhZGVycy5nZXQoXCJ4LXVwbG9hZHRoaW5nLXBhY2thZ2VcIikgPz8gXCJ1bmtub3duXCI7XG4gICAgICAgIGNvbnN0IGNsaWVudFZlcnNpb24gPSByZXEuaGVhZGVycy5nZXQoXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIik7XG4gICAgICAgIGlmIChjbGllbnRWZXJzaW9uICE9IG51bGwgJiYgY2xpZW50VmVyc2lvbiAhPT0gdmVyc2lvbikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiQ2xpZW50IHZlcnNpb24gbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNsaWVudCB2ZXJzaW9uIG1pc21hdGNoXCIsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGBTZXJ2ZXIgdmVyc2lvbjogJHt2ZXJzaW9ufSwgQ2xpZW50IHZlcnNpb246ICR7Y2xpZW50VmVyc2lvbn1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYWxpZGF0ZSBpbnB1dHNcbiAgICAgICAgaWYgKCFzbHVnKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJObyBzbHVnIHByb3ZpZGVkIGluIHBhcmFtczpcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gc2x1ZyBwcm92aWRlZCBpbiBwYXJhbXNcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNsdWcgJiYgdHlwZW9mIHNsdWcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBFeHBlY3RlZCBzbHVnIHRvIGJlIG9mIHR5cGUgJ3N0cmluZycsIGdvdCAnJHt0eXBlb2Ygc2x1Z30nYDtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJgc2x1Z2AgbXVzdCBiZSBhIHN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBtc2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3Rpb25UeXBlICYmIHR5cGVvZiBhY3Rpb25UeXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgYWN0aW9uVHlwZSB0byBiZSBvZiB0eXBlICdzdHJpbmcnLCBnb3QgJyR7dHlwZW9mIGFjdGlvblR5cGV9J2A7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiYGFjdGlvblR5cGVgIG11c3QgYmUgYSBzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBjYXVzZTogbXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBsb2FkdGhpbmdIb29rICYmIHR5cGVvZiB1cGxvYWR0aGluZ0hvb2sgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBFeHBlY3RlZCB1cGxvYWR0aGluZ0hvb2sgdG8gYmUgb2YgdHlwZSAnc3RyaW5nJywgZ290ICcke3R5cGVvZiB1cGxvYWR0aGluZ0hvb2t9J2A7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcImB1cGxvYWR0aGluZ0hvb2tgIG11c3QgYmUgYSBzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBjYXVzZTogbXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByZWZlcnJlZE9yRW52U2VjcmV0KSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgTm8gc2VjcmV0IHByb3ZpZGVkLCBwbGVhc2Ugc2V0IFVQTE9BRFRISU5HX1NFQ1JFVCBpbiB5b3VyIGVudiBmaWxlIG9yIGluIHRoZSBjb25maWdgO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiTUlTU0lOR19FTlZcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgTm8gc2VjcmV0IHByb3ZpZGVkYCxcbiAgICAgICAgICAgICAgICBjYXVzZTogbXNnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByZWZlcnJlZE9yRW52U2VjcmV0LnN0YXJ0c1dpdGgoXCJza19cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBJbnZhbGlkIHNlY3JldCBwcm92aWRlZCwgVVBMT0FEVEhJTkdfU0VDUkVUIG11c3Qgc3RhcnQgd2l0aCAnc2tfJ2A7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJNSVNTSU5HX0VOVlwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBBUEkga2V5LiBBUEkga2V5cyBtdXN0IHN0YXJ0IHdpdGggJ3NrXycuXCIsXG4gICAgICAgICAgICAgICAgY2F1c2U6IG1zZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0RnJvbnRlbmRQYWNrYWdlICYmIHR5cGVvZiB1dEZyb250ZW5kUGFja2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkIHgtdXBsb2FkdGhpbmctcGFja2FnZSB0byBiZSBvZiB0eXBlICdzdHJpbmcnLCBnb3QgJyR7dHlwZW9mIHV0RnJvbnRlbmRQYWNrYWdlfSdgO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcImB4LXVwbG9hZHRoaW5nLXBhY2thZ2VgIG11c3QgYmUgYSBzdHJpbmcuIGVnLiAnQHVwbG9hZHRoaW5nL3JlYWN0J1wiLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBtc2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVwbG9hZGFibGUgPSByb3V0ZXJbc2x1Z107XG4gICAgICAgIGlmICghdXBsb2FkYWJsZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYE5vIGZpbGUgcm91dGUgZm91bmQgZm9yIHNsdWcgJHtzbHVnfWA7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJOT1RfRk9VTkRcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHV0RmV0Y2ggPSBjcmVhdGVVVEZldGNoKHByZWZlcnJlZE9yRW52U2VjcmV0LCBmZXRjaCwgdXRGcm9udGVuZFBhY2thZ2UsIGFkYXB0ZXIpO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJBbGwgcmVxdWVzdCBpbnB1dCBpcyB2YWxpZFwiLCB7XG4gICAgICAgICAgICBzbHVnLFxuICAgICAgICAgICAgYWN0aW9uVHlwZSxcbiAgICAgICAgICAgIHVwbG9hZHRoaW5nSG9va1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVwbG9hZHRoaW5nSG9vayA9PT0gXCJjYWxsYmFja1wiKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHdoZW4gd2UgcmVjZWl2ZSB0aGUgd2ViaG9vayBmcm9tIHVwbG9hZHRoaW5nXG4gICAgICAgICAgICBjb25zdCBtYXliZVJlcUJvZHkgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHJlcSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJIYW5kbGluZyBjYWxsYmFjayByZXF1ZXN0IHdpdGggaW5wdXQ6XCIsIG1heWJlUmVxQm9keSk7XG4gICAgICAgICAgICBpZiAobWF5YmVSZXFCb2R5IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJJbnZhbGlkIHJlcXVlc3QgYm9keVwiLCBtYXliZVJlcUJvZHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIHJlcXVlc3QgYm9keVwiLFxuICAgICAgICAgICAgICAgICAgICBjYXVzZTogbWF5YmVSZXFCb2R5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2ZXJpZmllZCA9IGF3YWl0IHZlcmlmeVNpZ25hdHVyZShKU09OLnN0cmluZ2lmeShtYXliZVJlcUJvZHkpLCByZXEuaGVhZGVycy5nZXQoXCJ4LXVwbG9hZHRoaW5nLXNpZ25hdHVyZVwiKSwgcHJlZmVycmVkT3JFbnZTZWNyZXQpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiU2lnbmF0dXJlIHZlcmlmaWVkOlwiLCB2ZXJpZmllZCk7XG4gICAgICAgICAgICBpZiAoIXZlcmlmaWVkKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBzaWduYXR1cmVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgc2lnbmF0dXJlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQXJncyA9IHtcbiAgICAgICAgICAgICAgICBmaWxlOiBtYXliZVJlcUJvZHkuZmlsZSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWF5YmVSZXFCb2R5Lm1ldGFkYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUnVubmluZyAnb25VcGxvYWRDb21wbGV0ZScgY2FsbGJhY2sgd2l0aCBpbnB1dDpcIiwgcmVzb2x2ZXJBcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHVwbG9hZGFibGUucmVzb2x2ZXIocmVzb2x2ZXJBcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgZmlsZUtleTogbWF5YmVSZXFCb2R5LmZpbGUua2V5LFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrRGF0YTogcmVzID8/IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCInb25VcGxvYWRDb21wbGV0ZScgY2FsbGJhY2sgZmluaXNoZWQuIFNlbmRpbmcgcmVzcG9uc2UgdG8gVXBsb2FkVGhpbmc6XCIsIHBheWxvYWQpO1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tSZXNwb25zZSA9IGF3YWl0IHV0RmV0Y2goXCIvYXBpL3NlcnZlckNhbGxiYWNrXCIsIHBheWxvYWQpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiVXBsb2FkVGhpbmcgcmVzcG9uZGVkIHdpdGggc3RhdHVzOlwiLCBjYWxsYmFja1Jlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgIGJvZHk6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhY3Rpb25UeXBlIHx8ICFWQUxJRF9BQ1RJT05fVFlQRVMuaW5jbHVkZXMoYWN0aW9uVHlwZSkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgd291bGQgZWl0aGVyIGJlIHNvbWVvbmUgc3BhbW1pbmcgb3IgdGhlIEFXUyB3ZWJob29rXG4gICAgICAgICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgJHtWQUxJRF9BQ1RJT05fVFlQRVMubWFwKCh4KT0+YFwiJHt4fVwiYCkuam9pbihcIiwgXCIpLnJlcGxhY2UoLywoPyEuKiwpLywgXCIgb3JcIil9IGJ1dCBnb3QgXCIke2FjdGlvblR5cGV9XCJgO1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCBhY3Rpb24gdHlwZS5cIiwgbXNnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBgSW52YWxpZCBhY3Rpb24gdHlwZSAke2FjdGlvblR5cGV9YCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2dcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChhY3Rpb25UeXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJ1cGxvYWRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlSW5wdXQgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZUlucHV0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgcmVxdWVzdCBib2R5XCIsIG1heWJlSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIHJlcXVlc3QgYm9keVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBtYXliZUlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJIYW5kbGluZyB1cGxvYWQgcmVxdWVzdCB3aXRoIGlucHV0OlwiLCBtYXliZUlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaWxlcywgaW5wdXQ6IHVzZXJJbnB1dCB9ID0gbWF5YmVJbnB1dDtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgd2l0aG91dCBab2QgKGZvciBub3cpXG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmaWxlcykgfHwgIWZpbGVzLmV2ZXJ5KChmKT0+aXNPYmplY3QoZikgJiYgdHlwZW9mIGYubmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZi5zaXplID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBmLnR5cGUgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgZmlsZXMgdG8gYmUgb2YgdHlwZSAne25hbWU6c3RyaW5nLCBzaXplOm51bWJlciwgdHlwZTpzdHJpbmd9W10nLCBnb3QgJyR7SlNPTi5zdHJpbmdpZnkoZmlsZXMpfSdgO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZpbGVzIG11c3QgYmUgYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIG5hbWUgYW5kIHNpemVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogbXNnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB2YWxpZGF0ZSB0aGUgaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcnNlZElucHV0ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJQYXJzaW5nIGlucHV0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRQYXJzZXIgPSB1cGxvYWRhYmxlLl9kZWYuaW5wdXRQYXJzZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dCA9IGF3YWl0IGdldFBhcnNlRm4oaW5wdXRQYXJzZXIpKHVzZXJJbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJJbnB1dCBwYXJzZWQgc3VjY2Vzc2Z1bGx5XCIsIHBhcnNlZElucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkIHRyeWluZyB0byBwYXJzZSBpbnB1dDpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIGlucHV0LlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJSdW5uaW5nIG1pZGRsZXdhcmVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IGF3YWl0IHVwbG9hZGFibGUuX2RlZi5taWRkbGV3YXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5pbnB1dC5taWRkbGV3YXJlQXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiTWlkZGxld2FyZSBmaW5pc2hlZCBzdWNjZXNzZnVsbHkgd2l0aDpcIiwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiQW4gZXJyb3Igb2NjdXJyZWQgaW4geW91ciBtaWRkbGV3YXJlIGZ1bmN0aW9uOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBVcGxvYWRUaGluZ0Vycm9yKSByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcnVuIG1pZGRsZXdhcmUuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFbVVRGaWxlc10gJiYgbWV0YWRhdGFbVVRGaWxlc10ubGVuZ3RoICE9PSBmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBFeHBlY3RlZCBmaWxlcyBvdmVycmlkZSB0byBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhcyBvcmlnaW5hbCBmaWxlcywgZ290ICR7bWV0YWRhdGFbVVRGaWxlc10ubGVuZ3RofSBidXQgZXhwZWN0ZWQgJHtmaWxlcy5sZW5ndGh9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJGaWxlcyBvdmVycmlkZSBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoIGFzIGZpbGVzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IG1zZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0YWNoIGN1c3RvbUlkcyBmcm9tIG1pZGRsZXdhcmUgdG8gdGhlIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzV2l0aEN1c3RvbUlkcyA9IGZpbGVzLm1hcCgoZmlsZSwgaWR4KT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGhlaXJzID0gbWV0YWRhdGFbVVRGaWxlc10/LltpZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoZWlycyAmJiB0aGVpcnMuc2l6ZSAhPT0gZmlsZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJGaWxlIHNpemUgbWlzbWF0Y2guIFJldmVydGluZyB0byBvcmlnaW5hbCBzaXplXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0aGVpcnM/Lm5hbWUgPz8gZmlsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21JZDogdGhlaXJzPy5jdXN0b21JZFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJTEwgVEhFIFJPVVRFIENPTkZJRyBzbyB0aGUgc2VydmVyIG9ubHkgaGFzIG9uZSBoYXBweSBwYXRoXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWRDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJQYXJzaW5nIHJvdXRlIGNvbmZpZ1wiLCB1cGxvYWRhYmxlLl9kZWYucm91dGVyQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZENvbmZpZyA9IGZpbGxJbnB1dFJvdXRlQ29uZmlnKHVwbG9hZGFibGUuX2RlZi5yb3V0ZXJDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUm91dGUgY29uZmlnIHBhcnNlZCBzdWNjZXNzZnVsbHlcIiwgcGFyc2VkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgcm91dGUgY29uZmlnXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBjb25maWcuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQ2hlY2tpbmcgZmlsZSBjb3VudCBsaW1pdFwiLCBmaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxpbWl0SGl0LCBjb3VudCwgbGltaXQsIHR5cGUgfSA9IGZpbGVDb3VudExpbWl0SGl0KGZpbGVzLCBwYXJzZWRDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbWl0SGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYFlvdSB1cGxvYWRlZCAke2NvdW50fSBmaWxlcyBvZiB0eXBlICcke3R5cGV9JywgYnV0IHRoZSBsaW1pdCBmb3IgdGhhdCB0eXBlIGlzICR7bGltaXR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmlsZSBsaW1pdCBleGNlZWRlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogbXNnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJGaWxlIGNvdW50IGxpbWl0IGNoZWNrIHBhc3NlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkludmFsaWQgcm91dGUgY29uZmlnXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBjb25maWcuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFja1VybCA9IHJlc29sdmVDYWxsYmFja1VybCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RldlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUmV0cmlldmluZyBwcmVzaWduZWQgVVJMcyBmcm9tIFVwbG9hZFRoaW5nLiBDYWxsYmFjayBVUkwgaXM6XCIsIGNhbGxiYWNrVXJsLmhyZWYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGxvYWR0aGluZ0FwaVJlc3BvbnNlID0gYXdhaXQgdXRGZXRjaChcIi9hcGkvcHJlcGFyZVVwbG9hZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlczogZmlsZXNXaXRoQ3VzdG9tSWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVDb25maWc6IHBhcnNlZENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tVcmw6IGNhbGxiYWNrVXJsLm9yaWdpbiArIGNhbGxiYWNrVXJsLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tTbHVnOiBzbHVnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHdoZW4gd2Ugc2VuZCB0aGUgcmVzcG9uc2UgYmFjayB0byB0aGUgdXNlcidzIGZvcm0gc28gdGhleSBjYW4gc3VibWl0IHRoZSBmaWxlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXNwb25zZSA9IGF3YWl0IHNhZmVQYXJzZUpTT04odXBsb2FkdGhpbmdBcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXBsb2FkdGhpbmdBcGlSZXNwb25zZS5vayB8fCBwYXJzZWRSZXNwb25zZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJVbmFibGUgdG8gZ2V0IHByZXNpZ25lZCBVUkxzXCIsIHBhcnNlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJVUkxfR0VORVJBVElPTl9GQUlMRURcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlVuYWJsZSB0byBnZXQgcHJlc2lnbmVkIHVybHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogcGFyc2VkUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlVwbG9hZFRoaW5nIHJlc3BvbmRlZCB3aXRoOlwiLCBwYXJzZWRSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlNlbmRpbmcgcHJlc2lnbmVkIFVSTHMgdG8gY2xpZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHdoZW4gd2Ugc2VuZCB0aGUgcmVzcG9uc2UgYmFjayB0byB0aGUgdXNlcidzIGZvcm0gc28gdGhleSBjYW4gc3VibWl0IHRoZSBmaWxlc1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5hbGwocGFyc2VkUmVzcG9uc2UubWFwKChmaWxlKT0+Y29uZGl0aW9uYWxEZXZTZXJ2ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlS2V5OiBmaWxlLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpS2V5OiBwcmVmZXJyZWRPckVudlNlY3JldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkVyclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cDogcHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHBhcnNlZFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibXVsdGlwYXJ0LWNvbXBsZXRlXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXliZVJlcUJvZHkgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVJlcUJvZHkgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCByZXF1ZXN0IGJvZHlcIiwgbWF5YmVSZXFCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCByZXF1ZXN0IGJvZHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogbWF5YmVSZXFCb2R5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJIYW5kbGluZyBtdWx0aXBhcnQtY29tcGxldGUgcmVxdWVzdCB3aXRoIGlucHV0OlwiLCBtYXliZVJlcUJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJOb3RpZnlpbmcgVXBsb2FkVGhpbmcgdGhhdCBtdWx0aXBhcnQgdXBsb2FkIGlzIGNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wbGV0ZVJlcyA9IGF3YWl0IHV0RmV0Y2goXCIvYXBpL2NvbXBsZXRlTXVsdGlwYXJ0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVLZXk6IG1heWJlUmVxQm9keS5maWxlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkSWQ6IG1heWJlUmVxQm9keS51cGxvYWRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV0YWdzOiBtYXliZVJlcUJvZHkuZXRhZ3NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxldGVSZXMub2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBub3RpZnkgVXBsb2FkVGhpbmcgdGhhdCBtdWx0aXBhcnQgdXBsb2FkIGlzIGNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBjb21wbGV0ZSBtdWx0aXBhcnQgdXBsb2FkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGNvbXBsZXRlUmVzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJVcGxvYWRUaGluZyByZXNwb25kZWQgd2l0aDpcIiwgY29tcGxldGVSZXMuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmYWlsdXJlXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXliZVJlcUJvZHkgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVJlcUJvZHkgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiSW52YWxpZCByZXF1ZXN0IGJvZHlcIiwgbWF5YmVSZXFCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCByZXF1ZXN0IGJvZHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogbWF5YmVSZXFCb2R5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZpbGVLZXksIHVwbG9hZElkIH0gPSBtYXliZVJlcUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkhhbmRsaW5nIGZhaWx1cmUgcmVxdWVzdCB3aXRoIGlucHV0OlwiLCBtYXliZVJlcUJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJOb3RpZnlpbmcgVXBsb2FkVGhpbmcgdGhhdCB1cGxvYWQgZmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUZWxsIHVwbG9hZHRoaW5nIHRvIG1hcmsgdGhlIHVwbG9hZCBhcyBmYWlsZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBsb2FkdGhpbmdBcGlSZXNwb25zZSA9IGF3YWl0IHV0RmV0Y2goXCIvYXBpL2ZhaWx1cmVDYWxsYmFja1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkSWRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXBsb2FkdGhpbmdBcGlSZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHVwbG9hZHRoaW5nQXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIG1hcmsgdXBsb2FkIGFzIGZhaWxlZFwiLCBwYXJzZWRSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJVbmFibGUgdG8gbWFyayB1cGxvYWQgYXMgZmFpbGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F1c2U6IHBhcnNlZFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJVcGxvYWRUaGluZyByZXNwb25kZWQgd2l0aDpcIiwgdXBsb2FkdGhpbmdBcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIlJ1bm5pbmcgJ29uVXBsb2FkRXJyb3InIGNhbGxiYWNrXCIpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUnVuIHRoZSBvblVwbG9hZEVycm9yIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRhYmxlLl9kZWYub25VcGxvYWRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBVcGxvYWQgZmFpbGVkIGZvciAke2ZpbGVLZXl9YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHJ1biBvblVwbG9hZEVycm9yIGNhbGxiYWNrLiBZb3UgcHJvYmFibHkgc2hvdWxkbid0IGJlIHRocm93aW5nIGVycm9ycyBpbiB5b3VyIGNhbGxiYWNrLlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcnVuIG9uVXBsb2FkRXJyb3IgY2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBhY3Rpb24gdHlwZWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG5mdW5jdGlvbiByZXNvbHZlQ2FsbGJhY2tVcmwob3B0cykge1xuICAgIGxldCBjYWxsYmFja1VybCA9IG9wdHMudXJsO1xuICAgIGlmIChvcHRzLmNvbmZpZz8uY2FsbGJhY2tVcmwpIHtcbiAgICAgICAgY2FsbGJhY2tVcmwgPSByZXNvbHZlTWF5YmVVcmxBcmcob3B0cy5jb25maWcuY2FsbGJhY2tVcmwpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuVVBMT0FEVEhJTkdfVVJMKSB7XG4gICAgICAgIGNhbGxiYWNrVXJsID0gcmVzb2x2ZU1heWJlVXJsQXJnKHByb2Nlc3MuZW52LlVQTE9BRFRISU5HX1VSTCk7XG4gICAgfVxuICAgIGlmIChvcHRzLmlzRGV2IHx8ICFjYWxsYmFja1VybC5ob3N0LmluY2x1ZGVzKFwibG9jYWxob3N0XCIpKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFja1VybDtcbiAgICB9XG4gICAgLy8gUHJvZHVjdGlvbiBidWlsZHMgaGF2ZSB0byBoYXZlIGEgcHVibGljIFVSTCBzbyBVVCBjYW4gc2VuZCB3ZWJob29rXG4gICAgLy8gUGFyc2UgdGhlIFVSTCBmcm9tIHRoZSBoZWFkZXJzXG4gICAgY29uc3QgaGVhZGVycyA9IG9wdHMucmVxLmhlYWRlcnM7XG4gICAgbGV0IHBhcnNlZEZyb21IZWFkZXJzID0gaGVhZGVycy5nZXQoXCJvcmlnaW5cIikgPz8gaGVhZGVycy5nZXQoXCJyZWZlcmVyXCIpID8/IGhlYWRlcnMuZ2V0KFwiaG9zdFwiKSA/PyBoZWFkZXJzLmdldChcIngtZm9yd2FyZGVkLWhvc3RcIik7XG4gICAgaWYgKHBhcnNlZEZyb21IZWFkZXJzICYmICFwYXJzZWRGcm9tSGVhZGVycy5pbmNsdWRlcyhcImh0dHBcIikpIHtcbiAgICAgICAgcGFyc2VkRnJvbUhlYWRlcnMgPSAoaGVhZGVycy5nZXQoXCJ4LWZvcndhcmRlZC1wcm90b1wiKSA/PyBcImh0dHBzXCIpICsgXCI6Ly9cIiArIHBhcnNlZEZyb21IZWFkZXJzO1xuICAgIH1cbiAgICBpZiAoIXBhcnNlZEZyb21IZWFkZXJzIHx8IHBhcnNlZEZyb21IZWFkZXJzLmluY2x1ZGVzKFwibG9jYWxob3N0XCIpKSB7XG4gICAgICAgIC8vIERpZG4ndCBmaW5kIGEgdmFsaWQgVVJMIGluIHRoZSBoZWFkZXJzLCBsb2cgYSB3YXJuaW5nIGFuZCB1c2UgdGhlIG9yaWdpbmFsIHVybCBhbnl3YXlcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJZb3UgYXJlIHVzaW5nIGEgbG9jYWxob3N0IGNhbGxiYWNrIHVybCBpbiBwcm9kdWN0aW9uIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQuXCIsIFwiUmVhZCBtb3JlIGFuZCBsZWFybiBob3cgdG8gZml4IGl0IGhlcmU6IGh0dHBzOi8vZG9jcy51cGxvYWR0aGluZy5jb20vZmFxI215LWNhbGxiYWNrLXJ1bnMtaW4tZGV2ZWxvcG1lbnQtYnV0LW5vdC1pbi1wcm9kdWN0aW9uXCIpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2tVcmw7XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlTWF5YmVVcmxBcmcocGFyc2VkRnJvbUhlYWRlcnMpO1xufVxuY29uc3QgYnVpbGRQZXJtaXNzaW9uc0luZm9IYW5kbGVyID0gKG9wdHMpPT57XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGNvbnN0IHIgPSBvcHRzLnJvdXRlcjtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBPYmplY3Qua2V5cyhyKS5tYXAoKGspPT57XG4gICAgICAgICAgICBjb25zdCByb3V0ZSA9IHJba107XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBmaWxsSW5wdXRSb3V0ZUNvbmZpZyhyb3V0ZS5fZGVmLnJvdXRlckNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNsdWc6IGssXG4gICAgICAgICAgICAgICAgY29uZmlnXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBlcm1pc3Npb25zO1xuICAgIH07XG59O1xuXG5mdW5jdGlvbiBpbmNvbXBhdGlibGVOb2RlR3VhcmQoKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47XG4gICAgbGV0IG1ham9yO1xuICAgIGxldCBtaW5vcjtcbiAgICBjb25zdCBtYXliZU5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9ucz8ubm9kZT8uc3BsaXQoXCIuXCIpO1xuICAgIGlmIChtYXliZU5vZGVWZXJzaW9uKSB7XG4gICAgICAgIFttYWpvciwgbWlub3JdID0gbWF5YmVOb2RlVmVyc2lvbi5tYXAoKHYpPT5wYXJzZUludCh2LCAxMCkpO1xuICAgIH1cbiAgICBjb25zdCBtYXliZU5vZGVQYXRoID0gcHJvY2Vzcy5lbnY/Lk5PREU7XG4gICAgaWYgKCFtYWpvciAmJiBtYXliZU5vZGVQYXRoKSB7XG4gICAgICAgIGNvbnN0IG5vZGVWZXJzaW9uID0gL3YoXFxkKylcXC4oXFxkKylcXC4oXFxkKykvLmV4ZWMobWF5YmVOb2RlUGF0aCk/LlswXTtcbiAgICAgICAgaWYgKG5vZGVWZXJzaW9uKSB7XG4gICAgICAgICAgICBbbWFqb3IsIG1pbm9yXSA9IG5vZGVWZXJzaW9uLnN1YnN0cmluZygxKS5zcGxpdChcIi5cIikubWFwKCh2KT0+cGFyc2VJbnQodiwgMTApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW1ham9yIHx8ICFtaW5vcikgcmV0dXJuO1xuICAgIC8vIFJlcXVpcmUgXjE4LjEzLjBcbiAgICBpZiAobWFqb3IgPiAxOCkgcmV0dXJuO1xuICAgIGlmIChtYWpvciA9PT0gMTggJiYgbWlub3IgPj0gMTMpIHJldHVybjtcbiAgICBsb2dnZXIuZmF0YWwoYFlPVSBBUkUgVVNJTkcgQSBMRUdBQ1kgKCR7bWFqb3J9LiR7bWlub3J9KSBOT0RFIFZFUlNJT04gV0hJQ0ggSVNOJ1QgT0ZGSUNJQUxMWSBTVVBQT1JURUQuIFBMRUFTRSBVUEdSQURFIFRPIE5PREUgXjE4LjEzLmApO1xuICAgIC8vIEtpbGwgdGhlIHByb2Nlc3MgaWYgaXQgaXNuJ3QgZ29pbmcgdG8gd29yayBjb3JyZWN0bHkgYW55d2F5XG4gICAgLy8gSWYgd2UndmUgZ290dGVuIHRoaXMgZmFyIHdlIGtub3cgd2UgaGF2ZSBhIE5vZGUuanMgcnVudGltZSBzbyBleGl0IGlzIGRlZmluZWQuIE92ZXJyaWRlIHN0ZC1lbnYgdHlwZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICBwcm9jZXNzLmV4aXQ/LigxKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJuYWxDcmVhdGVCdWlsZGVyKGluaXREZWYgPSB7fSkge1xuICAgIGNvbnN0IF9kZWYgPSB7XG4gICAgICAgIC8vIERlZmF1bHQgcm91dGVyIGNvbmZpZ1xuICAgICAgICByb3V0ZXJDb25maWc6IHtcbiAgICAgICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICAgICAgbWF4RmlsZVNpemU6IFwiNE1CXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXRQYXJzZXI6IHtcbiAgICAgICAgICAgIHBhcnNlOiAoKT0+dW5kZWZpbmVkLFxuICAgICAgICAgICAgX2lucHV0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBfb3V0cHV0OiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgbWlkZGxld2FyZTogKCk9Pih7fSksXG4gICAgICAgIG9uVXBsb2FkRXJyb3I6ICgpPT4oe30pLFxuICAgICAgICBlcnJvckZvcm1hdHRlcjogaW5pdERlZi5lcnJvckZvcm1hdHRlciA/PyBkZWZhdWx0RXJyb3JGb3JtYXR0ZXIsXG4gICAgICAgIC8vIE92ZXJsb2FkIHdpdGggcHJvcGVydGllcyBwYXNzZWQgaW5cbiAgICAgICAgLi4uaW5pdERlZlxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQgKHVzZXJQYXJzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbENyZWF0ZUJ1aWxkZXIoe1xuICAgICAgICAgICAgICAgIC4uLl9kZWYsXG4gICAgICAgICAgICAgICAgaW5wdXRQYXJzZXI6IHVzZXJQYXJzZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBtaWRkbGV3YXJlICh1c2VyTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsQ3JlYXRlQnVpbGRlcih7XG4gICAgICAgICAgICAgICAgLi4uX2RlZixcbiAgICAgICAgICAgICAgICBtaWRkbGV3YXJlOiB1c2VyTWlkZGxld2FyZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVXBsb2FkQ29tcGxldGUgKHVzZXJVcGxvYWRDb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBfZGVmLFxuICAgICAgICAgICAgICAgIHJlc29sdmVyOiB1c2VyVXBsb2FkQ29tcGxldGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIG9uVXBsb2FkRXJyb3IgKHVzZXJPblVwbG9hZEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxDcmVhdGVCdWlsZGVyKHtcbiAgICAgICAgICAgICAgICAuLi5fZGVmLFxuICAgICAgICAgICAgICAgIG9uVXBsb2FkRXJyb3I6IHVzZXJPblVwbG9hZEVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVCdWlsZGVyKG9wdHMpIHtcbiAgICByZXR1cm4gKGlucHV0KT0+e1xuICAgICAgICByZXR1cm4gaW50ZXJuYWxDcmVhdGVCdWlsZGVyKHtcbiAgICAgICAgICAgIHJvdXRlckNvbmZpZzogaW5wdXQsXG4gICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbmNvbnN0IG1heWJlUGFyc2VSZXNwb25zZVhNTCA9IChtYXliZVhtbCk9PntcbiAgICBjb25zdCBjb2RlTWF0Y2ggPSBtYXliZVhtbC5tYXRjaCgvPENvZGU+KC4qPyk8XFwvQ29kZT4vcyk7XG4gICAgY29uc3QgbWVzc2FnZU1hdGNoID0gbWF5YmVYbWwubWF0Y2goLzxNZXNzYWdlPiguKj8pPFxcL01lc3NhZ2U+L3MpO1xuICAgIGNvbnN0IGNvZGUgPSBjb2RlTWF0Y2g/LlsxXTtcbiAgICBjb25zdCBtZXNzYWdlID0gbWVzc2FnZU1hdGNoPy5bMV07XG4gICAgaWYgKCFjb2RlIHx8ICFtZXNzYWdlKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBzM0NvZGVUb1VwbG9hZFRoaW5nQ29kZVtjb2RlXSA/PyBERUZBVUxUX0VSUk9SX0NPREUsXG4gICAgICAgIG1lc3NhZ2VcbiAgICB9O1xufTtcbi8qKlxuICogTWFwIFMzIGVycm9yIGNvZGVzIHRvIFVwbG9hZFRoaW5nIGVycm9yIGNvZGVzXG4gKlxuICogVGhpcyBpcyBhIHN1YnNldCBvZiB0aGUgUzMgZXJyb3IgY29kZXMsIGJhc2VkIG9uIHdoYXQgc2VlbWVkIG1vc3QgbGlrZWx5IHRvXG4gKiBvY2N1ciBpbiB1cGxvYWR0aGluZy4gRm9yIGEgZnVsbCBsaXN0IG9mIFMzIGVycm9yIGNvZGVzLCBzZWU6XG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uUzMvbGF0ZXN0L0FQSS9FcnJvclJlc3BvbnNlcy5odG1sXG4gKi8gY29uc3QgREVGQVVMVF9FUlJPUl9DT0RFID0gXCJVUExPQURfRkFJTEVEXCI7XG5jb25zdCBzM0NvZGVUb1VwbG9hZFRoaW5nQ29kZSA9IHtcbiAgICBBY2Nlc3NEZW5pZWQ6IFwiRk9SQklEREVOXCIsXG4gICAgRW50aXR5VG9vU21hbGw6IFwiVE9PX1NNQUxMXCIsXG4gICAgRW50aXR5VG9vTGFyZ2U6IFwiVE9PX0xBUkdFXCIsXG4gICAgRXhwaXJlZFRva2VuOiBcIkZPUkJJRERFTlwiLFxuICAgIEluY29ycmVjdE51bWJlck9mRmlsZXNJblBvc3RSZXF1ZXN0OiBcIlRPT19NQU5ZX0ZJTEVTXCIsXG4gICAgSW50ZXJuYWxFcnJvcjogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcbiAgICBLZXlUb29Mb25nRXJyb3I6IFwiS0VZX1RPT19MT05HXCIsXG4gICAgTWF4TWVzc2FnZUxlbmd0aEV4Y2VlZGVkOiBcIlRPT19MQVJHRVwiXG59O1xuXG4vKipcbiAqIFVzZWQgYnkgc2VydmVyIHVwbG9hZHMgd2hlcmUgcHJvZ3Jlc3MgaXMgbm90IG5lZWRlZC5cbiAqIFVzZXMgbm9ybWFsIGZldGNoIEFQSS5cbiAqLyBhc3luYyBmdW5jdGlvbiB1cGxvYWRQYXJ0KG9wdHMsIHJldHJ5Q291bnQgPSAwKSB7XG4gICAgY29uc3QgczNSZXMgPSBhd2FpdCBvcHRzLmZldGNoKG9wdHMudXJsLCB7XG4gICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgYm9keTogb3B0cy5jaHVuayxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogb3B0cy5jb250ZW50VHlwZSxcbiAgICAgICAgICAgIFwiQ29udGVudC1EaXNwb3NpdGlvblwiOiBjb250ZW50RGlzcG9zaXRpb24ob3B0cy5jb250ZW50RGlzcG9zaXRpb24sIG9wdHMuZmlsZU5hbWUpXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoczNSZXMub2spIHtcbiAgICAgICAgY29uc3QgZXRhZyA9IHMzUmVzLmhlYWRlcnMuZ2V0KFwiRXRhZ1wiKTtcbiAgICAgICAgaWYgKCFldGFnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJNaXNzaW5nIEV0YWcgaGVhZGVyIGZyb20gdXBsb2FkZWQgcGFydFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXRhZy5yZXBsYWNlKC9cIi9nLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKHJldHJ5Q291bnQgPCBvcHRzLm1heFJldHJpZXMpIHtcbiAgICAgICAgLy8gUmV0cnkgYWZ0ZXIgZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICBjb25zdCBkZWxheSA9IDIgKiogcmV0cnlDb3VudCAqIDEwMDA7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKT0+c2V0VGltZW91dChyLCBkZWxheSkpO1xuICAgICAgICByZXR1cm4gdXBsb2FkUGFydChvcHRzLCByZXRyeUNvdW50KyspO1xuICAgIH1cbiAgICAvLyBNYXggcmV0cmllcyBleGNlZWRlZCwgdGVsbCBVVCBzZXJ2ZXIgdGhhdCB1cGxvYWQgZmFpbGVkXG4gICAgYXdhaXQgb3B0cy5mZXRjaChnZW5lcmF0ZVVwbG9hZFRoaW5nVVJMKFwiL2FwaS9mYWlsdXJlQ2FsbGJhY2tcIiksIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgZmlsZUtleTogb3B0cy5rZXlcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IG9wdHMudXRSZXF1ZXN0SGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHRleHQgPSBhd2FpdCBzM1Jlcy50ZXh0KCk7XG4gICAgY29uc3QgcGFyc2VkID0gbWF5YmVQYXJzZVJlc3BvbnNlWE1MKHRleHQpO1xuICAgIGlmIChwYXJzZWQ/Lm1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogXCJVUExPQURfRkFJTEVEXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBwYXJzZWQubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gdXBsb2FkIGZpbGUgdG8gc3RvcmFnZSBwcm92aWRlclwiLFxuICAgICAgICBjYXVzZTogczNSZXNcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ3VhcmRTZXJ2ZXJPbmx5KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgIGNvZGU6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRoZSBgdXRhcGlgIGNhbiBvbmx5IGJlIHVzZWQgb24gdGhlIHNlcnZlci5cIlxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRBcGlLZXlPclRocm93KGFwaUtleSkge1xuICAgIGlmIChhcGlLZXkpIHJldHVybiBhcGlLZXk7XG4gICAgaWYgKHByb2Nlc3MuZW52LlVQTE9BRFRISU5HX1NFQ1JFVCkgcmV0dXJuIHByb2Nlc3MuZW52LlVQTE9BRFRISU5HX1NFQ1JFVDtcbiAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgIGNvZGU6IFwiTUlTU0lOR19FTlZcIixcbiAgICAgICAgbWVzc2FnZTogXCJNaXNzaW5nIGBVUExPQURUSElOR19TRUNSRVRgIGVudiB2YXJpYWJsZS5cIlxuICAgIH0pO1xufVxuY29uc3QgdXBsb2FkRmlsZXNJbnRlcm5hbCA9IGFzeW5jIChkYXRhLCBvcHRzKT0+e1xuICAgIC8vIFJlcXVlc3QgcHJlc2lnbmVkIFVSTHMgZm9yIGVhY2ggZmlsZVxuICAgIGNvbnN0IGZpbGVEYXRhID0gZGF0YS5maWxlcy5tYXAoKGZpbGUpPT4oe1xuICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lID8/IFwidW5uYW1lZC1ibG9iXCIsXG4gICAgICAgICAgICB0eXBlOiBmaWxlLnR5cGUsXG4gICAgICAgICAgICBzaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgICAuLi5cImN1c3RvbUlkXCIgaW4gZmlsZSA/IHtcbiAgICAgICAgICAgICAgICBjdXN0b21JZDogZmlsZS5jdXN0b21JZFxuICAgICAgICAgICAgfSA6IHt9XG4gICAgICAgIH0pKTtcbiAgICBsb2dnZXIuZGVidWcoXCJHZXR0aW5nIHByZXNpZ25lZCBVUkxzIGZvciBmaWxlc1wiLCBmaWxlRGF0YSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgb3B0cy5mZXRjaChnZW5lcmF0ZVVwbG9hZFRoaW5nVVJMKFwiL2FwaS91cGxvYWRGaWxlc1wiKSwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiBvcHRzLnV0UmVxdWVzdEhlYWRlcnMsXG4gICAgICAgIGNhY2hlOiBcIm5vLXN0b3JlXCIsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGZpbGVzOiBmaWxlRGF0YSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBkYXRhLm1ldGFkYXRhLFxuICAgICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uOiBkYXRhLmNvbnRlbnREaXNwb3NpdGlvbixcbiAgICAgICAgICAgIGFjbDogZGF0YS5hY2xcbiAgICAgICAgfSlcbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBjb25zdCBlcnJvciA9IGF3YWl0IFVwbG9hZFRoaW5nRXJyb3IuZnJvbVJlc3BvbnNlKHJlcyk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZhaWxlZCBnZXR0aW5nIHByZXNpZ25lZCBVUkxzOlwiLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBsb2dnZXIuZGVidWcoXCJHb3QgcHJlc2lnbmVkIFVSTHM6XCIsIGpzb24uZGF0YSk7XG4gICAgbG9nZ2VyLmRlYnVnKFwiU3RhcnRpbmcgdXBsb2Fkcy4uLlwiKTtcbiAgICAvLyBVcGxvYWQgZWFjaCBmaWxlIHRvIFMzIGluIGNodW5rcyB1c2luZyBtdWx0aS1wYXJ0IHVwbG9hZHNcbiAgICBjb25zdCB1cGxvYWRzID0gYXdhaXQgUHJvbWlzZS5hbGxTZXR0bGVkKGRhdGEuZmlsZXMubWFwKGFzeW5jIChmaWxlLCBpKT0+e1xuICAgICAgICBjb25zdCBwcmVzaWduZWQgPSBqc29uLmRhdGFbaV07XG4gICAgICAgIGlmICghcHJlc2lnbmVkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcHJlc2lnbmVkIFVSTCBmb3IgZmlsZTpcIiwgZmlsZSwgcHJlc2lnbmVkKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcIlVSTF9HRU5FUkFUSU9OX0ZBSUxFRFwiLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIGdlbmVyYXRlIHByZXNpZ25lZCBVUkxcIixcbiAgICAgICAgICAgICAgICBjYXVzZTogSlNPTi5zdHJpbmdpZnkocHJlc2lnbmVkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwidXJsc1wiIGluIHByZXNpZ25lZCkge1xuICAgICAgICAgICAgYXdhaXQgdXBsb2FkTXVsdGlwYXJ0KGZpbGUsIHByZXNpZ25lZCwge1xuICAgICAgICAgICAgICAgIC4uLm9wdHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdXBsb2FkUHJlc2lnbmVkUG9zdChmaWxlLCBwcmVzaWduZWQsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb2xsIGZvciBmaWxlIHRvIGJlIGF2YWlsYWJsZVxuICAgICAgICBsb2dnZXIuZGVidWcoXCJQb2xsaW5nIGZvciBmaWxlIGRhdGEuLi5cIik7XG4gICAgICAgIGF3YWl0IHBvbGxGb3JGaWxlRGF0YSh7XG4gICAgICAgICAgICB1cmw6IGdlbmVyYXRlVXBsb2FkVGhpbmdVUkwoYC9hcGkvcG9sbFVwbG9hZC8ke3ByZXNpZ25lZC5rZXl9YCksXG4gICAgICAgICAgICBhcGlLZXk6IG9wdHMudXRSZXF1ZXN0SGVhZGVyc1tcIngtdXBsb2FkdGhpbmctYXBpLWtleVwiXSxcbiAgICAgICAgICAgIHNka1ZlcnNpb246IHZlcnNpb24sXG4gICAgICAgICAgICBmZXRjaDogb3B0cy5mZXRjaFxuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUG9sbGluZyBjb21wbGV0ZS5cIik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHByZXNpZ25lZC5rZXksXG4gICAgICAgICAgICB1cmw6IHByZXNpZ25lZC5maWxlVXJsLFxuICAgICAgICAgICAgbmFtZTogZmlsZS5uYW1lLFxuICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgICAgdHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgY3VzdG9tSWQ6IFwiY3VzdG9tSWRcIiBpbiBmaWxlID8gZmlsZS5jdXN0b21JZCA/PyBudWxsIDogbnVsbFxuICAgICAgICB9O1xuICAgIH0pKTtcbiAgICBsb2dnZXIuZGVidWcoXCJBbGwgdXBsb2FkcyBjb21wbGV0ZSwgYWdncmVnYXRpbmcgcmVzdWx0cy4uLlwiKTtcbiAgICByZXR1cm4gdXBsb2Fkcy5tYXAoKHVwbG9hZCk9PntcbiAgICAgICAgaWYgKHVwbG9hZC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB1cGxvYWQudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugb25seSB0aHJvdyBVcGxvYWRUaGluZ0Vycm9ycywgc28gdGhpcyBpcyBzYWZlXG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IHVwbG9hZC5yZWFzb247XG4gICAgICAgIGNvbnN0IGVycm9yID0gVXBsb2FkVGhpbmdFcnJvci50b09iamVjdChyZWFzb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuYXN5bmMgZnVuY3Rpb24gdXBsb2FkTXVsdGlwYXJ0KGZpbGUsIHByZXNpZ25lZCwgb3B0cykge1xuICAgIGxvZ2dlci5kZWJ1ZyhcIlVwbG9hZGluZyBmaWxlXCIsIGZpbGUubmFtZSwgXCJ3aXRoXCIsIHByZXNpZ25lZC51cmxzLmxlbmd0aCwgXCJjaHVua3Mgb2Ygc2l6ZVwiLCBwcmVzaWduZWQuY2h1bmtTaXplLCBcImJ5dGVzIGVhY2hcIik7XG4gICAgY29uc3QgZXRhZ3MgPSBhd2FpdCBQcm9taXNlLmFsbChwcmVzaWduZWQudXJscy5tYXAoYXN5bmMgKHVybCwgaW5kZXgpPT57XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHByZXNpZ25lZC5jaHVua1NpemUgKiBpbmRleDtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4ob2Zmc2V0ICsgcHJlc2lnbmVkLmNodW5rU2l6ZSwgZmlsZS5zaXplKTtcbiAgICAgICAgY29uc3QgY2h1bmsgPSBmaWxlLnNsaWNlKG9mZnNldCwgZW5kKTtcbiAgICAgICAgY29uc3QgZXRhZyA9IGF3YWl0IHVwbG9hZFBhcnQoe1xuICAgICAgICAgICAgZmV0Y2g6IG9wdHMuZmV0Y2gsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBjaHVuazogY2h1bmssXG4gICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IHByZXNpZ25lZC5jb250ZW50RGlzcG9zaXRpb24sXG4gICAgICAgICAgICBjb250ZW50VHlwZTogZmlsZS50eXBlLFxuICAgICAgICAgICAgZmlsZU5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgICAgIG1heFJldHJpZXM6IDEwLFxuICAgICAgICAgICAga2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgdXRSZXF1ZXN0SGVhZGVyczogb3B0cy51dFJlcXVlc3RIZWFkZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJQYXJ0XCIsIGluZGV4ICsgMSwgXCJ1cGxvYWRlZCBzdWNjZXNzZnVsbHk6XCIsIGV0YWcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFnOiBldGFnLFxuICAgICAgICAgICAgcGFydE51bWJlcjogaW5kZXggKyAxXG4gICAgICAgIH07XG4gICAgfSkpO1xuICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbGVcIiwgZmlsZS5uYW1lLCBcInVwbG9hZGVkIHN1Y2Nlc3NmdWxseS4gTm90aWZ5aW5nIFVwbG9hZFRoaW5nIHRvIGNvbXBsZXRlIG11bHRpcGFydCB1cGxvYWQuXCIpO1xuICAgIC8vIENvbXBsZXRlIG11bHRpcGFydCB1cGxvYWRcbiAgICBjb25zdCBjb21wbGV0aW9uUmVzID0gYXdhaXQgb3B0cy5mZXRjaChnZW5lcmF0ZVVwbG9hZFRoaW5nVVJMKFwiL2FwaS9jb21wbGV0ZU11bHRpcGFydFwiKSwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBmaWxlS2V5OiBwcmVzaWduZWQua2V5LFxuICAgICAgICAgICAgdXBsb2FkSWQ6IHByZXNpZ25lZC51cGxvYWRJZCxcbiAgICAgICAgICAgIGV0YWdzXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiBvcHRzLnV0UmVxdWVzdEhlYWRlcnNcbiAgICB9KTtcbiAgICBsb2dnZXIuZGVidWcoXCJVcGxvYWRUaGluZyByZXNwb25zZWQgd2l0aCBzdGF0dXM6XCIsIGNvbXBsZXRpb25SZXMuc3RhdHVzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZFByZXNpZ25lZFBvc3QoZmlsZSwgcHJlc2lnbmVkLCBvcHRzKSB7XG4gICAgbG9nZ2VyLmRlYnVnKFwiVXBsb2FkaW5nIGZpbGVcIiwgZmlsZS5uYW1lLCBcInVzaW5nIHByZXNpZ25lZCBQT1NUIFVSTFwiKTtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIE9iamVjdC5lbnRyaWVzKHByZXNpZ25lZC5maWVsZHMpLmZvckVhY2goKFtrLCB2XSk9PmZvcm1EYXRhLmFwcGVuZChrLCB2KSk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBmaWxlKTsgLy8gRmlsZSBkYXRhICoqTVVTVCBHTyBMQVNUKipcbiAgICBjb25zdCByZXMgPSBhd2FpdCBvcHRzLmZldGNoKHByZXNpZ25lZC51cmwsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgICAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi94bWxcIlxuICAgICAgICB9KVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gdXBsb2FkIGZpbGU6XCIsIHRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICBjb2RlOiBcIlVQTE9BRF9GQUlMRURcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHVwbG9hZCBmaWxlXCIsXG4gICAgICAgICAgICBjYXVzZTogdGV4dFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9nZ2VyLmRlYnVnKFwiRmlsZVwiLCBmaWxlLm5hbWUsIFwidXBsb2FkZWQgc3VjY2Vzc2Z1bGx5XCIpO1xufVxuZnVuY3Rpb24gcGFyc2VUaW1lVG9TZWNvbmRzKHRpbWUpIHtcbiAgICBjb25zdCBtYXRjaCA9IHRpbWUudG9TdHJpbmcoKS5zcGxpdCgvKFxcZCspLykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IG51bSA9IE51bWJlcihtYXRjaFswXSk7XG4gICAgY29uc3QgdW5pdCA9IChtYXRjaFsxXSA/PyBcInNcIikudHJpbSgpLnNsaWNlKDAsIDEpO1xuICAgIGNvbnN0IG11bHRpcGxpZXIgPSB7XG4gICAgICAgIHM6IDEsXG4gICAgICAgIG06IDYwLFxuICAgICAgICBoOiAzNjAwLFxuICAgICAgICBkOiA4NjQwMFxuICAgIH1bdW5pdF07XG4gICAgcmV0dXJuIG51bSAqIG11bHRpcGxpZXI7XG59XG5cbi8qKlxuICogRXh0ZW5zaW9uIG9mIHRoZSBCbG9iIGNsYXNzIHRoYXQgc2ltcGxpZmllcyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kIGBjdXN0b21JZGAgcHJvcGVydGllcyxcbiAqIHNpbWlsYXIgdG8gdGhlIGJ1aWx0LWluIEZpbGUgY2xhc3MgZnJvbSBOb2RlID4gMjAuXG4gKi8gY2xhc3MgVVRGaWxlIGV4dGVuZHMgQmxvYiB7XG4gICAgY29uc3RydWN0b3IocGFydHMsIG5hbWUsIG9wdGlvbnMpe1xuICAgICAgICBjb25zdCBvcHRpb25zV2l0aERlZmF1bHRzID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHR5cGU6IG9wdGlvbnM/LnR5cGUgPz8gKGxvb2t1cChuYW1lKSB8fCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiBvcHRpb25zPy5sYXN0TW9kaWZpZWQgPz8gRGF0ZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihwYXJ0cywgb3B0aW9uc1dpdGhEZWZhdWx0cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY3VzdG9tSWQgPSBvcHRpb25zV2l0aERlZmF1bHRzLmN1c3RvbUlkO1xuICAgICAgICB0aGlzLmxhc3RNb2RpZmllZCA9IG9wdGlvbnNXaXRoRGVmYXVsdHMubGFzdE1vZGlmaWVkO1xuICAgIH1cbn1cbmNsYXNzIFVUQXBpIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKXtcbiAgICAgICAgLyoqXG4gICAqIFJlcXVlc3QgdG8gZGVsZXRlIGZpbGVzIGZyb20gVXBsb2FkVGhpbmcgc3RvcmFnZS5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gZmlsZUtleXNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgZGVsZXRlRmlsZXMoXCIyZTBmZGI2NC05OTU3LTQyNjItOGU0NS1mMzcyYmE5MDNhYzhfaW1hZ2UuanBnXCIpO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBhd2FpdCBkZWxldGVGaWxlcyhbXCIyZTBmZGI2NC05OTU3LTQyNjItOGU0NS1mMzcyYmE5MDNhYzhfaW1hZ2UuanBnXCIsXCIxNjQ5MzUzYi0wNGVhLTQ4YTItOWRiNy0zMWRlN2Y1NjJjOGRfaW1hZ2UyLmpwZ1wiXSlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYXdhaXQgZGVsZXRlRmlsZXMoXCJteUN1c3RvbUlkZW50aWZpZXJcIiwgeyBrZXlUeXBlOiBcImN1c3RvbUlkXCIgfSlcbiAgICovIHRoaXMuZGVsZXRlRmlsZXMgPSBhc3luYyAoa2V5cywgb3B0cyk9PntcbiAgICAgICAgICAgIGd1YXJkU2VydmVyT25seSgpO1xuICAgICAgICAgICAgY29uc3QgeyBrZXlUeXBlID0gdGhpcy5kZWZhdWx0S2V5VHlwZSB9ID0gb3B0cyA/PyB7fTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RVcGxvYWRUaGluZyhcIi9hcGkvZGVsZXRlRmlsZVwiLCBrZXlUeXBlID09PSBcImZpbGVLZXlcIiA/IHtcbiAgICAgICAgICAgICAgICBmaWxlS2V5czogYXNBcnJheShrZXlzKVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICBjdXN0b21JZHM6IGFzQXJyYXkoa2V5cylcbiAgICAgICAgICAgIH0sIFwiQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZCB3aGlsZSBkZWxldGluZyBmaWxlcy5cIik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgKiBSZXF1ZXN0IGZpbGUgVVJMcyBmcm9tIFVwbG9hZFRoaW5nIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW119IGZpbGVLZXlzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRGaWxlVXJscyhcIjJlMGZkYjY0LTk5NTctNDI2Mi04ZTQ1LWYzNzJiYTkwM2FjOF9pbWFnZS5qcGdcIik7XG4gICAqIGNvbnNvbGUubG9nKGRhdGEpOyAvLyBbe2tleTogXCIyZTBmZGI2NC05OTU3LTQyNjItOGU0NS1mMzcyYmE5MDNhYzhfaW1hZ2UuanBnXCIsIHVybDogXCJodHRwczovL3VwbG9hZHRoaW5nLmNvbS9mLzJlMGZkYjY0LTk5NTctNDI2Mi04ZTQ1LWYzNzJiYTkwM2FjOF9pbWFnZS5qcGdcIn1dXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGRhdGEgPSBhd2FpdCBnZXRGaWxlVXJscyhbXCIyZTBmZGI2NC05OTU3LTQyNjItOGU0NS1mMzcyYmE5MDNhYzhfaW1hZ2UuanBnXCIsXCIxNjQ5MzUzYi0wNGVhLTQ4YTItOWRiNy0zMWRlN2Y1NjJjOGRfaW1hZ2UyLmpwZ1wiXSlcbiAgICogY29uc29sZS5sb2coZGF0YSkgLy8gW3trZXk6IFwiMmUwZmRiNjQtOTk1Ny00MjYyLThlNDUtZjM3MmJhOTAzYWM4X2ltYWdlLmpwZ1wiLCB1cmw6IFwiaHR0cHM6Ly91cGxvYWR0aGluZy5jb20vZi8yZTBmZGI2NC05OTU3LTQyNjItOGU0NS1mMzcyYmE5MDNhYzhfaW1hZ2UuanBnXCIgfSx7a2V5OiBcIjE2NDkzNTNiLTA0ZWEtNDhhMi05ZGI3LTMxZGU3ZjU2MmM4ZF9pbWFnZTIuanBnXCIsIHVybDogXCJodHRwczovL3VwbG9hZHRoaW5nLmNvbS9mLzE2NDkzNTNiLTA0ZWEtNDhhMi05ZGI3LTMxZGU3ZjU2MmM4ZF9pbWFnZTIuanBnXCJ9XVxuICAgKi8gdGhpcy5nZXRGaWxlVXJscyA9IGFzeW5jIChrZXlzLCBvcHRzKT0+e1xuICAgICAgICAgICAgZ3VhcmRTZXJ2ZXJPbmx5KCk7XG4gICAgICAgICAgICBjb25zdCB7IGtleVR5cGUgPSB0aGlzLmRlZmF1bHRLZXlUeXBlIH0gPSBvcHRzID8/IHt9O1xuICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHRoaXMucmVxdWVzdFVwbG9hZFRoaW5nKFwiL2FwaS9nZXRGaWxlVXJsXCIsIGtleVR5cGUgPT09IFwiZmlsZUtleVwiID8ge1xuICAgICAgICAgICAgICAgIGZpbGVLZXlzOiBhc0FycmF5KGtleXMpXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgIGN1c3RvbUlkczogYXNBcnJheShrZXlzKVxuICAgICAgICAgICAgfSwgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIHJldHJpZXZpbmcgZmlsZSBVUkxzLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBqc29uLmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgKiBSZXF1ZXN0IGZpbGUgbGlzdCBmcm9tIFVwbG9hZFRoaW5nIHN0b3JhZ2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLmxpbWl0IFRoZSBtYXhpbXVtIG51bWJlciBvZiBmaWxlcyB0byByZXR1cm5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMub2Zmc2V0IFRoZSBudW1iZXIgb2YgZmlsZXMgdG8gc2tpcFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBkYXRhID0gYXdhaXQgbGlzdEZpbGVzKHsgbGltaXQ6IDEgfSk7XG4gICAqIGNvbnNvbGUubG9nKGRhdGEpOyAvLyB7IGtleTogXCIyZTBmZGI2NC05OTU3LTQyNjItOGU0NS1mMzcyYmE5MDNhYzhfaW1hZ2UuanBnXCIsIGlkOiBcIjJlMGZkYjY0LTk5NTctNDI2Mi04ZTQ1LWYzNzJiYTkwM2FjOFwiIH1cbiAgICovIHRoaXMubGlzdEZpbGVzID0gYXN5bmMgKG9wdHMpPT57XG4gICAgICAgICAgICBndWFyZFNlcnZlck9ubHkoKTtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCB0aGlzLnJlcXVlc3RVcGxvYWRUaGluZyhcIi9hcGkvbGlzdEZpbGVzXCIsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgICAgICB9LCBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgbGlzdGluZyBmaWxlcy5cIik7XG4gICAgICAgICAgICByZXR1cm4ganNvbi5maWxlcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW5hbWVGaWxlcyA9IGFzeW5jICh1cGRhdGVzKT0+e1xuICAgICAgICAgICAgZ3VhcmRTZXJ2ZXJPbmx5KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0VXBsb2FkVGhpbmcoXCIvYXBpL3JlbmFtZUZpbGVzXCIsIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVzOiBhc0FycmF5KHVwZGF0ZXMpXG4gICAgICAgICAgICB9LCBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVuYW1pbmcgZmlsZXMuXCIpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayByZW5hbWVGaWxlc30gaW5zdGVhZC4gKi8gdGhpcy5yZW5hbWVGaWxlID0gdGhpcy5yZW5hbWVGaWxlcztcbiAgICAgICAgdGhpcy5nZXRVc2FnZUluZm8gPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgZ3VhcmRTZXJ2ZXJPbmx5KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0VXBsb2FkVGhpbmcoXCIvYXBpL2dldFVzYWdlSW5mb1wiLCB7fSwgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGdldHRpbmcgdXNhZ2UgaW5mby5cIik7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBSZXF1ZXN0IGEgcHJlc2lnbmVkIHVybCBmb3IgYSBwcml2YXRlIGZpbGUocykgKi8gdGhpcy5nZXRTaWduZWRVUkwgPSBhc3luYyAoa2V5LCBvcHRzKT0+e1xuICAgICAgICAgICAgZ3VhcmRTZXJ2ZXJPbmx5KCk7XG4gICAgICAgICAgICBjb25zdCBleHBpcmVzSW4gPSBvcHRzPy5leHBpcmVzSW4gPyBwYXJzZVRpbWVUb1NlY29uZHMob3B0cy5leHBpcmVzSW4pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgeyBrZXlUeXBlID0gdGhpcy5kZWZhdWx0S2V5VHlwZSB9ID0gb3B0cyA/PyB7fTtcbiAgICAgICAgICAgIGlmIChvcHRzPy5leHBpcmVzSW4gJiYgaXNOYU4oZXhwaXJlc0luKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcImV4cGlyZXNJbiBtdXN0IGJlIGEgdmFsaWQgdGltZSBzdHJpbmcsIGZvciBleGFtcGxlICcxZCcsICcyIGRheXMnLCBvciBhIG51bWJlciBvZiBzZWNvbmRzLlwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhwaXJlc0luICYmIGV4cGlyZXNJbiA+IDg2NDAwICogNykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcImV4cGlyZXNJbiBtdXN0IGJlIGxlc3MgdGhhbiA3IGRheXMgKDYwNDgwMCBzZWNvbmRzKS5cIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHRoaXMucmVxdWVzdFVwbG9hZFRoaW5nKFwiL2FwaS9yZXF1ZXN0RmlsZUFjY2Vzc1wiLCBrZXlUeXBlID09PSBcImZpbGVLZXlcIiA/IHtcbiAgICAgICAgICAgICAgICBmaWxlS2V5OiBrZXksXG4gICAgICAgICAgICAgICAgZXhwaXJlc0luXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgIGN1c3RvbUlkOiBrZXksXG4gICAgICAgICAgICAgICAgZXhwaXJlc0luXG4gICAgICAgICAgICB9LCBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmV0cmlldmluZyBwcmVzaWduZWQgVVJMcy5cIik7XG4gICAgICAgICAgICByZXR1cm4ganNvbi51cmw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmV0Y2ggPSBvcHRzPy5mZXRjaCA/PyBnbG9iYWxUaGlzLmZldGNoO1xuICAgICAgICB0aGlzLmFwaUtleSA9IG9wdHM/LmFwaUtleSA/PyBwcm9jZXNzLmVudi5VUExPQURUSElOR19TRUNSRVQ7XG4gICAgICAgIHRoaXMuZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1hcGkta2V5XCI6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgXCJ4LXVwbG9hZHRoaW5nLXZlcnNpb25cIjogdmVyc2lvbixcbiAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy1iZS1hZGFwdGVyXCI6IFwic2VydmVyLXNka1wiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVmYXVsdEtleVR5cGUgPSBvcHRzPy5kZWZhdWx0S2V5VHlwZSA/PyBcImZpbGVLZXlcIjtcbiAgICAgICAgaW5pdExvZ2dlcihvcHRzPy5sb2dMZXZlbCk7XG4gICAgICAgIC8vIEFzc2VydCBzb21lIHN0dWZmXG4gICAgICAgIGd1YXJkU2VydmVyT25seSgpO1xuICAgICAgICBnZXRBcGlLZXlPclRocm93KHRoaXMuYXBpS2V5KTtcbiAgICAgICAgaWYgKCF0aGlzLmFwaUtleT8uc3RhcnRzV2l0aChcInNrX1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVwbG9hZFRoaW5nRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiTUlTU0lOR19FTlZcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgQVBJIGtleS4gQVBJIGtleXMgbXVzdCBzdGFydCB3aXRoIGBza19gLlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpbmNvbXBhdGlibGVOb2RlR3VhcmQoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVxdWVzdFVwbG9hZFRoaW5nKHBhdGhuYW1lLCBib2R5LCBmYWxsYmFja0Vycm9yTWVzc2FnZSkge1xuICAgICAgICBjb25zdCB1cmwgPSBnZW5lcmF0ZVVwbG9hZFRoaW5nVVJMKHBhdGhuYW1lKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUmVxdWVzdGluZyBVcGxvYWRUaGluZzpcIiwge1xuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZGVmYXVsdEhlYWRlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZmV0Y2godXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgY2FjaGU6IFwibm8tc3RvcmVcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuZGVmYXVsdEhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiVXBsb2FkVGhpbmcgcmVzcG9uc2VkIHdpdGggc3RhdHVzOlwiLCByZXMuc3RhdHVzKTtcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICAgIGlmICghcmVzLm9rIHx8IFwiZXJyb3JcIiBpbiBqc29uKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvcjpcIiwganNvbik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcImVycm9yXCIgaW4ganNvbiAmJiB0eXBlb2YganNvbi5lcnJvciA9PT0gXCJzdHJpbmdcIiA/IGpzb24uZXJyb3IgOiBmYWxsYmFja0Vycm9yTWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiVXBsb2FkVGhpbmcgcmVzcG9uc2U6XCIsIGpzb24pO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkRmlsZXMoZmlsZXMsIG9wdHMpIHtcbiAgICAgICAgZ3VhcmRTZXJ2ZXJPbmx5KCk7XG4gICAgICAgIGNvbnN0IHVwbG9hZHMgPSBhd2FpdCB1cGxvYWRGaWxlc0ludGVybmFsKHtcbiAgICAgICAgICAgIGZpbGVzOiBhc0FycmF5KGZpbGVzKSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRzPy5tZXRhZGF0YSA/PyB7fSxcbiAgICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbjogb3B0cz8uY29udGVudERpc3Bvc2l0aW9uID8/IFwiaW5saW5lXCIsXG4gICAgICAgICAgICBhY2w6IG9wdHM/LmFjbFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIHV0UmVxdWVzdEhlYWRlcnM6IHRoaXMuZGVmYXVsdEhlYWRlcnNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHVwbG9hZEZpbGVSZXNwb25zZSA9IEFycmF5LmlzQXJyYXkoZmlsZXMpID8gdXBsb2FkcyA6IHVwbG9hZHNbMF07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbmlzaGVkIHVwbG9hZGluZzpcIiwgdXBsb2FkRmlsZVJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZEZpbGVSZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgdXBsb2FkRmlsZXNGcm9tVXJsKHVybHMsIG9wdHMpIHtcbiAgICAgICAgZ3VhcmRTZXJ2ZXJPbmx5KCk7XG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZChcIm1ldGFkYXRhXCIsIEpTT04uc3RyaW5naWZ5KG9wdHM/Lm1ldGFkYXRhID8/IHt9KSk7XG4gICAgICAgIGNvbnN0IGRvd25sb2FkRXJyb3JzID0ge307XG4gICAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYXNBcnJheSh1cmxzKS5tYXAoYXN5bmMgKF91cmwsIGluZGV4KT0+e1xuICAgICAgICAgICAgbGV0IHVybCA9IGlzT2JqZWN0KF91cmwpID8gX3VybC51cmwgOiBfdXJsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBkYXRhdXJscyB3aWxsIHJlc3VsdCBpbiBuYW1lIGJlaW5nIHRvbyBsb25nLCB0ZWxsIHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgLy8gdG8gdXNlIHVwbG9hZEZpbGVzIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRFcnJvcnNbaW5kZXhdID0gVXBsb2FkVGhpbmdFcnJvci50b09iamVjdChuZXcgVXBsb2FkVGhpbmdFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlBsZWFzZSB1c2UgdXBsb2FkRmlsZXMoKSBmb3IgZGF0YSBVUkxzLiB1cGxvYWRGaWxlc0Zyb21VcmwoKSBpcyBpbnRlbmRlZCBmb3IgdXNlIHdpdGggcmVtb3RlIFVSTHMgb25seS5cIlxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVybCA9IG5ldyBVUkwodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSA9IHVybC5wYXRobmFtZS5zcGxpdChcIi9cIikucG9wKCkgPz8gXCJ1bmtub3duLWZpbGVuYW1lXCIsIGN1c3RvbUlkID0gdW5kZWZpbmVkIH0gPSBpc09iamVjdChfdXJsKSA/IF91cmwgOiB7fTtcbiAgICAgICAgICAgIC8vIERvd25sb2FkIHRoZSBmaWxlIG9uIHRoZSB1c2VyJ3Mgc2VydmVyIHRvIGF2b2lkIGVncmVzcyBjaGFyZ2VzXG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJEb3dubG9hZGluZyBmaWxlOlwiLCB1cmwpO1xuICAgICAgICAgICAgY29uc3QgZmlsZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh1cmwpO1xuICAgICAgICAgICAgaWYgKCFmaWxlUmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBkb3dubG9hZEVycm9yc1tpbmRleF0gPSBVcGxvYWRUaGluZ0Vycm9yLnRvT2JqZWN0KG5ldyBVcGxvYWRUaGluZ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJCQURfUkVRVUVTVFwiLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBkb3dubG9hZCByZXF1ZXN0ZWQgZmlsZS5cIixcbiAgICAgICAgICAgICAgICAgICAgY2F1c2U6IGZpbGVSZXNwb25zZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRmluaXNoZWQgZG93bmxvYWRpbmcgZmlsZS4gUmVhZGluZyBibG9iLi4uXCIpO1xuICAgICAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IGZpbGVSZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJGaW5pc2hlZCByZWFkaW5nIGJsb2IuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVVEZpbGUoW1xuICAgICAgICAgICAgICAgIGJsb2JcbiAgICAgICAgICAgIF0sIG5hbWUsIHtcbiAgICAgICAgICAgICAgICBjdXN0b21JZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKS50aGVuKChmaWxlcyk9PmZpbGVzLmZpbHRlcigoeCk9PnggIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJVcGxvYWRpbmcgZmlsZXM6XCIsIGZpbGVzKTtcbiAgICAgICAgY29uc3QgdXBsb2FkcyA9IGF3YWl0IHVwbG9hZEZpbGVzSW50ZXJuYWwoe1xuICAgICAgICAgICAgZmlsZXMsXG4gICAgICAgICAgICBtZXRhZGF0YTogb3B0cz8ubWV0YWRhdGEgPz8ge30sXG4gICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IG9wdHM/LmNvbnRlbnREaXNwb3NpdGlvbiA/PyBcImlubGluZVwiLFxuICAgICAgICAgICAgYWNsOiBvcHRzPy5hY2xcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICB1dFJlcXVlc3RIZWFkZXJzOiB0aGlzLmRlZmF1bHRIZWFkZXJzXG4gICAgICAgIH0pO1xuICAgICAgICAvKiogUHV0IGl0IGFsbCBiYWNrIHRvZ2V0aGVyLCBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2YgZmlsZXMgKi8gY29uc3QgcmVzcG9uc2VzID0gYXNBcnJheSh1cmxzKS5tYXAoKF8sIGluZGV4KT0+e1xuICAgICAgICAgICAgaWYgKGRvd25sb2FkRXJyb3JzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBkb3dubG9hZEVycm9yc1tpbmRleF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwbG9hZHMuc2hpZnQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKiBSZXR1cm4gc2luZ2xlIG9iamVjdCBvciBhcnJheSBiYXNlZCBvbiBpbnB1dCB1cmxzICovIGNvbnN0IHVwbG9hZEZpbGVSZXNwb25zZSA9IEFycmF5LmlzQXJyYXkodXJscykgPyByZXNwb25zZXMgOiByZXNwb25zZXNbMF07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkZpbmlzaGVkIHVwbG9hZGluZzpcIiwgdXBsb2FkRmlsZVJlc3BvbnNlKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZEZpbGVSZXNwb25zZTtcbiAgICB9XG59XG5cbmNvbnN0IGNyZWF0ZVVwbG9hZHRoaW5nID0gKG9wdHMpPT5jcmVhdGVCdWlsZGVyKG9wdHMpO1xuLyoqIEBpbnRlcm5hbCAqLyBjb25zdCBJTlRFUk5BTF9ET19OT1RfVVNFX2NyZWF0ZVJvdXRlSGFuZGxlckNvcmUgPSAob3B0cywgYWRhcHRlcik9PntcbiAgICBpbml0TG9nZ2VyKG9wdHMuY29uZmlnPy5sb2dMZXZlbCk7XG4gICAgaW5jb21wYXRpYmxlTm9kZUd1YXJkKCk7XG4gICAgY29uc3QgcmVxdWVzdEhhbmRsZXIgPSBidWlsZFJlcXVlc3RIYW5kbGVyKG9wdHMsIGFkYXB0ZXIpO1xuICAgIGNvbnN0IGdldEJ1aWxkUGVybXMgPSBidWlsZFBlcm1pc3Npb25zSW5mb0hhbmRsZXIob3B0cyk7XG4gICAgY29uc3QgUE9TVCA9IGFzeW5jIChyZXF1ZXN0KT0+e1xuICAgICAgICBjb25zdCByZXEgPSByZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCA/IHJlcXVlc3QgOiByZXF1ZXN0LnJlcXVlc3Q7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVxdWVzdEhhbmRsZXIoe1xuICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgbWlkZGxld2FyZUFyZ3M6IHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgcmVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgVXBsb2FkVGhpbmdFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShmb3JtYXRFcnJvcihyZXNwb25zZSwgb3B0cy5yb3V0ZXIpKSwge1xuICAgICAgICAgICAgICAgIHN0YXR1czogZ2V0U3RhdHVzQ29kZUZyb21FcnJvcihyZXNwb25zZSksXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBcIngtdXBsb2FkdGhpbmctdmVyc2lvblwiOiB2ZXJzaW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAvLyBXZSBtZXNzZWQgdXAgLSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkXCIsIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCI6IHZlcnNpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuYm9keSksIHtcbiAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCI6IHZlcnNpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSB0aGlzIGlzIGEgY3VzdG9tIHByb3BlcnR5XG4gICAgICAgIHJlcy5jbGVhbnVwID0gcmVzcG9uc2UuY2xlYW51cDtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIGNvbnN0IEdFVCA9IChyZXF1ZXN0KT0+e1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KGdldEJ1aWxkUGVybXMoKSksIHtcbiAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwieC11cGxvYWR0aGluZy12ZXJzaW9uXCI6IHZlcnNpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBHRVQsXG4gICAgICAgIFBPU1RcbiAgICB9O1xufTtcbmNvbnN0IGNyZWF0ZVJvdXRlSGFuZGxlciA9IChvcHRzKT0+SU5URVJOQUxfRE9fTk9UX1VTRV9jcmVhdGVSb3V0ZUhhbmRsZXJDb3JlKG9wdHMsIFwic2VydmVyXCIpO1xuY29uc3QgZXh0cmFjdFJvdXRlckNvbmZpZyA9IChyb3V0ZXIpPT5idWlsZFBlcm1pc3Npb25zSW5mb0hhbmRsZXIoe1xuICAgICAgICByb3V0ZXJcbiAgICB9KSgpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGNyZWF0ZVJvdXRlSGFuZGxlcn0gaW5zdGVhZFxuICovIGNvbnN0IGNyZWF0ZVNlcnZlckhhbmRsZXIgPSBjcmVhdGVSb3V0ZUhhbmRsZXI7XG5cbmV4cG9ydCB7IElOVEVSTkFMX0RPX05PVF9VU0VfY3JlYXRlUm91dGVIYW5kbGVyQ29yZSwgVVRBcGksIFVURmlsZSwgY3JlYXRlUm91dGVIYW5kbGVyLCBjcmVhdGVTZXJ2ZXJIYW5kbGVyLCBjcmVhdGVVcGxvYWR0aGluZywgZXh0cmFjdFJvdXRlckNvbmZpZyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uploadthing/server/index.js\n");

/***/ })

};
;