"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@huggingface";
exports.ids = ["vendor-chunks/@huggingface"];
exports.modules = {

/***/ "(rsc)/./node_modules/@huggingface/jinja/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@huggingface/jinja/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   Interpreter: () => (/* binding */ Interpreter),\n/* harmony export */   Template: () => (/* binding */ Template),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n// src/lexer.ts\nvar TOKEN_TYPES = Object.freeze({\n  Text: \"Text\",\n  // The text between Jinja statements or expressions\n  NumericLiteral: \"NumericLiteral\",\n  // e.g., 123\n  BooleanLiteral: \"BooleanLiteral\",\n  // true or false\n  StringLiteral: \"StringLiteral\",\n  // 'string'\n  Identifier: \"Identifier\",\n  // Variables, functions, etc.\n  Equals: \"Equals\",\n  // =\n  OpenParen: \"OpenParen\",\n  // (\n  CloseParen: \"CloseParen\",\n  // )\n  OpenStatement: \"OpenStatement\",\n  // {%\n  CloseStatement: \"CloseStatement\",\n  // %}\n  OpenExpression: \"OpenExpression\",\n  // {{\n  CloseExpression: \"CloseExpression\",\n  // }}\n  OpenSquareBracket: \"OpenSquareBracket\",\n  // [\n  CloseSquareBracket: \"CloseSquareBracket\",\n  // ]\n  OpenCurlyBracket: \"OpenCurlyBracket\",\n  // {\n  CloseCurlyBracket: \"CloseCurlyBracket\",\n  // }\n  Comma: \"Comma\",\n  // ,\n  Dot: \"Dot\",\n  // .\n  Colon: \"Colon\",\n  // :\n  Pipe: \"Pipe\",\n  // |\n  CallOperator: \"CallOperator\",\n  // ()\n  AdditiveBinaryOperator: \"AdditiveBinaryOperator\",\n  // + -\n  MultiplicativeBinaryOperator: \"MultiplicativeBinaryOperator\",\n  // * / %\n  ComparisonBinaryOperator: \"ComparisonBinaryOperator\",\n  // < > <= >= == !=\n  UnaryOperator: \"UnaryOperator\",\n  // ! - +\n  // Keywords\n  Set: \"Set\",\n  If: \"If\",\n  For: \"For\",\n  In: \"In\",\n  Is: \"Is\",\n  NotIn: \"NotIn\",\n  Else: \"Else\",\n  EndIf: \"EndIf\",\n  ElseIf: \"ElseIf\",\n  EndFor: \"EndFor\",\n  And: \"And\",\n  Or: \"Or\",\n  Not: \"UnaryOperator\"\n});\nvar KEYWORDS = Object.freeze({\n  set: TOKEN_TYPES.Set,\n  for: TOKEN_TYPES.For,\n  in: TOKEN_TYPES.In,\n  is: TOKEN_TYPES.Is,\n  if: TOKEN_TYPES.If,\n  else: TOKEN_TYPES.Else,\n  endif: TOKEN_TYPES.EndIf,\n  elif: TOKEN_TYPES.ElseIf,\n  endfor: TOKEN_TYPES.EndFor,\n  and: TOKEN_TYPES.And,\n  or: TOKEN_TYPES.Or,\n  not: TOKEN_TYPES.Not,\n  \"not in\": TOKEN_TYPES.NotIn,\n  // Literals\n  true: TOKEN_TYPES.BooleanLiteral,\n  false: TOKEN_TYPES.BooleanLiteral\n});\nvar Token = class {\n  /**\n   * Constructs a new Token.\n   * @param {string} value The raw value as seen inside the source code.\n   * @param {TokenType} type The type of token.\n   */\n  constructor(value, type) {\n    this.value = value;\n    this.type = type;\n  }\n};\nfunction isWord(char) {\n  return /\\w/.test(char);\n}\nfunction isInteger(char) {\n  return /[0-9]/.test(char);\n}\nvar ORDERED_MAPPING_TABLE = [\n  // Control sequences\n  [\"{%\", TOKEN_TYPES.OpenStatement],\n  [\"%}\", TOKEN_TYPES.CloseStatement],\n  [\"{{\", TOKEN_TYPES.OpenExpression],\n  [\"}}\", TOKEN_TYPES.CloseExpression],\n  // Single character tokens\n  [\"(\", TOKEN_TYPES.OpenParen],\n  [\")\", TOKEN_TYPES.CloseParen],\n  [\"{\", TOKEN_TYPES.OpenCurlyBracket],\n  [\"}\", TOKEN_TYPES.CloseCurlyBracket],\n  [\"[\", TOKEN_TYPES.OpenSquareBracket],\n  [\"]\", TOKEN_TYPES.CloseSquareBracket],\n  [\",\", TOKEN_TYPES.Comma],\n  [\".\", TOKEN_TYPES.Dot],\n  [\":\", TOKEN_TYPES.Colon],\n  [\"|\", TOKEN_TYPES.Pipe],\n  // Comparison operators\n  [\"<=\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\">=\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\"==\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\"!=\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\"<\", TOKEN_TYPES.ComparisonBinaryOperator],\n  [\">\", TOKEN_TYPES.ComparisonBinaryOperator],\n  // Arithmetic operators\n  [\"+\", TOKEN_TYPES.AdditiveBinaryOperator],\n  [\"-\", TOKEN_TYPES.AdditiveBinaryOperator],\n  [\"*\", TOKEN_TYPES.MultiplicativeBinaryOperator],\n  [\"/\", TOKEN_TYPES.MultiplicativeBinaryOperator],\n  [\"%\", TOKEN_TYPES.MultiplicativeBinaryOperator],\n  // Assignment operator\n  [\"=\", TOKEN_TYPES.Equals]\n];\nvar ESCAPE_CHARACTERS = /* @__PURE__ */ new Map([\n  [\"n\", \"\\n\"],\n  // New line\n  [\"t\", \"\t\"],\n  // Horizontal tab\n  [\"r\", \"\\r\"],\n  // Carriage return\n  [\"b\", \"\\b\"],\n  // Backspace\n  [\"f\", \"\\f\"],\n  // Form feed\n  [\"v\", \"\\v\"],\n  // Vertical tab\n  [\"'\", \"'\"],\n  // Single quote\n  ['\"', '\"'],\n  // Double quote\n  [\"\\\\\", \"\\\\\"]\n  // Backslash\n]);\nfunction preprocess(template, options = {}) {\n  if (template.endsWith(\"\\n\")) {\n    template = template.slice(0, -1);\n  }\n  template = template.replace(/{#.*?#}/gs, \"{##}\");\n  if (options.lstrip_blocks) {\n    template = template.replace(/^[ \\t]*({[#%])/gm, \"$1\");\n  }\n  if (options.trim_blocks) {\n    template = template.replace(/([#%]})\\n/g, \"$1\");\n  }\n  return template.replace(/{##}/g, \"\").replace(/-%}\\s*/g, \"%}\").replace(/\\s*{%-/g, \"{%\").replace(/-}}\\s*/g, \"}}\").replace(/\\s*{{-/g, \"{{\");\n}\nfunction tokenize(source, options = {}) {\n  const tokens = [];\n  const src = preprocess(source, options);\n  let cursorPosition = 0;\n  const consumeWhile = (predicate) => {\n    let str = \"\";\n    while (predicate(src[cursorPosition])) {\n      if (src[cursorPosition] === \"\\\\\") {\n        ++cursorPosition;\n        if (cursorPosition >= src.length)\n          throw new SyntaxError(\"Unexpected end of input\");\n        const escaped = src[cursorPosition++];\n        const unescaped = ESCAPE_CHARACTERS.get(escaped);\n        if (unescaped === void 0) {\n          throw new SyntaxError(`Unexpected escaped character: ${escaped}`);\n        }\n        str += unescaped;\n        continue;\n      }\n      str += src[cursorPosition++];\n      if (cursorPosition >= src.length)\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    return str;\n  };\n  main:\n    while (cursorPosition < src.length) {\n      const lastTokenType = tokens.at(-1)?.type;\n      if (lastTokenType === void 0 || lastTokenType === TOKEN_TYPES.CloseStatement || lastTokenType === TOKEN_TYPES.CloseExpression) {\n        let text = \"\";\n        while (cursorPosition < src.length && // Keep going until we hit the next Jinja statement or expression\n        !(src[cursorPosition] === \"{\" && (src[cursorPosition + 1] === \"%\" || src[cursorPosition + 1] === \"{\"))) {\n          text += src[cursorPosition++];\n        }\n        if (text.length > 0) {\n          tokens.push(new Token(text, TOKEN_TYPES.Text));\n          continue;\n        }\n      }\n      consumeWhile((char2) => /\\s/.test(char2));\n      const char = src[cursorPosition];\n      if (char === \"-\" || char === \"+\") {\n        const lastTokenType2 = tokens.at(-1)?.type;\n        if (lastTokenType2 === TOKEN_TYPES.Text || lastTokenType2 === void 0) {\n          throw new SyntaxError(`Unexpected character: ${char}`);\n        }\n        switch (lastTokenType2) {\n          case TOKEN_TYPES.Identifier:\n          case TOKEN_TYPES.NumericLiteral:\n          case TOKEN_TYPES.BooleanLiteral:\n          case TOKEN_TYPES.StringLiteral:\n          case TOKEN_TYPES.CloseParen:\n          case TOKEN_TYPES.CloseSquareBracket:\n            break;\n          default: {\n            ++cursorPosition;\n            const num = consumeWhile(isInteger);\n            tokens.push(\n              new Token(`${char}${num}`, num.length > 0 ? TOKEN_TYPES.NumericLiteral : TOKEN_TYPES.UnaryOperator)\n            );\n            continue;\n          }\n        }\n      }\n      for (const [char2, token] of ORDERED_MAPPING_TABLE) {\n        const slice2 = src.slice(cursorPosition, cursorPosition + char2.length);\n        if (slice2 === char2) {\n          tokens.push(new Token(char2, token));\n          cursorPosition += char2.length;\n          continue main;\n        }\n      }\n      if (char === \"'\" || char === '\"') {\n        ++cursorPosition;\n        const str = consumeWhile((c) => c !== char);\n        tokens.push(new Token(str, TOKEN_TYPES.StringLiteral));\n        ++cursorPosition;\n        continue;\n      }\n      if (isInteger(char)) {\n        const num = consumeWhile(isInteger);\n        tokens.push(new Token(num, TOKEN_TYPES.NumericLiteral));\n        continue;\n      }\n      if (isWord(char)) {\n        const word = consumeWhile(isWord);\n        const type = Object.hasOwn(KEYWORDS, word) ? KEYWORDS[word] : TOKEN_TYPES.Identifier;\n        if (type === TOKEN_TYPES.In && tokens.at(-1)?.type === TOKEN_TYPES.Not) {\n          tokens.pop();\n          tokens.push(new Token(\"not in\", TOKEN_TYPES.NotIn));\n        } else {\n          tokens.push(new Token(word, type));\n        }\n        continue;\n      }\n      throw new SyntaxError(`Unexpected character: ${char}`);\n    }\n  return tokens;\n}\n\n// src/ast.ts\nvar Statement = class {\n  type = \"Statement\";\n};\nvar Program = class extends Statement {\n  constructor(body) {\n    super();\n    this.body = body;\n  }\n  type = \"Program\";\n};\nvar If = class extends Statement {\n  constructor(test, body, alternate) {\n    super();\n    this.test = test;\n    this.body = body;\n    this.alternate = alternate;\n  }\n  type = \"If\";\n};\nvar For = class extends Statement {\n  constructor(loopvar, iterable, body) {\n    super();\n    this.loopvar = loopvar;\n    this.iterable = iterable;\n    this.body = body;\n  }\n  type = \"For\";\n};\nvar SetStatement = class extends Statement {\n  constructor(assignee, value) {\n    super();\n    this.assignee = assignee;\n    this.value = value;\n  }\n  type = \"Set\";\n};\nvar Expression = class extends Statement {\n  type = \"Expression\";\n};\nvar MemberExpression = class extends Expression {\n  constructor(object, property, computed) {\n    super();\n    this.object = object;\n    this.property = property;\n    this.computed = computed;\n  }\n  type = \"MemberExpression\";\n};\nvar CallExpression = class extends Expression {\n  constructor(callee, args) {\n    super();\n    this.callee = callee;\n    this.args = args;\n  }\n  type = \"CallExpression\";\n};\nvar Identifier = class extends Expression {\n  /**\n   * @param {string} value The name of the identifier\n   */\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Identifier\";\n};\nvar Literal = class extends Expression {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  type = \"Literal\";\n};\nvar NumericLiteral = class extends Literal {\n  type = \"NumericLiteral\";\n};\nvar StringLiteral = class extends Literal {\n  type = \"StringLiteral\";\n};\nvar BooleanLiteral = class extends Literal {\n  type = \"BooleanLiteral\";\n};\nvar ArrayLiteral = class extends Literal {\n  type = \"ArrayLiteral\";\n};\nvar TupleLiteral = class extends Literal {\n  type = \"TupleLiteral\";\n};\nvar ObjectLiteral = class extends Literal {\n  type = \"ObjectLiteral\";\n};\nvar BinaryExpression = class extends Expression {\n  constructor(operator, left, right) {\n    super();\n    this.operator = operator;\n    this.left = left;\n    this.right = right;\n  }\n  type = \"BinaryExpression\";\n};\nvar FilterExpression = class extends Expression {\n  constructor(operand, filter) {\n    super();\n    this.operand = operand;\n    this.filter = filter;\n  }\n  type = \"FilterExpression\";\n};\nvar TestExpression = class extends Expression {\n  constructor(operand, negate, test) {\n    super();\n    this.operand = operand;\n    this.negate = negate;\n    this.test = test;\n  }\n  type = \"TestExpression\";\n};\nvar UnaryExpression = class extends Expression {\n  constructor(operator, argument) {\n    super();\n    this.operator = operator;\n    this.argument = argument;\n  }\n  type = \"UnaryExpression\";\n};\nvar SliceExpression = class extends Expression {\n  constructor(start = void 0, stop = void 0, step = void 0) {\n    super();\n    this.start = start;\n    this.stop = stop;\n    this.step = step;\n  }\n  type = \"SliceExpression\";\n};\nvar KeywordArgumentExpression = class extends Expression {\n  constructor(key, value) {\n    super();\n    this.key = key;\n    this.value = value;\n  }\n  type = \"KeywordArgumentExpression\";\n};\n\n// src/parser.ts\nfunction parse(tokens) {\n  const program = new Program([]);\n  let current = 0;\n  function expect(type, error) {\n    const prev = tokens[current++];\n    if (!prev || prev.type !== type) {\n      throw new Error(`Parser Error: ${error}. ${prev.type} !== ${type}.`);\n    }\n    return prev;\n  }\n  function parseAny() {\n    switch (tokens[current].type) {\n      case TOKEN_TYPES.Text:\n        return parseText();\n      case TOKEN_TYPES.OpenStatement:\n        return parseJinjaStatement();\n      case TOKEN_TYPES.OpenExpression:\n        return parseJinjaExpression();\n      default:\n        throw new SyntaxError(`Unexpected token type: ${tokens[current].type}`);\n    }\n  }\n  function not(...types) {\n    return current + types.length <= tokens.length && types.some((type, i) => type !== tokens[current + i].type);\n  }\n  function is(...types) {\n    return current + types.length <= tokens.length && types.every((type, i) => type === tokens[current + i].type);\n  }\n  function parseText() {\n    return new StringLiteral(expect(TOKEN_TYPES.Text, \"Expected text token\").value);\n  }\n  function parseJinjaStatement() {\n    expect(TOKEN_TYPES.OpenStatement, \"Expected opening statement token\");\n    let result;\n    switch (tokens[current].type) {\n      case TOKEN_TYPES.Set:\n        ++current;\n        result = parseSetStatement();\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        break;\n      case TOKEN_TYPES.If:\n        ++current;\n        result = parseIfStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expect(TOKEN_TYPES.EndIf, \"Expected endif token\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      case TOKEN_TYPES.For:\n        ++current;\n        result = parseForStatement();\n        expect(TOKEN_TYPES.OpenStatement, \"Expected {% token\");\n        expect(TOKEN_TYPES.EndFor, \"Expected endfor token\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected %} token\");\n        break;\n      default:\n        throw new SyntaxError(`Unknown statement type: ${tokens[current].type}`);\n    }\n    return result;\n  }\n  function parseJinjaExpression() {\n    expect(TOKEN_TYPES.OpenExpression, \"Expected opening expression token\");\n    const result = parseExpression();\n    expect(TOKEN_TYPES.CloseExpression, \"Expected closing expression token\");\n    return result;\n  }\n  function parseSetStatement() {\n    const left = parseExpression();\n    if (is(TOKEN_TYPES.Equals)) {\n      ++current;\n      const value = parseSetStatement();\n      return new SetStatement(left, value);\n    }\n    return left;\n  }\n  function parseIfStatement() {\n    const test = parseExpression();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    const alternate = [];\n    while (!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && (tokens[current + 1]?.type === TOKEN_TYPES.ElseIf || tokens[current + 1]?.type === TOKEN_TYPES.Else || tokens[current + 1]?.type === TOKEN_TYPES.EndIf))) {\n      body.push(parseAny());\n    }\n    if (tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type !== TOKEN_TYPES.EndIf) {\n      ++current;\n      if (is(TOKEN_TYPES.ElseIf)) {\n        expect(TOKEN_TYPES.ElseIf, \"Expected elseif token\");\n        alternate.push(parseIfStatement());\n      } else {\n        expect(TOKEN_TYPES.Else, \"Expected else token\");\n        expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n        while (!(tokens[current]?.type === TOKEN_TYPES.OpenStatement && tokens[current + 1]?.type === TOKEN_TYPES.EndIf)) {\n          alternate.push(parseAny());\n        }\n      }\n    }\n    return new If(test, body, alternate);\n  }\n  function parseExpressionSequence(primary = false) {\n    const fn = primary ? parsePrimaryExpression : parseExpression;\n    const expressions = [fn()];\n    const isTuple = is(TOKEN_TYPES.Comma);\n    while (isTuple) {\n      ++current;\n      expressions.push(fn());\n      if (!is(TOKEN_TYPES.Comma)) {\n        break;\n      }\n    }\n    return isTuple ? new TupleLiteral(expressions) : expressions[0];\n  }\n  function parseForStatement() {\n    const loopVariable = parseExpressionSequence(true);\n    if (!(loopVariable instanceof Identifier || loopVariable instanceof TupleLiteral)) {\n      throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${loopVariable.type} instead`);\n    }\n    expect(TOKEN_TYPES.In, \"Expected `in` keyword following loop variable\");\n    const iterable = parseExpression();\n    expect(TOKEN_TYPES.CloseStatement, \"Expected closing statement token\");\n    const body = [];\n    while (not(TOKEN_TYPES.OpenStatement, TOKEN_TYPES.EndFor)) {\n      body.push(parseAny());\n    }\n    return new For(loopVariable, iterable, body);\n  }\n  function parseExpression() {\n    return parseTernaryExpression();\n  }\n  function parseTernaryExpression() {\n    const a = parseLogicalOrExpression();\n    if (is(TOKEN_TYPES.If)) {\n      ++current;\n      const predicate = parseLogicalOrExpression();\n      expect(TOKEN_TYPES.Else, \"Expected else token\");\n      const b = parseLogicalOrExpression();\n      return new If(predicate, [a], [b]);\n    }\n    return a;\n  }\n  function parseLogicalOrExpression() {\n    let left = parseLogicalAndExpression();\n    while (is(TOKEN_TYPES.Or)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseLogicalAndExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseLogicalAndExpression() {\n    let left = parseLogicalNegationExpression();\n    while (is(TOKEN_TYPES.And)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseLogicalNegationExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseLogicalNegationExpression() {\n    let right;\n    while (is(TOKEN_TYPES.Not)) {\n      const operator = tokens[current];\n      ++current;\n      const arg = parseLogicalNegationExpression();\n      right = new UnaryExpression(operator, arg);\n    }\n    return right ?? parseComparisonExpression();\n  }\n  function parseComparisonExpression() {\n    let left = parseAdditiveExpression();\n    while (is(TOKEN_TYPES.ComparisonBinaryOperator) || is(TOKEN_TYPES.In) || is(TOKEN_TYPES.NotIn)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseAdditiveExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseAdditiveExpression() {\n    let left = parseMultiplicativeExpression();\n    while (is(TOKEN_TYPES.AdditiveBinaryOperator)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseMultiplicativeExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseCallMemberExpression() {\n    const member = parseMemberExpression();\n    if (is(TOKEN_TYPES.OpenParen)) {\n      return parseCallExpression(member);\n    }\n    return member;\n  }\n  function parseCallExpression(callee) {\n    let callExpression = new CallExpression(callee, parseArgs());\n    if (is(TOKEN_TYPES.OpenParen)) {\n      callExpression = parseCallExpression(callExpression);\n    }\n    return callExpression;\n  }\n  function parseArgs() {\n    expect(TOKEN_TYPES.OpenParen, \"Expected opening parenthesis for arguments list\");\n    const args = parseArgumentsList();\n    expect(TOKEN_TYPES.CloseParen, \"Expected closing parenthesis for arguments list\");\n    return args;\n  }\n  function parseArgumentsList() {\n    const args = [];\n    while (!is(TOKEN_TYPES.CloseParen)) {\n      let argument = parseExpression();\n      if (is(TOKEN_TYPES.Equals)) {\n        ++current;\n        if (!(argument instanceof Identifier)) {\n          throw new SyntaxError(`Expected identifier for keyword argument`);\n        }\n        const value = parseExpression();\n        argument = new KeywordArgumentExpression(argument, value);\n      }\n      args.push(argument);\n      if (is(TOKEN_TYPES.Comma)) {\n        ++current;\n      }\n    }\n    return args;\n  }\n  function parseMemberExpressionArgumentsList() {\n    const slices = [];\n    let isSlice = false;\n    while (!is(TOKEN_TYPES.CloseSquareBracket)) {\n      if (is(TOKEN_TYPES.Colon)) {\n        slices.push(void 0);\n        ++current;\n        isSlice = true;\n      } else {\n        slices.push(parseExpression());\n        if (is(TOKEN_TYPES.Colon)) {\n          ++current;\n          isSlice = true;\n        }\n      }\n    }\n    if (slices.length === 0) {\n      throw new SyntaxError(`Expected at least one argument for member/slice expression`);\n    }\n    if (isSlice) {\n      if (slices.length > 3) {\n        throw new SyntaxError(`Expected 0-3 arguments for slice expression`);\n      }\n      return new SliceExpression(...slices);\n    }\n    return slices[0];\n  }\n  function parseMemberExpression() {\n    let object = parsePrimaryExpression();\n    while (is(TOKEN_TYPES.Dot) || is(TOKEN_TYPES.OpenSquareBracket)) {\n      const operator = tokens[current];\n      ++current;\n      let property;\n      const computed = operator.type !== TOKEN_TYPES.Dot;\n      if (computed) {\n        property = parseMemberExpressionArgumentsList();\n        expect(TOKEN_TYPES.CloseSquareBracket, \"Expected closing square bracket\");\n      } else {\n        property = parsePrimaryExpression();\n        if (property.type !== \"Identifier\") {\n          throw new SyntaxError(`Expected identifier following dot operator`);\n        }\n      }\n      object = new MemberExpression(object, property, computed);\n    }\n    return object;\n  }\n  function parseMultiplicativeExpression() {\n    let left = parseTestExpression();\n    while (is(TOKEN_TYPES.MultiplicativeBinaryOperator)) {\n      const operator = tokens[current];\n      ++current;\n      const right = parseTestExpression();\n      left = new BinaryExpression(operator, left, right);\n    }\n    return left;\n  }\n  function parseTestExpression() {\n    let operand = parseFilterExpression();\n    while (is(TOKEN_TYPES.Is)) {\n      ++current;\n      const negate = is(TOKEN_TYPES.Not);\n      if (negate) {\n        ++current;\n      }\n      let filter = parsePrimaryExpression();\n      if (filter instanceof BooleanLiteral) {\n        filter = new Identifier(filter.value.toString());\n      }\n      if (!(filter instanceof Identifier)) {\n        throw new SyntaxError(`Expected identifier for the test`);\n      }\n      operand = new TestExpression(operand, negate, filter);\n    }\n    return operand;\n  }\n  function parseFilterExpression() {\n    let operand = parseCallMemberExpression();\n    while (is(TOKEN_TYPES.Pipe)) {\n      ++current;\n      let filter = parsePrimaryExpression();\n      if (!(filter instanceof Identifier)) {\n        throw new SyntaxError(`Expected identifier for the filter`);\n      }\n      if (is(TOKEN_TYPES.OpenParen)) {\n        filter = parseCallExpression(filter);\n      }\n      operand = new FilterExpression(operand, filter);\n    }\n    return operand;\n  }\n  function parsePrimaryExpression() {\n    const token = tokens[current];\n    switch (token.type) {\n      case TOKEN_TYPES.NumericLiteral:\n        ++current;\n        return new NumericLiteral(Number(token.value));\n      case TOKEN_TYPES.StringLiteral:\n        ++current;\n        return new StringLiteral(token.value);\n      case TOKEN_TYPES.BooleanLiteral:\n        ++current;\n        return new BooleanLiteral(token.value === \"true\");\n      case TOKEN_TYPES.Identifier:\n        ++current;\n        return new Identifier(token.value);\n      case TOKEN_TYPES.OpenParen: {\n        ++current;\n        const expression = parseExpressionSequence();\n        if (tokens[current].type !== TOKEN_TYPES.CloseParen) {\n          throw new SyntaxError(`Expected closing parenthesis, got ${tokens[current].type} instead`);\n        }\n        ++current;\n        return expression;\n      }\n      case TOKEN_TYPES.OpenSquareBracket: {\n        ++current;\n        const values = [];\n        while (!is(TOKEN_TYPES.CloseSquareBracket)) {\n          values.push(parseExpression());\n          if (is(TOKEN_TYPES.Comma)) {\n            ++current;\n          }\n        }\n        ++current;\n        return new ArrayLiteral(values);\n      }\n      case TOKEN_TYPES.OpenCurlyBracket: {\n        ++current;\n        const values = /* @__PURE__ */ new Map();\n        while (!is(TOKEN_TYPES.CloseCurlyBracket)) {\n          const key = parseExpression();\n          expect(TOKEN_TYPES.Colon, \"Expected colon between key and value in object literal\");\n          const value = parseExpression();\n          values.set(key, value);\n          if (is(TOKEN_TYPES.Comma)) {\n            ++current;\n          }\n        }\n        ++current;\n        return new ObjectLiteral(values);\n      }\n      default:\n        throw new SyntaxError(`Unexpected token: ${token.type}`);\n    }\n  }\n  while (current < tokens.length) {\n    program.body.push(parseAny());\n  }\n  return program;\n}\n\n// src/utils.ts\nfunction range(start, stop, step = 1) {\n  if (stop === void 0) {\n    stop = start;\n    start = 0;\n  }\n  const result = [];\n  for (let i = start; i < stop; i += step) {\n    result.push(i);\n  }\n  return result;\n}\nfunction slice(array, start, stop, step = 1) {\n  const direction = Math.sign(step);\n  if (direction >= 0) {\n    start = (start ??= 0) < 0 ? Math.max(array.length + start, 0) : Math.min(start, array.length);\n    stop = (stop ??= array.length) < 0 ? Math.max(array.length + stop, 0) : Math.min(stop, array.length);\n  } else {\n    start = (start ??= array.length - 1) < 0 ? Math.max(array.length + start, -1) : Math.min(start, array.length - 1);\n    stop = (stop ??= -1) < -1 ? Math.max(array.length + stop, -1) : Math.min(stop, array.length - 1);\n  }\n  const result = [];\n  for (let i = start; direction * i < direction * stop; i += step) {\n    result.push(array[i]);\n  }\n  return result;\n}\nfunction titleCase(value) {\n  return value.replace(/\\b\\w/g, (c) => c.toUpperCase());\n}\n\n// src/runtime.ts\nvar RuntimeValue = class {\n  type = \"RuntimeValue\";\n  value;\n  /**\n   * A collection of built-in functions for this type.\n   */\n  builtins = /* @__PURE__ */ new Map();\n  /**\n   * Creates a new RuntimeValue.\n   */\n  constructor(value = void 0) {\n    this.value = value;\n  }\n  /**\n   * Determines truthiness or falsiness of the runtime value.\n   * This function should be overridden by subclasses if it has custom truthiness criteria.\n   * @returns {BooleanValue} BooleanValue(true) if the value is truthy, BooleanValue(false) otherwise.\n   */\n  __bool__() {\n    return new BooleanValue(!!this.value);\n  }\n};\nvar NumericValue = class extends RuntimeValue {\n  type = \"NumericValue\";\n};\nvar StringValue = class extends RuntimeValue {\n  type = \"StringValue\";\n  builtins = /* @__PURE__ */ new Map([\n    [\n      \"upper\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.toUpperCase());\n      })\n    ],\n    [\n      \"lower\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.toLowerCase());\n      })\n    ],\n    [\n      \"strip\",\n      new FunctionValue(() => {\n        return new StringValue(this.value.trim());\n      })\n    ],\n    [\n      \"title\",\n      new FunctionValue(() => {\n        return new StringValue(titleCase(this.value));\n      })\n    ],\n    [\"length\", new NumericValue(this.value.length)]\n  ]);\n};\nvar BooleanValue = class extends RuntimeValue {\n  type = \"BooleanValue\";\n};\nvar ObjectValue = class extends RuntimeValue {\n  type = \"ObjectValue\";\n  /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  {} && 5 -> 5\n   *  - Python:      {} and 5 -> {}\n   */\n  __bool__() {\n    return new BooleanValue(this.value.size > 0);\n  }\n  builtins = /* @__PURE__ */ new Map([\n    [\n      \"get\",\n      new FunctionValue(([key, defaultValue]) => {\n        if (!(key instanceof StringValue)) {\n          throw new Error(`Object key must be a string: got ${key.type}`);\n        }\n        return this.value.get(key.value) ?? defaultValue ?? new NullValue();\n      })\n    ],\n    [\n      \"items\",\n      new FunctionValue(() => {\n        return new ArrayValue(\n          Array.from(this.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value]))\n        );\n      })\n    ]\n  ]);\n};\nvar ArrayValue = class extends RuntimeValue {\n  type = \"ArrayValue\";\n  builtins = /* @__PURE__ */ new Map([[\"length\", new NumericValue(this.value.length)]]);\n  /**\n   * NOTE: necessary to override since all JavaScript arrays are considered truthy,\n   * while only non-empty Python arrays are consider truthy.\n   *\n   * e.g.,\n   *  - JavaScript:  [] && 5 -> 5\n   *  - Python:      [] and 5 -> []\n   */\n  __bool__() {\n    return new BooleanValue(this.value.length > 0);\n  }\n};\nvar TupleValue = class extends ArrayValue {\n  type = \"TupleValue\";\n};\nvar FunctionValue = class extends RuntimeValue {\n  type = \"FunctionValue\";\n};\nvar NullValue = class extends RuntimeValue {\n  type = \"NullValue\";\n};\nvar UndefinedValue = class extends RuntimeValue {\n  type = \"UndefinedValue\";\n};\nvar Environment = class {\n  constructor(parent) {\n    this.parent = parent;\n  }\n  /**\n   * The variables declared in this environment.\n   */\n  variables = /* @__PURE__ */ new Map([\n    [\n      \"namespace\",\n      new FunctionValue((args) => {\n        if (args.length === 0) {\n          return new ObjectValue(/* @__PURE__ */ new Map());\n        }\n        if (args.length !== 1 || !(args[0] instanceof ObjectValue)) {\n          throw new Error(\"`namespace` expects either zero arguments or a single object argument\");\n        }\n        return args[0];\n      })\n    ]\n  ]);\n  /**\n   * The tests available in this environment.\n   */\n  tests = /* @__PURE__ */ new Map([\n    [\"boolean\", (operand) => operand.type === \"BooleanValue\"],\n    [\"callable\", (operand) => operand instanceof FunctionValue],\n    [\n      \"odd\",\n      (operand) => {\n        if (operand.type !== \"NumericValue\") {\n          throw new Error(`Cannot apply test \"odd\" to type: ${operand.type}`);\n        }\n        return operand.value % 2 !== 0;\n      }\n    ],\n    [\n      \"even\",\n      (operand) => {\n        if (operand.type !== \"NumericValue\") {\n          throw new Error(`Cannot apply test \"even\" to type: ${operand.type}`);\n        }\n        return operand.value % 2 === 0;\n      }\n    ],\n    [\"false\", (operand) => operand.type === \"BooleanValue\" && !operand.value],\n    [\"true\", (operand) => operand.type === \"BooleanValue\" && operand.value],\n    [\"number\", (operand) => operand.type === \"NumericValue\"],\n    [\"integer\", (operand) => operand.type === \"NumericValue\" && Number.isInteger(operand.value)],\n    [\"iterable\", (operand) => operand instanceof ArrayValue || operand instanceof StringValue],\n    [\n      \"lower\",\n      (operand) => {\n        const str = operand.value;\n        return operand.type === \"StringValue\" && str === str.toLowerCase();\n      }\n    ],\n    [\n      \"upper\",\n      (operand) => {\n        const str = operand.value;\n        return operand.type === \"StringValue\" && str === str.toUpperCase();\n      }\n    ],\n    [\"none\", (operand) => operand.type === \"NullValue\"],\n    [\"defined\", (operand) => operand.type !== \"UndefinedValue\"],\n    [\"undefined\", (operand) => operand.type === \"UndefinedValue\"],\n    [\"equalto\", (a, b) => a.value === b.value]\n  ]);\n  /**\n   * Set the value of a variable in the current environment.\n   */\n  set(name, value) {\n    return this.declareVariable(name, convertToRuntimeValues(value));\n  }\n  declareVariable(name, value) {\n    if (this.variables.has(name)) {\n      throw new SyntaxError(`Variable already declared: ${name}`);\n    }\n    this.variables.set(name, value);\n    return value;\n  }\n  // private assignVariable(name: string, value: AnyRuntimeValue): AnyRuntimeValue {\n  // \tconst env = this.resolve(name);\n  // \tenv.variables.set(name, value);\n  // \treturn value;\n  // }\n  /**\n   * Set variable in the current scope.\n   * See https://jinja.palletsprojects.com/en/3.0.x/templates/#assignments for more information.\n   */\n  setVariable(name, value) {\n    this.variables.set(name, value);\n    return value;\n  }\n  /**\n   * Resolve the environment in which the variable is declared.\n   * @param {string} name The name of the variable.\n   * @returns {Environment} The environment in which the variable is declared.\n   */\n  resolve(name) {\n    if (this.variables.has(name)) {\n      return this;\n    }\n    if (this.parent) {\n      return this.parent.resolve(name);\n    }\n    throw new Error(`Unknown variable: ${name}`);\n  }\n  lookupVariable(name) {\n    try {\n      return this.resolve(name).variables.get(name) ?? new UndefinedValue();\n    } catch {\n      return new UndefinedValue();\n    }\n  }\n};\nvar Interpreter = class {\n  global;\n  constructor(env) {\n    this.global = env ?? new Environment();\n  }\n  /**\n   * Run the program.\n   */\n  run(program) {\n    return this.evaluate(program, this.global);\n  }\n  /**\n   * Evaluates expressions following the binary operation type.\n   */\n  evaluateBinaryExpression(node, environment) {\n    const left = this.evaluate(node.left, environment);\n    switch (node.operator.value) {\n      case \"and\":\n        return left.__bool__().value ? this.evaluate(node.right, environment) : left;\n      case \"or\":\n        return left.__bool__().value ? left : this.evaluate(node.right, environment);\n    }\n    const right = this.evaluate(node.right, environment);\n    switch (node.operator.value) {\n      case \"==\":\n        return new BooleanValue(left.value == right.value);\n      case \"!=\":\n        return new BooleanValue(left.value != right.value);\n    }\n    if (left instanceof UndefinedValue || right instanceof UndefinedValue) {\n      throw new Error(\"Cannot perform operation on undefined values\");\n    } else if (left instanceof NullValue || right instanceof NullValue) {\n      throw new Error(\"Cannot perform operation on null values\");\n    } else if (left instanceof NumericValue && right instanceof NumericValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new NumericValue(left.value + right.value);\n        case \"-\":\n          return new NumericValue(left.value - right.value);\n        case \"*\":\n          return new NumericValue(left.value * right.value);\n        case \"/\":\n          return new NumericValue(left.value / right.value);\n        case \"%\":\n          return new NumericValue(left.value % right.value);\n        case \"<\":\n          return new BooleanValue(left.value < right.value);\n        case \">\":\n          return new BooleanValue(left.value > right.value);\n        case \">=\":\n          return new BooleanValue(left.value >= right.value);\n        case \"<=\":\n          return new BooleanValue(left.value <= right.value);\n      }\n    } else if (left instanceof ArrayValue && right instanceof ArrayValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new ArrayValue(left.value.concat(right.value));\n      }\n    } else if (right instanceof ArrayValue) {\n      const member = right.value.find((x) => x.value === left.value) !== void 0;\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(member);\n        case \"not in\":\n          return new BooleanValue(!member);\n      }\n    }\n    if (left instanceof StringValue || right instanceof StringValue) {\n      switch (node.operator.value) {\n        case \"+\":\n          return new StringValue(left.value.toString() + right.value.toString());\n      }\n    }\n    if (left instanceof StringValue && right instanceof StringValue) {\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(right.value.includes(left.value));\n        case \"not in\":\n          return new BooleanValue(!right.value.includes(left.value));\n      }\n    }\n    if (left instanceof StringValue && right instanceof ObjectValue) {\n      switch (node.operator.value) {\n        case \"in\":\n          return new BooleanValue(right.value.has(left.value));\n        case \"not in\":\n          return new BooleanValue(!right.value.has(left.value));\n      }\n    }\n    throw new SyntaxError(`Unknown operator \"${node.operator.value}\" between ${left.type} and ${right.type}`);\n  }\n  /**\n   * Evaluates expressions following the filter operation type.\n   */\n  evaluateFilterExpression(node, environment) {\n    const operand = this.evaluate(node.operand, environment);\n    if (node.filter.type === \"Identifier\") {\n      const filter = node.filter;\n      if (operand instanceof ArrayValue) {\n        switch (filter.value) {\n          case \"list\":\n            return operand;\n          case \"first\":\n            return operand.value[0];\n          case \"last\":\n            return operand.value[operand.value.length - 1];\n          case \"length\":\n            return new NumericValue(operand.value.length);\n          case \"reverse\":\n            return new ArrayValue(operand.value.reverse());\n          case \"sort\":\n            return new ArrayValue(\n              operand.value.sort((a, b) => {\n                if (a.type !== b.type) {\n                  throw new Error(`Cannot compare different types: ${a.type} and ${b.type}`);\n                }\n                switch (a.type) {\n                  case \"NumericValue\":\n                    return a.value - b.value;\n                  case \"StringValue\":\n                    return a.value.localeCompare(b.value);\n                  default:\n                    throw new Error(`Cannot compare type: ${a.type}`);\n                }\n              })\n            );\n          default:\n            throw new Error(`Unknown ArrayValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof StringValue) {\n        switch (filter.value) {\n          case \"length\":\n            return new NumericValue(operand.value.length);\n          case \"upper\":\n            return new StringValue(operand.value.toUpperCase());\n          case \"lower\":\n            return new StringValue(operand.value.toLowerCase());\n          case \"title\":\n            return new StringValue(titleCase(operand.value));\n          case \"capitalize\":\n            return new StringValue(operand.value.charAt(0).toUpperCase() + operand.value.slice(1));\n          case \"trim\":\n            return new StringValue(operand.value.trim());\n          default:\n            throw new Error(`Unknown StringValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof NumericValue) {\n        switch (filter.value) {\n          case \"abs\":\n            return new NumericValue(Math.abs(operand.value));\n          default:\n            throw new Error(`Unknown NumericValue filter: ${filter.value}`);\n        }\n      } else if (operand instanceof ObjectValue) {\n        switch (filter.value) {\n          case \"items\":\n            return new ArrayValue(\n              Array.from(operand.value.entries()).map(([key, value]) => new ArrayValue([new StringValue(key), value]))\n            );\n          case \"length\":\n            return new NumericValue(operand.value.size);\n          default:\n            throw new Error(`Unknown ObjectValue filter: ${filter.value}`);\n        }\n      }\n      throw new Error(`Cannot apply filter \"${filter.value}\" to type: ${operand.type}`);\n    } else if (node.filter.type === \"CallExpression\") {\n      const filter = node.filter;\n      if (filter.callee.type !== \"Identifier\") {\n        throw new Error(`Unknown filter: ${filter.callee.type}`);\n      }\n      const filterName = filter.callee.value;\n      if (operand instanceof ArrayValue) {\n        switch (filterName) {\n          case \"selectattr\": {\n            if (operand.value.some((x) => !(x instanceof ObjectValue))) {\n              throw new Error(\"`selectattr` can only be applied to array of objects\");\n            }\n            if (filter.args.some((x) => x.type !== \"StringLiteral\")) {\n              throw new Error(\"arguments of `selectattr` must be strings\");\n            }\n            const [attr, testName, value] = filter.args.map((x) => this.evaluate(x, environment));\n            let testFunction;\n            if (testName) {\n              const test = environment.tests.get(testName.value);\n              if (!test) {\n                throw new Error(`Unknown test: ${testName.value}`);\n              }\n              testFunction = test;\n            } else {\n              testFunction = (...x) => x[0].__bool__().value;\n            }\n            const filtered = operand.value.filter((item) => {\n              const a = item.value.get(attr.value);\n              if (a) {\n                return testFunction(a, value);\n              }\n              return false;\n            });\n            return new ArrayValue(filtered);\n          }\n        }\n        throw new Error(`Unknown ArrayValue filter: ${filterName}`);\n      } else {\n        throw new Error(`Cannot apply filter \"${filterName}\" to type: ${operand.type}`);\n      }\n    }\n    throw new Error(`Unknown filter: ${node.filter.type}`);\n  }\n  /**\n   * Evaluates expressions following the test operation type.\n   */\n  evaluateTestExpression(node, environment) {\n    const operand = this.evaluate(node.operand, environment);\n    const test = environment.tests.get(node.test.value);\n    if (!test) {\n      throw new Error(`Unknown test: ${node.test.value}`);\n    }\n    const result = test(operand);\n    return new BooleanValue(node.negate ? !result : result);\n  }\n  /**\n   * Evaluates expressions following the unary operation type.\n   */\n  evaluateUnaryExpression(node, environment) {\n    const argument = this.evaluate(node.argument, environment);\n    switch (node.operator.value) {\n      case \"not\":\n        return new BooleanValue(!argument.value);\n      default:\n        throw new SyntaxError(`Unknown operator: ${node.operator.value}`);\n    }\n  }\n  evalProgram(program, environment) {\n    return this.evaluateBlock(program.body, environment);\n  }\n  evaluateBlock(statements, environment) {\n    let result = \"\";\n    for (const statement of statements) {\n      const lastEvaluated = this.evaluate(statement, environment);\n      if (lastEvaluated.type !== \"NullValue\" && lastEvaluated.type !== \"UndefinedValue\") {\n        result += lastEvaluated.value;\n      }\n    }\n    return new StringValue(result);\n  }\n  evaluateIdentifier(node, environment) {\n    return environment.lookupVariable(node.value);\n  }\n  evaluateCallExpression(expr, environment) {\n    const args = [];\n    const kwargs = /* @__PURE__ */ new Map();\n    for (const argument of expr.args) {\n      if (argument.type === \"KeywordArgumentExpression\") {\n        const kwarg = argument;\n        kwargs.set(kwarg.key.value, this.evaluate(kwarg.value, environment));\n      } else {\n        args.push(this.evaluate(argument, environment));\n      }\n    }\n    if (kwargs.size > 0) {\n      args.push(new ObjectValue(kwargs));\n    }\n    const fn = this.evaluate(expr.callee, environment);\n    if (fn.type !== \"FunctionValue\") {\n      throw new Error(`Cannot call something that is not a function: got ${fn.type}`);\n    }\n    return fn.value(args, environment);\n  }\n  evaluateSliceExpression(object, expr, environment) {\n    if (!(object instanceof ArrayValue || object instanceof StringValue)) {\n      throw new Error(\"Slice object must be an array or string\");\n    }\n    const start = this.evaluate(expr.start, environment);\n    const stop = this.evaluate(expr.stop, environment);\n    const step = this.evaluate(expr.step, environment);\n    if (!(start instanceof NumericValue || start instanceof UndefinedValue)) {\n      throw new Error(\"Slice start must be numeric or undefined\");\n    }\n    if (!(stop instanceof NumericValue || stop instanceof UndefinedValue)) {\n      throw new Error(\"Slice stop must be numeric or undefined\");\n    }\n    if (!(step instanceof NumericValue || step instanceof UndefinedValue)) {\n      throw new Error(\"Slice step must be numeric or undefined\");\n    }\n    if (object instanceof ArrayValue) {\n      return new ArrayValue(slice(object.value, start.value, stop.value, step.value));\n    } else {\n      return new StringValue(slice(Array.from(object.value), start.value, stop.value, step.value).join(\"\"));\n    }\n  }\n  evaluateMemberExpression(expr, environment) {\n    const object = this.evaluate(expr.object, environment);\n    let property;\n    if (expr.computed) {\n      if (expr.property.type === \"SliceExpression\") {\n        return this.evaluateSliceExpression(object, expr.property, environment);\n      } else {\n        property = this.evaluate(expr.property, environment);\n      }\n    } else {\n      property = new StringValue(expr.property.value);\n    }\n    let value;\n    if (object instanceof ObjectValue) {\n      if (!(property instanceof StringValue)) {\n        throw new Error(`Cannot access property with non-string: got ${property.type}`);\n      }\n      value = object.value.get(property.value) ?? object.builtins.get(property.value);\n    } else if (object instanceof ArrayValue || object instanceof StringValue) {\n      if (property instanceof NumericValue) {\n        value = object.value.at(property.value);\n        if (object instanceof StringValue) {\n          value = new StringValue(object.value.at(property.value));\n        }\n      } else if (property instanceof StringValue) {\n        value = object.builtins.get(property.value);\n      } else {\n        throw new Error(`Cannot access property with non-string/non-number: got ${property.type}`);\n      }\n    } else {\n      if (!(property instanceof StringValue)) {\n        throw new Error(`Cannot access property with non-string: got ${property.type}`);\n      }\n      value = object.builtins.get(property.value);\n    }\n    return value instanceof RuntimeValue ? value : new UndefinedValue();\n  }\n  evaluateSet(node, environment) {\n    const rhs = this.evaluate(node.value, environment);\n    if (node.assignee.type === \"Identifier\") {\n      const variableName = node.assignee.value;\n      environment.setVariable(variableName, rhs);\n    } else if (node.assignee.type === \"MemberExpression\") {\n      const member = node.assignee;\n      const object = this.evaluate(member.object, environment);\n      if (!(object instanceof ObjectValue)) {\n        throw new Error(\"Cannot assign to member of non-object\");\n      }\n      if (member.property.type !== \"Identifier\") {\n        throw new Error(\"Cannot assign to member with non-identifier property\");\n      }\n      object.value.set(member.property.value, rhs);\n    } else {\n      throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(node.assignee)}`);\n    }\n    return new NullValue();\n  }\n  evaluateIf(node, environment) {\n    const test = this.evaluate(node.test, environment);\n    return this.evaluateBlock(test.__bool__().value ? node.body : node.alternate, environment);\n  }\n  evaluateFor(node, environment) {\n    const scope = new Environment(environment);\n    const iterable = this.evaluate(node.iterable, scope);\n    if (!(iterable instanceof ArrayValue)) {\n      throw new Error(`Expected iterable type in for loop: got ${iterable.type}`);\n    }\n    let result = \"\";\n    for (let i = 0; i < iterable.value.length; ++i) {\n      const loop = /* @__PURE__ */ new Map([\n        [\"index\", new NumericValue(i + 1)],\n        [\"index0\", new NumericValue(i)],\n        [\"revindex\", new NumericValue(iterable.value.length - i)],\n        [\"revindex0\", new NumericValue(iterable.value.length - i - 1)],\n        [\"first\", new BooleanValue(i === 0)],\n        [\"last\", new BooleanValue(i === iterable.value.length - 1)],\n        [\"length\", new NumericValue(iterable.value.length)],\n        [\"previtem\", i > 0 ? iterable.value[i - 1] : new UndefinedValue()],\n        [\"nextitem\", i < iterable.value.length - 1 ? iterable.value[i + 1] : new UndefinedValue()]\n      ]);\n      scope.setVariable(\"loop\", new ObjectValue(loop));\n      const current = iterable.value[i];\n      if (node.loopvar.type === \"Identifier\") {\n        scope.setVariable(node.loopvar.value, current);\n      } else if (node.loopvar.type === \"TupleLiteral\") {\n        const loopvar = node.loopvar;\n        if (current.type !== \"ArrayValue\") {\n          throw new Error(`Cannot unpack non-iterable type: ${current.type}`);\n        }\n        const c = current;\n        if (loopvar.value.length !== c.value.length) {\n          throw new Error(`Too ${loopvar.value.length > c.value.length ? \"few\" : \"many\"} items to unpack`);\n        }\n        for (let j = 0; j < loopvar.value.length; ++j) {\n          if (loopvar.value[j].type !== \"Identifier\") {\n            throw new Error(`Cannot unpack non-identifier type: ${loopvar.value[j].type}`);\n          }\n          scope.setVariable(loopvar.value[j].value, c.value[j]);\n        }\n      }\n      const evaluated = this.evaluateBlock(node.body, scope);\n      result += evaluated.value;\n    }\n    return new StringValue(result);\n  }\n  evaluate(statement, environment) {\n    if (statement === void 0)\n      return new UndefinedValue();\n    switch (statement.type) {\n      case \"Program\":\n        return this.evalProgram(statement, environment);\n      case \"Set\":\n        return this.evaluateSet(statement, environment);\n      case \"If\":\n        return this.evaluateIf(statement, environment);\n      case \"For\":\n        return this.evaluateFor(statement, environment);\n      case \"NumericLiteral\":\n        return new NumericValue(Number(statement.value));\n      case \"StringLiteral\":\n        return new StringValue(statement.value);\n      case \"BooleanLiteral\":\n        return new BooleanValue(statement.value);\n      case \"ArrayLiteral\":\n        return new ArrayValue(statement.value.map((x) => this.evaluate(x, environment)));\n      case \"TupleLiteral\":\n        return new TupleValue(statement.value.map((x) => this.evaluate(x, environment)));\n      case \"ObjectLiteral\": {\n        const mapping = /* @__PURE__ */ new Map();\n        for (const [key, value] of statement.value) {\n          const evaluatedKey = this.evaluate(key, environment);\n          if (!(evaluatedKey instanceof StringValue)) {\n            throw new Error(`Object keys must be strings: got ${evaluatedKey.type}`);\n          }\n          mapping.set(evaluatedKey.value, this.evaluate(value, environment));\n        }\n        return new ObjectValue(mapping);\n      }\n      case \"Identifier\":\n        return this.evaluateIdentifier(statement, environment);\n      case \"CallExpression\":\n        return this.evaluateCallExpression(statement, environment);\n      case \"MemberExpression\":\n        return this.evaluateMemberExpression(statement, environment);\n      case \"UnaryExpression\":\n        return this.evaluateUnaryExpression(statement, environment);\n      case \"BinaryExpression\":\n        return this.evaluateBinaryExpression(statement, environment);\n      case \"FilterExpression\":\n        return this.evaluateFilterExpression(statement, environment);\n      case \"TestExpression\":\n        return this.evaluateTestExpression(statement, environment);\n      default:\n        throw new SyntaxError(`Unknown node type: ${statement.type}`);\n    }\n  }\n};\nfunction convertToRuntimeValues(input) {\n  switch (typeof input) {\n    case \"number\":\n      return new NumericValue(input);\n    case \"string\":\n      return new StringValue(input);\n    case \"boolean\":\n      return new BooleanValue(input);\n    case \"object\":\n      if (input === null) {\n        return new NullValue();\n      } else if (Array.isArray(input)) {\n        return new ArrayValue(input.map(convertToRuntimeValues));\n      } else {\n        return new ObjectValue(\n          new Map(Object.entries(input).map(([key, value]) => [key, convertToRuntimeValues(value)]))\n        );\n      }\n    case \"function\":\n      return new FunctionValue((args, _scope) => {\n        const result = input(...args.map((x) => x.value)) ?? null;\n        return convertToRuntimeValues(result);\n      });\n    default:\n      throw new Error(`Cannot convert to runtime value: ${input}`);\n  }\n}\n\n// src/index.ts\nvar Template = class {\n  parsed;\n  /**\n   * @param {string} template The template string\n   */\n  constructor(template) {\n    const tokens = tokenize(template, {\n      lstrip_blocks: true,\n      trim_blocks: true\n    });\n    this.parsed = parse(tokens);\n  }\n  render(items) {\n    const env = new Environment();\n    env.set(\"false\", false);\n    env.set(\"true\", true);\n    env.set(\"raise_exception\", (args) => {\n      throw new Error(args);\n    });\n    env.set(\"range\", range);\n    for (const [key, value] of Object.entries(items)) {\n      env.set(key, value);\n    }\n    const interpreter = new Interpreter(env);\n    const result = interpreter.run(this.parsed);\n    return result.value;\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGh1Z2dpbmdmYWNlL2ppbmphL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ04sTUFBTTtBQUNOLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTSxPQUFPLEdBQUc7QUFDaEQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLDRCQUE0QixHQUFHLG9CQUFvQixVQUFVLGdCQUFnQixRQUFRLGdCQUFnQixVQUFVLGlCQUFpQixRQUFRO0FBQ3hJO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLFFBQVE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsdUVBQXVFO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUssRUFBRSxJQUFJO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNLElBQUksV0FBVyxNQUFNLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHFCQUFxQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLG1CQUFtQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsc0JBQXNCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsV0FBVztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFNBQVM7QUFDdkU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxhQUFhO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxLQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0IsWUFBWSxXQUFXLE1BQU0sV0FBVztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUSxNQUFNLE9BQU87QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsT0FBTztBQUNuRTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsMERBQTBELGFBQWE7QUFDdkU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGFBQWE7QUFDekU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYSxhQUFhLGFBQWE7QUFDckYsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQ0FBMkMsbUJBQW1CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxXQUFXO0FBQ2pFLFFBQVE7QUFDUixnREFBZ0QsV0FBVyxhQUFhLGFBQWE7QUFDckY7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsb0JBQW9CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsUUFBUTtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixrRkFBa0YsY0FBYztBQUNoRztBQUNBLE1BQU07QUFDTjtBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtRUFBbUUsOEJBQThCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsY0FBYztBQUMvRTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDhEQUE4RCxhQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3REFBd0Q7QUFDekY7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0Esa0VBQWtFLHNCQUFzQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwwREFBMEQsTUFBTTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPRSIsInNvdXJjZXMiOlsid2VicGFjazovL29iamVjdC1kZXRlY3Rpb24vLi9ub2RlX21vZHVsZXMvQGh1Z2dpbmdmYWNlL2ppbmphL2Rpc3QvaW5kZXguanM/MmFkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvbGV4ZXIudHNcbnZhciBUT0tFTl9UWVBFUyA9IE9iamVjdC5mcmVlemUoe1xuICBUZXh0OiBcIlRleHRcIixcbiAgLy8gVGhlIHRleHQgYmV0d2VlbiBKaW5qYSBzdGF0ZW1lbnRzIG9yIGV4cHJlc3Npb25zXG4gIE51bWVyaWNMaXRlcmFsOiBcIk51bWVyaWNMaXRlcmFsXCIsXG4gIC8vIGUuZy4sIDEyM1xuICBCb29sZWFuTGl0ZXJhbDogXCJCb29sZWFuTGl0ZXJhbFwiLFxuICAvLyB0cnVlIG9yIGZhbHNlXG4gIFN0cmluZ0xpdGVyYWw6IFwiU3RyaW5nTGl0ZXJhbFwiLFxuICAvLyAnc3RyaW5nJ1xuICBJZGVudGlmaWVyOiBcIklkZW50aWZpZXJcIixcbiAgLy8gVmFyaWFibGVzLCBmdW5jdGlvbnMsIGV0Yy5cbiAgRXF1YWxzOiBcIkVxdWFsc1wiLFxuICAvLyA9XG4gIE9wZW5QYXJlbjogXCJPcGVuUGFyZW5cIixcbiAgLy8gKFxuICBDbG9zZVBhcmVuOiBcIkNsb3NlUGFyZW5cIixcbiAgLy8gKVxuICBPcGVuU3RhdGVtZW50OiBcIk9wZW5TdGF0ZW1lbnRcIixcbiAgLy8geyVcbiAgQ2xvc2VTdGF0ZW1lbnQ6IFwiQ2xvc2VTdGF0ZW1lbnRcIixcbiAgLy8gJX1cbiAgT3BlbkV4cHJlc3Npb246IFwiT3BlbkV4cHJlc3Npb25cIixcbiAgLy8ge3tcbiAgQ2xvc2VFeHByZXNzaW9uOiBcIkNsb3NlRXhwcmVzc2lvblwiLFxuICAvLyB9fVxuICBPcGVuU3F1YXJlQnJhY2tldDogXCJPcGVuU3F1YXJlQnJhY2tldFwiLFxuICAvLyBbXG4gIENsb3NlU3F1YXJlQnJhY2tldDogXCJDbG9zZVNxdWFyZUJyYWNrZXRcIixcbiAgLy8gXVxuICBPcGVuQ3VybHlCcmFja2V0OiBcIk9wZW5DdXJseUJyYWNrZXRcIixcbiAgLy8ge1xuICBDbG9zZUN1cmx5QnJhY2tldDogXCJDbG9zZUN1cmx5QnJhY2tldFwiLFxuICAvLyB9XG4gIENvbW1hOiBcIkNvbW1hXCIsXG4gIC8vICxcbiAgRG90OiBcIkRvdFwiLFxuICAvLyAuXG4gIENvbG9uOiBcIkNvbG9uXCIsXG4gIC8vIDpcbiAgUGlwZTogXCJQaXBlXCIsXG4gIC8vIHxcbiAgQ2FsbE9wZXJhdG9yOiBcIkNhbGxPcGVyYXRvclwiLFxuICAvLyAoKVxuICBBZGRpdGl2ZUJpbmFyeU9wZXJhdG9yOiBcIkFkZGl0aXZlQmluYXJ5T3BlcmF0b3JcIixcbiAgLy8gKyAtXG4gIE11bHRpcGxpY2F0aXZlQmluYXJ5T3BlcmF0b3I6IFwiTXVsdGlwbGljYXRpdmVCaW5hcnlPcGVyYXRvclwiLFxuICAvLyAqIC8gJVxuICBDb21wYXJpc29uQmluYXJ5T3BlcmF0b3I6IFwiQ29tcGFyaXNvbkJpbmFyeU9wZXJhdG9yXCIsXG4gIC8vIDwgPiA8PSA+PSA9PSAhPVxuICBVbmFyeU9wZXJhdG9yOiBcIlVuYXJ5T3BlcmF0b3JcIixcbiAgLy8gISAtICtcbiAgLy8gS2V5d29yZHNcbiAgU2V0OiBcIlNldFwiLFxuICBJZjogXCJJZlwiLFxuICBGb3I6IFwiRm9yXCIsXG4gIEluOiBcIkluXCIsXG4gIElzOiBcIklzXCIsXG4gIE5vdEluOiBcIk5vdEluXCIsXG4gIEVsc2U6IFwiRWxzZVwiLFxuICBFbmRJZjogXCJFbmRJZlwiLFxuICBFbHNlSWY6IFwiRWxzZUlmXCIsXG4gIEVuZEZvcjogXCJFbmRGb3JcIixcbiAgQW5kOiBcIkFuZFwiLFxuICBPcjogXCJPclwiLFxuICBOb3Q6IFwiVW5hcnlPcGVyYXRvclwiXG59KTtcbnZhciBLRVlXT1JEUyA9IE9iamVjdC5mcmVlemUoe1xuICBzZXQ6IFRPS0VOX1RZUEVTLlNldCxcbiAgZm9yOiBUT0tFTl9UWVBFUy5Gb3IsXG4gIGluOiBUT0tFTl9UWVBFUy5JbixcbiAgaXM6IFRPS0VOX1RZUEVTLklzLFxuICBpZjogVE9LRU5fVFlQRVMuSWYsXG4gIGVsc2U6IFRPS0VOX1RZUEVTLkVsc2UsXG4gIGVuZGlmOiBUT0tFTl9UWVBFUy5FbmRJZixcbiAgZWxpZjogVE9LRU5fVFlQRVMuRWxzZUlmLFxuICBlbmRmb3I6IFRPS0VOX1RZUEVTLkVuZEZvcixcbiAgYW5kOiBUT0tFTl9UWVBFUy5BbmQsXG4gIG9yOiBUT0tFTl9UWVBFUy5PcixcbiAgbm90OiBUT0tFTl9UWVBFUy5Ob3QsXG4gIFwibm90IGluXCI6IFRPS0VOX1RZUEVTLk5vdEluLFxuICAvLyBMaXRlcmFsc1xuICB0cnVlOiBUT0tFTl9UWVBFUy5Cb29sZWFuTGl0ZXJhbCxcbiAgZmFsc2U6IFRPS0VOX1RZUEVTLkJvb2xlYW5MaXRlcmFsXG59KTtcbnZhciBUb2tlbiA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgVG9rZW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgcmF3IHZhbHVlIGFzIHNlZW4gaW5zaWRlIHRoZSBzb3VyY2UgY29kZS5cbiAgICogQHBhcmFtIHtUb2tlblR5cGV9IHR5cGUgVGhlIHR5cGUgb2YgdG9rZW4uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdHlwZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG59O1xuZnVuY3Rpb24gaXNXb3JkKGNoYXIpIHtcbiAgcmV0dXJuIC9cXHcvLnRlc3QoY2hhcik7XG59XG5mdW5jdGlvbiBpc0ludGVnZXIoY2hhcikge1xuICByZXR1cm4gL1swLTldLy50ZXN0KGNoYXIpO1xufVxudmFyIE9SREVSRURfTUFQUElOR19UQUJMRSA9IFtcbiAgLy8gQ29udHJvbCBzZXF1ZW5jZXNcbiAgW1wieyVcIiwgVE9LRU5fVFlQRVMuT3BlblN0YXRlbWVudF0sXG4gIFtcIiV9XCIsIFRPS0VOX1RZUEVTLkNsb3NlU3RhdGVtZW50XSxcbiAgW1wie3tcIiwgVE9LRU5fVFlQRVMuT3BlbkV4cHJlc3Npb25dLFxuICBbXCJ9fVwiLCBUT0tFTl9UWVBFUy5DbG9zZUV4cHJlc3Npb25dLFxuICAvLyBTaW5nbGUgY2hhcmFjdGVyIHRva2Vuc1xuICBbXCIoXCIsIFRPS0VOX1RZUEVTLk9wZW5QYXJlbl0sXG4gIFtcIilcIiwgVE9LRU5fVFlQRVMuQ2xvc2VQYXJlbl0sXG4gIFtcIntcIiwgVE9LRU5fVFlQRVMuT3BlbkN1cmx5QnJhY2tldF0sXG4gIFtcIn1cIiwgVE9LRU5fVFlQRVMuQ2xvc2VDdXJseUJyYWNrZXRdLFxuICBbXCJbXCIsIFRPS0VOX1RZUEVTLk9wZW5TcXVhcmVCcmFja2V0XSxcbiAgW1wiXVwiLCBUT0tFTl9UWVBFUy5DbG9zZVNxdWFyZUJyYWNrZXRdLFxuICBbXCIsXCIsIFRPS0VOX1RZUEVTLkNvbW1hXSxcbiAgW1wiLlwiLCBUT0tFTl9UWVBFUy5Eb3RdLFxuICBbXCI6XCIsIFRPS0VOX1RZUEVTLkNvbG9uXSxcbiAgW1wifFwiLCBUT0tFTl9UWVBFUy5QaXBlXSxcbiAgLy8gQ29tcGFyaXNvbiBvcGVyYXRvcnNcbiAgW1wiPD1cIiwgVE9LRU5fVFlQRVMuQ29tcGFyaXNvbkJpbmFyeU9wZXJhdG9yXSxcbiAgW1wiPj1cIiwgVE9LRU5fVFlQRVMuQ29tcGFyaXNvbkJpbmFyeU9wZXJhdG9yXSxcbiAgW1wiPT1cIiwgVE9LRU5fVFlQRVMuQ29tcGFyaXNvbkJpbmFyeU9wZXJhdG9yXSxcbiAgW1wiIT1cIiwgVE9LRU5fVFlQRVMuQ29tcGFyaXNvbkJpbmFyeU9wZXJhdG9yXSxcbiAgW1wiPFwiLCBUT0tFTl9UWVBFUy5Db21wYXJpc29uQmluYXJ5T3BlcmF0b3JdLFxuICBbXCI+XCIsIFRPS0VOX1RZUEVTLkNvbXBhcmlzb25CaW5hcnlPcGVyYXRvcl0sXG4gIC8vIEFyaXRobWV0aWMgb3BlcmF0b3JzXG4gIFtcIitcIiwgVE9LRU5fVFlQRVMuQWRkaXRpdmVCaW5hcnlPcGVyYXRvcl0sXG4gIFtcIi1cIiwgVE9LRU5fVFlQRVMuQWRkaXRpdmVCaW5hcnlPcGVyYXRvcl0sXG4gIFtcIipcIiwgVE9LRU5fVFlQRVMuTXVsdGlwbGljYXRpdmVCaW5hcnlPcGVyYXRvcl0sXG4gIFtcIi9cIiwgVE9LRU5fVFlQRVMuTXVsdGlwbGljYXRpdmVCaW5hcnlPcGVyYXRvcl0sXG4gIFtcIiVcIiwgVE9LRU5fVFlQRVMuTXVsdGlwbGljYXRpdmVCaW5hcnlPcGVyYXRvcl0sXG4gIC8vIEFzc2lnbm1lbnQgb3BlcmF0b3JcbiAgW1wiPVwiLCBUT0tFTl9UWVBFUy5FcXVhbHNdXG5dO1xudmFyIEVTQ0FQRV9DSEFSQUNURVJTID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXCJuXCIsIFwiXFxuXCJdLFxuICAvLyBOZXcgbGluZVxuICBbXCJ0XCIsIFwiXHRcIl0sXG4gIC8vIEhvcml6b250YWwgdGFiXG4gIFtcInJcIiwgXCJcXHJcIl0sXG4gIC8vIENhcnJpYWdlIHJldHVyblxuICBbXCJiXCIsIFwiXFxiXCJdLFxuICAvLyBCYWNrc3BhY2VcbiAgW1wiZlwiLCBcIlxcZlwiXSxcbiAgLy8gRm9ybSBmZWVkXG4gIFtcInZcIiwgXCJcXHZcIl0sXG4gIC8vIFZlcnRpY2FsIHRhYlxuICBbXCInXCIsIFwiJ1wiXSxcbiAgLy8gU2luZ2xlIHF1b3RlXG4gIFsnXCInLCAnXCInXSxcbiAgLy8gRG91YmxlIHF1b3RlXG4gIFtcIlxcXFxcIiwgXCJcXFxcXCJdXG4gIC8vIEJhY2tzbGFzaFxuXSk7XG5mdW5jdGlvbiBwcmVwcm9jZXNzKHRlbXBsYXRlLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKHRlbXBsYXRlLmVuZHNXaXRoKFwiXFxuXCIpKSB7XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5zbGljZSgwLCAtMSk7XG4gIH1cbiAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC97Iy4qPyN9L2dzLCBcInsjI31cIik7XG4gIGlmIChvcHRpb25zLmxzdHJpcF9ibG9ja3MpIHtcbiAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL15bIFxcdF0qKHtbIyVdKS9nbSwgXCIkMVwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy50cmltX2Jsb2Nrcykge1xuICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvKFsjJV19KVxcbi9nLCBcIiQxXCIpO1xuICB9XG4gIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC97IyN9L2csIFwiXCIpLnJlcGxhY2UoLy0lfVxccyovZywgXCIlfVwiKS5yZXBsYWNlKC9cXHMqeyUtL2csIFwieyVcIikucmVwbGFjZSgvLX19XFxzKi9nLCBcIn19XCIpLnJlcGxhY2UoL1xccyp7ey0vZywgXCJ7e1wiKTtcbn1cbmZ1bmN0aW9uIHRva2VuaXplKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBjb25zdCBzcmMgPSBwcmVwcm9jZXNzKHNvdXJjZSwgb3B0aW9ucyk7XG4gIGxldCBjdXJzb3JQb3NpdGlvbiA9IDA7XG4gIGNvbnN0IGNvbnN1bWVXaGlsZSA9IChwcmVkaWNhdGUpID0+IHtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICB3aGlsZSAocHJlZGljYXRlKHNyY1tjdXJzb3JQb3NpdGlvbl0pKSB7XG4gICAgICBpZiAoc3JjW2N1cnNvclBvc2l0aW9uXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgKytjdXJzb3JQb3NpdGlvbjtcbiAgICAgICAgaWYgKGN1cnNvclBvc2l0aW9uID49IHNyYy5sZW5ndGgpXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXRcIik7XG4gICAgICAgIGNvbnN0IGVzY2FwZWQgPSBzcmNbY3Vyc29yUG9zaXRpb24rK107XG4gICAgICAgIGNvbnN0IHVuZXNjYXBlZCA9IEVTQ0FQRV9DSEFSQUNURVJTLmdldChlc2NhcGVkKTtcbiAgICAgICAgaWYgKHVuZXNjYXBlZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGVzY2FwZWQgY2hhcmFjdGVyOiAke2VzY2FwZWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9IHVuZXNjYXBlZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzdHIgKz0gc3JjW2N1cnNvclBvc2l0aW9uKytdO1xuICAgICAgaWYgKGN1cnNvclBvc2l0aW9uID49IHNyYy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICBtYWluOlxuICAgIHdoaWxlIChjdXJzb3JQb3NpdGlvbiA8IHNyYy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhc3RUb2tlblR5cGUgPSB0b2tlbnMuYXQoLTEpPy50eXBlO1xuICAgICAgaWYgKGxhc3RUb2tlblR5cGUgPT09IHZvaWQgMCB8fCBsYXN0VG9rZW5UeXBlID09PSBUT0tFTl9UWVBFUy5DbG9zZVN0YXRlbWVudCB8fCBsYXN0VG9rZW5UeXBlID09PSBUT0tFTl9UWVBFUy5DbG9zZUV4cHJlc3Npb24pIHtcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiO1xuICAgICAgICB3aGlsZSAoY3Vyc29yUG9zaXRpb24gPCBzcmMubGVuZ3RoICYmIC8vIEtlZXAgZ29pbmcgdW50aWwgd2UgaGl0IHRoZSBuZXh0IEppbmphIHN0YXRlbWVudCBvciBleHByZXNzaW9uXG4gICAgICAgICEoc3JjW2N1cnNvclBvc2l0aW9uXSA9PT0gXCJ7XCIgJiYgKHNyY1tjdXJzb3JQb3NpdGlvbiArIDFdID09PSBcIiVcIiB8fCBzcmNbY3Vyc29yUG9zaXRpb24gKyAxXSA9PT0gXCJ7XCIpKSkge1xuICAgICAgICAgIHRleHQgKz0gc3JjW2N1cnNvclBvc2l0aW9uKytdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0b2tlbnMucHVzaChuZXcgVG9rZW4odGV4dCwgVE9LRU5fVFlQRVMuVGV4dCkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdW1lV2hpbGUoKGNoYXIyKSA9PiAvXFxzLy50ZXN0KGNoYXIyKSk7XG4gICAgICBjb25zdCBjaGFyID0gc3JjW2N1cnNvclBvc2l0aW9uXTtcbiAgICAgIGlmIChjaGFyID09PSBcIi1cIiB8fCBjaGFyID09PSBcIitcIikge1xuICAgICAgICBjb25zdCBsYXN0VG9rZW5UeXBlMiA9IHRva2Vucy5hdCgtMSk/LnR5cGU7XG4gICAgICAgIGlmIChsYXN0VG9rZW5UeXBlMiA9PT0gVE9LRU5fVFlQRVMuVGV4dCB8fCBsYXN0VG9rZW5UeXBlMiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlcjogJHtjaGFyfWApO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobGFzdFRva2VuVHlwZTIpIHtcbiAgICAgICAgICBjYXNlIFRPS0VOX1RZUEVTLklkZW50aWZpZXI6XG4gICAgICAgICAgY2FzZSBUT0tFTl9UWVBFUy5OdW1lcmljTGl0ZXJhbDpcbiAgICAgICAgICBjYXNlIFRPS0VOX1RZUEVTLkJvb2xlYW5MaXRlcmFsOlxuICAgICAgICAgIGNhc2UgVE9LRU5fVFlQRVMuU3RyaW5nTGl0ZXJhbDpcbiAgICAgICAgICBjYXNlIFRPS0VOX1RZUEVTLkNsb3NlUGFyZW46XG4gICAgICAgICAgY2FzZSBUT0tFTl9UWVBFUy5DbG9zZVNxdWFyZUJyYWNrZXQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICArK2N1cnNvclBvc2l0aW9uO1xuICAgICAgICAgICAgY29uc3QgbnVtID0gY29uc3VtZVdoaWxlKGlzSW50ZWdlcik7XG4gICAgICAgICAgICB0b2tlbnMucHVzaChcbiAgICAgICAgICAgICAgbmV3IFRva2VuKGAke2NoYXJ9JHtudW19YCwgbnVtLmxlbmd0aCA+IDAgPyBUT0tFTl9UWVBFUy5OdW1lcmljTGl0ZXJhbCA6IFRPS0VOX1RZUEVTLlVuYXJ5T3BlcmF0b3IpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtjaGFyMiwgdG9rZW5dIG9mIE9SREVSRURfTUFQUElOR19UQUJMRSkge1xuICAgICAgICBjb25zdCBzbGljZTIgPSBzcmMuc2xpY2UoY3Vyc29yUG9zaXRpb24sIGN1cnNvclBvc2l0aW9uICsgY2hhcjIubGVuZ3RoKTtcbiAgICAgICAgaWYgKHNsaWNlMiA9PT0gY2hhcjIpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaChuZXcgVG9rZW4oY2hhcjIsIHRva2VuKSk7XG4gICAgICAgICAgY3Vyc29yUG9zaXRpb24gKz0gY2hhcjIubGVuZ3RoO1xuICAgICAgICAgIGNvbnRpbnVlIG1haW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjaGFyID09PSBcIidcIiB8fCBjaGFyID09PSAnXCInKSB7XG4gICAgICAgICsrY3Vyc29yUG9zaXRpb247XG4gICAgICAgIGNvbnN0IHN0ciA9IGNvbnN1bWVXaGlsZSgoYykgPT4gYyAhPT0gY2hhcik7XG4gICAgICAgIHRva2Vucy5wdXNoKG5ldyBUb2tlbihzdHIsIFRPS0VOX1RZUEVTLlN0cmluZ0xpdGVyYWwpKTtcbiAgICAgICAgKytjdXJzb3JQb3NpdGlvbjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNJbnRlZ2VyKGNoYXIpKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IGNvbnN1bWVXaGlsZShpc0ludGVnZXIpO1xuICAgICAgICB0b2tlbnMucHVzaChuZXcgVG9rZW4obnVtLCBUT0tFTl9UWVBFUy5OdW1lcmljTGl0ZXJhbCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1dvcmQoY2hhcikpIHtcbiAgICAgICAgY29uc3Qgd29yZCA9IGNvbnN1bWVXaGlsZShpc1dvcmQpO1xuICAgICAgICBjb25zdCB0eXBlID0gT2JqZWN0Lmhhc093bihLRVlXT1JEUywgd29yZCkgPyBLRVlXT1JEU1t3b3JkXSA6IFRPS0VOX1RZUEVTLklkZW50aWZpZXI7XG4gICAgICAgIGlmICh0eXBlID09PSBUT0tFTl9UWVBFUy5JbiAmJiB0b2tlbnMuYXQoLTEpPy50eXBlID09PSBUT0tFTl9UWVBFUy5Ob3QpIHtcbiAgICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2gobmV3IFRva2VuKFwibm90IGluXCIsIFRPS0VOX1RZUEVTLk5vdEluKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2gobmV3IFRva2VuKHdvcmQsIHR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXI6ICR7Y2hhcn1gKTtcbiAgICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5cbi8vIHNyYy9hc3QudHNcbnZhciBTdGF0ZW1lbnQgPSBjbGFzcyB7XG4gIHR5cGUgPSBcIlN0YXRlbWVudFwiO1xufTtcbnZhciBQcm9ncmFtID0gY2xhc3MgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihib2R5KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICB9XG4gIHR5cGUgPSBcIlByb2dyYW1cIjtcbn07XG52YXIgSWYgPSBjbGFzcyBleHRlbmRzIFN0YXRlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHRlc3QsIGJvZHksIGFsdGVybmF0ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICB9XG4gIHR5cGUgPSBcIklmXCI7XG59O1xudmFyIEZvciA9IGNsYXNzIGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgY29uc3RydWN0b3IobG9vcHZhciwgaXRlcmFibGUsIGJvZHkpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubG9vcHZhciA9IGxvb3B2YXI7XG4gICAgdGhpcy5pdGVyYWJsZSA9IGl0ZXJhYmxlO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gIH1cbiAgdHlwZSA9IFwiRm9yXCI7XG59O1xudmFyIFNldFN0YXRlbWVudCA9IGNsYXNzIGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgY29uc3RydWN0b3IoYXNzaWduZWUsIHZhbHVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFzc2lnbmVlID0gYXNzaWduZWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHR5cGUgPSBcIlNldFwiO1xufTtcbnZhciBFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBTdGF0ZW1lbnQge1xuICB0eXBlID0gXCJFeHByZXNzaW9uXCI7XG59O1xudmFyIE1lbWJlckV4cHJlc3Npb24gPSBjbGFzcyBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihvYmplY3QsIHByb3BlcnR5LCBjb21wdXRlZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIHRoaXMuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgfVxuICB0eXBlID0gXCJNZW1iZXJFeHByZXNzaW9uXCI7XG59O1xudmFyIENhbGxFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3IoY2FsbGVlLCBhcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG4gIHR5cGUgPSBcIkNhbGxFeHByZXNzaW9uXCI7XG59O1xudmFyIElkZW50aWZpZXIgPSBjbGFzcyBleHRlbmRzIEV4cHJlc3Npb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBuYW1lIG9mIHRoZSBpZGVudGlmaWVyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHR5cGUgPSBcIklkZW50aWZpZXJcIjtcbn07XG52YXIgTGl0ZXJhbCA9IGNsYXNzIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgdHlwZSA9IFwiTGl0ZXJhbFwiO1xufTtcbnZhciBOdW1lcmljTGl0ZXJhbCA9IGNsYXNzIGV4dGVuZHMgTGl0ZXJhbCB7XG4gIHR5cGUgPSBcIk51bWVyaWNMaXRlcmFsXCI7XG59O1xudmFyIFN0cmluZ0xpdGVyYWwgPSBjbGFzcyBleHRlbmRzIExpdGVyYWwge1xuICB0eXBlID0gXCJTdHJpbmdMaXRlcmFsXCI7XG59O1xudmFyIEJvb2xlYW5MaXRlcmFsID0gY2xhc3MgZXh0ZW5kcyBMaXRlcmFsIHtcbiAgdHlwZSA9IFwiQm9vbGVhbkxpdGVyYWxcIjtcbn07XG52YXIgQXJyYXlMaXRlcmFsID0gY2xhc3MgZXh0ZW5kcyBMaXRlcmFsIHtcbiAgdHlwZSA9IFwiQXJyYXlMaXRlcmFsXCI7XG59O1xudmFyIFR1cGxlTGl0ZXJhbCA9IGNsYXNzIGV4dGVuZHMgTGl0ZXJhbCB7XG4gIHR5cGUgPSBcIlR1cGxlTGl0ZXJhbFwiO1xufTtcbnZhciBPYmplY3RMaXRlcmFsID0gY2xhc3MgZXh0ZW5kcyBMaXRlcmFsIHtcbiAgdHlwZSA9IFwiT2JqZWN0TGl0ZXJhbFwiO1xufTtcbnZhciBCaW5hcnlFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3Iob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gIH1cbiAgdHlwZSA9IFwiQmluYXJ5RXhwcmVzc2lvblwiO1xufTtcbnZhciBGaWx0ZXJFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3Iob3BlcmFuZCwgZmlsdGVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wZXJhbmQgPSBvcGVyYW5kO1xuICAgIHRoaXMuZmlsdGVyID0gZmlsdGVyO1xuICB9XG4gIHR5cGUgPSBcIkZpbHRlckV4cHJlc3Npb25cIjtcbn07XG52YXIgVGVzdEV4cHJlc3Npb24gPSBjbGFzcyBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihvcGVyYW5kLCBuZWdhdGUsIHRlc3QpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3BlcmFuZCA9IG9wZXJhbmQ7XG4gICAgdGhpcy5uZWdhdGUgPSBuZWdhdGU7XG4gICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgfVxuICB0eXBlID0gXCJUZXN0RXhwcmVzc2lvblwiO1xufTtcbnZhciBVbmFyeUV4cHJlc3Npb24gPSBjbGFzcyBleHRlbmRzIEV4cHJlc3Npb24ge1xuICBjb25zdHJ1Y3RvcihvcGVyYXRvciwgYXJndW1lbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gIH1cbiAgdHlwZSA9IFwiVW5hcnlFeHByZXNzaW9uXCI7XG59O1xudmFyIFNsaWNlRXhwcmVzc2lvbiA9IGNsYXNzIGV4dGVuZHMgRXhwcmVzc2lvbiB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0ID0gdm9pZCAwLCBzdG9wID0gdm9pZCAwLCBzdGVwID0gdm9pZCAwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5zdG9wID0gc3RvcDtcbiAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuICB9XG4gIHR5cGUgPSBcIlNsaWNlRXhwcmVzc2lvblwiO1xufTtcbnZhciBLZXl3b3JkQXJndW1lbnRFeHByZXNzaW9uID0gY2xhc3MgZXh0ZW5kcyBFeHByZXNzaW9uIHtcbiAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIHR5cGUgPSBcIktleXdvcmRBcmd1bWVudEV4cHJlc3Npb25cIjtcbn07XG5cbi8vIHNyYy9wYXJzZXIudHNcbmZ1bmN0aW9uIHBhcnNlKHRva2Vucykge1xuICBjb25zdCBwcm9ncmFtID0gbmV3IFByb2dyYW0oW10pO1xuICBsZXQgY3VycmVudCA9IDA7XG4gIGZ1bmN0aW9uIGV4cGVjdCh0eXBlLCBlcnJvcikge1xuICAgIGNvbnN0IHByZXYgPSB0b2tlbnNbY3VycmVudCsrXTtcbiAgICBpZiAoIXByZXYgfHwgcHJldi50eXBlICE9PSB0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcnNlciBFcnJvcjogJHtlcnJvcn0uICR7cHJldi50eXBlfSAhPT0gJHt0eXBlfS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHByZXY7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VBbnkoKSB7XG4gICAgc3dpdGNoICh0b2tlbnNbY3VycmVudF0udHlwZSkge1xuICAgICAgY2FzZSBUT0tFTl9UWVBFUy5UZXh0OlxuICAgICAgICByZXR1cm4gcGFyc2VUZXh0KCk7XG4gICAgICBjYXNlIFRPS0VOX1RZUEVTLk9wZW5TdGF0ZW1lbnQ6XG4gICAgICAgIHJldHVybiBwYXJzZUppbmphU3RhdGVtZW50KCk7XG4gICAgICBjYXNlIFRPS0VOX1RZUEVTLk9wZW5FeHByZXNzaW9uOlxuICAgICAgICByZXR1cm4gcGFyc2VKaW5qYUV4cHJlc3Npb24oKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCB0b2tlbiB0eXBlOiAke3Rva2Vuc1tjdXJyZW50XS50eXBlfWApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub3QoLi4udHlwZXMpIHtcbiAgICByZXR1cm4gY3VycmVudCArIHR5cGVzLmxlbmd0aCA8PSB0b2tlbnMubGVuZ3RoICYmIHR5cGVzLnNvbWUoKHR5cGUsIGkpID0+IHR5cGUgIT09IHRva2Vuc1tjdXJyZW50ICsgaV0udHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gaXMoLi4udHlwZXMpIHtcbiAgICByZXR1cm4gY3VycmVudCArIHR5cGVzLmxlbmd0aCA8PSB0b2tlbnMubGVuZ3RoICYmIHR5cGVzLmV2ZXJ5KCh0eXBlLCBpKSA9PiB0eXBlID09PSB0b2tlbnNbY3VycmVudCArIGldLnR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlVGV4dCgpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0xpdGVyYWwoZXhwZWN0KFRPS0VOX1RZUEVTLlRleHQsIFwiRXhwZWN0ZWQgdGV4dCB0b2tlblwiKS52YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VKaW5qYVN0YXRlbWVudCgpIHtcbiAgICBleHBlY3QoVE9LRU5fVFlQRVMuT3BlblN0YXRlbWVudCwgXCJFeHBlY3RlZCBvcGVuaW5nIHN0YXRlbWVudCB0b2tlblwiKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHN3aXRjaCAodG9rZW5zW2N1cnJlbnRdLnR5cGUpIHtcbiAgICAgIGNhc2UgVE9LRU5fVFlQRVMuU2V0OlxuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlU2V0U3RhdGVtZW50KCk7XG4gICAgICAgIGV4cGVjdChUT0tFTl9UWVBFUy5DbG9zZVN0YXRlbWVudCwgXCJFeHBlY3RlZCBjbG9zaW5nIHN0YXRlbWVudCB0b2tlblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPS0VOX1RZUEVTLklmOlxuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlSWZTdGF0ZW1lbnQoKTtcbiAgICAgICAgZXhwZWN0KFRPS0VOX1RZUEVTLk9wZW5TdGF0ZW1lbnQsIFwiRXhwZWN0ZWQgeyUgdG9rZW5cIik7XG4gICAgICAgIGV4cGVjdChUT0tFTl9UWVBFUy5FbmRJZiwgXCJFeHBlY3RlZCBlbmRpZiB0b2tlblwiKTtcbiAgICAgICAgZXhwZWN0KFRPS0VOX1RZUEVTLkNsb3NlU3RhdGVtZW50LCBcIkV4cGVjdGVkICV9IHRva2VuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9LRU5fVFlQRVMuRm9yOlxuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgIHJlc3VsdCA9IHBhcnNlRm9yU3RhdGVtZW50KCk7XG4gICAgICAgIGV4cGVjdChUT0tFTl9UWVBFUy5PcGVuU3RhdGVtZW50LCBcIkV4cGVjdGVkIHslIHRva2VuXCIpO1xuICAgICAgICBleHBlY3QoVE9LRU5fVFlQRVMuRW5kRm9yLCBcIkV4cGVjdGVkIGVuZGZvciB0b2tlblwiKTtcbiAgICAgICAgZXhwZWN0KFRPS0VOX1RZUEVTLkNsb3NlU3RhdGVtZW50LCBcIkV4cGVjdGVkICV9IHRva2VuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5rbm93biBzdGF0ZW1lbnQgdHlwZTogJHt0b2tlbnNbY3VycmVudF0udHlwZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUppbmphRXhwcmVzc2lvbigpIHtcbiAgICBleHBlY3QoVE9LRU5fVFlQRVMuT3BlbkV4cHJlc3Npb24sIFwiRXhwZWN0ZWQgb3BlbmluZyBleHByZXNzaW9uIHRva2VuXCIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGV4cGVjdChUT0tFTl9UWVBFUy5DbG9zZUV4cHJlc3Npb24sIFwiRXhwZWN0ZWQgY2xvc2luZyBleHByZXNzaW9uIHRva2VuXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VTZXRTdGF0ZW1lbnQoKSB7XG4gICAgY29uc3QgbGVmdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGlmIChpcyhUT0tFTl9UWVBFUy5FcXVhbHMpKSB7XG4gICAgICArK2N1cnJlbnQ7XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlU2V0U3RhdGVtZW50KCk7XG4gICAgICByZXR1cm4gbmV3IFNldFN0YXRlbWVudChsZWZ0LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlSWZTdGF0ZW1lbnQoKSB7XG4gICAgY29uc3QgdGVzdCA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGV4cGVjdChUT0tFTl9UWVBFUy5DbG9zZVN0YXRlbWVudCwgXCJFeHBlY3RlZCBjbG9zaW5nIHN0YXRlbWVudCB0b2tlblwiKTtcbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgY29uc3QgYWx0ZXJuYXRlID0gW107XG4gICAgd2hpbGUgKCEodG9rZW5zW2N1cnJlbnRdPy50eXBlID09PSBUT0tFTl9UWVBFUy5PcGVuU3RhdGVtZW50ICYmICh0b2tlbnNbY3VycmVudCArIDFdPy50eXBlID09PSBUT0tFTl9UWVBFUy5FbHNlSWYgfHwgdG9rZW5zW2N1cnJlbnQgKyAxXT8udHlwZSA9PT0gVE9LRU5fVFlQRVMuRWxzZSB8fCB0b2tlbnNbY3VycmVudCArIDFdPy50eXBlID09PSBUT0tFTl9UWVBFUy5FbmRJZikpKSB7XG4gICAgICBib2R5LnB1c2gocGFyc2VBbnkoKSk7XG4gICAgfVxuICAgIGlmICh0b2tlbnNbY3VycmVudF0/LnR5cGUgPT09IFRPS0VOX1RZUEVTLk9wZW5TdGF0ZW1lbnQgJiYgdG9rZW5zW2N1cnJlbnQgKyAxXT8udHlwZSAhPT0gVE9LRU5fVFlQRVMuRW5kSWYpIHtcbiAgICAgICsrY3VycmVudDtcbiAgICAgIGlmIChpcyhUT0tFTl9UWVBFUy5FbHNlSWYpKSB7XG4gICAgICAgIGV4cGVjdChUT0tFTl9UWVBFUy5FbHNlSWYsIFwiRXhwZWN0ZWQgZWxzZWlmIHRva2VuXCIpO1xuICAgICAgICBhbHRlcm5hdGUucHVzaChwYXJzZUlmU3RhdGVtZW50KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhwZWN0KFRPS0VOX1RZUEVTLkVsc2UsIFwiRXhwZWN0ZWQgZWxzZSB0b2tlblwiKTtcbiAgICAgICAgZXhwZWN0KFRPS0VOX1RZUEVTLkNsb3NlU3RhdGVtZW50LCBcIkV4cGVjdGVkIGNsb3Npbmcgc3RhdGVtZW50IHRva2VuXCIpO1xuICAgICAgICB3aGlsZSAoISh0b2tlbnNbY3VycmVudF0/LnR5cGUgPT09IFRPS0VOX1RZUEVTLk9wZW5TdGF0ZW1lbnQgJiYgdG9rZW5zW2N1cnJlbnQgKyAxXT8udHlwZSA9PT0gVE9LRU5fVFlQRVMuRW5kSWYpKSB7XG4gICAgICAgICAgYWx0ZXJuYXRlLnB1c2gocGFyc2VBbnkoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBJZih0ZXN0LCBib2R5LCBhbHRlcm5hdGUpO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvblNlcXVlbmNlKHByaW1hcnkgPSBmYWxzZSkge1xuICAgIGNvbnN0IGZuID0gcHJpbWFyeSA/IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24gOiBwYXJzZUV4cHJlc3Npb247XG4gICAgY29uc3QgZXhwcmVzc2lvbnMgPSBbZm4oKV07XG4gICAgY29uc3QgaXNUdXBsZSA9IGlzKFRPS0VOX1RZUEVTLkNvbW1hKTtcbiAgICB3aGlsZSAoaXNUdXBsZSkge1xuICAgICAgKytjdXJyZW50O1xuICAgICAgZXhwcmVzc2lvbnMucHVzaChmbigpKTtcbiAgICAgIGlmICghaXMoVE9LRU5fVFlQRVMuQ29tbWEpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNUdXBsZSA/IG5ldyBUdXBsZUxpdGVyYWwoZXhwcmVzc2lvbnMpIDogZXhwcmVzc2lvbnNbMF07XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VGb3JTdGF0ZW1lbnQoKSB7XG4gICAgY29uc3QgbG9vcFZhcmlhYmxlID0gcGFyc2VFeHByZXNzaW9uU2VxdWVuY2UodHJ1ZSk7XG4gICAgaWYgKCEobG9vcFZhcmlhYmxlIGluc3RhbmNlb2YgSWRlbnRpZmllciB8fCBsb29wVmFyaWFibGUgaW5zdGFuY2VvZiBUdXBsZUxpdGVyYWwpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEV4cGVjdGVkIGlkZW50aWZpZXIvdHVwbGUgZm9yIHRoZSBsb29wIHZhcmlhYmxlLCBnb3QgJHtsb29wVmFyaWFibGUudHlwZX0gaW5zdGVhZGApO1xuICAgIH1cbiAgICBleHBlY3QoVE9LRU5fVFlQRVMuSW4sIFwiRXhwZWN0ZWQgYGluYCBrZXl3b3JkIGZvbGxvd2luZyBsb29wIHZhcmlhYmxlXCIpO1xuICAgIGNvbnN0IGl0ZXJhYmxlID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgZXhwZWN0KFRPS0VOX1RZUEVTLkNsb3NlU3RhdGVtZW50LCBcIkV4cGVjdGVkIGNsb3Npbmcgc3RhdGVtZW50IHRva2VuXCIpO1xuICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICB3aGlsZSAobm90KFRPS0VOX1RZUEVTLk9wZW5TdGF0ZW1lbnQsIFRPS0VOX1RZUEVTLkVuZEZvcikpIHtcbiAgICAgIGJvZHkucHVzaChwYXJzZUFueSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGb3IobG9vcFZhcmlhYmxlLCBpdGVyYWJsZSwgYm9keSk7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiBwYXJzZVRlcm5hcnlFeHByZXNzaW9uKCk7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VUZXJuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCBhID0gcGFyc2VMb2dpY2FsT3JFeHByZXNzaW9uKCk7XG4gICAgaWYgKGlzKFRPS0VOX1RZUEVTLklmKSkge1xuICAgICAgKytjdXJyZW50O1xuICAgICAgY29uc3QgcHJlZGljYXRlID0gcGFyc2VMb2dpY2FsT3JFeHByZXNzaW9uKCk7XG4gICAgICBleHBlY3QoVE9LRU5fVFlQRVMuRWxzZSwgXCJFeHBlY3RlZCBlbHNlIHRva2VuXCIpO1xuICAgICAgY29uc3QgYiA9IHBhcnNlTG9naWNhbE9yRXhwcmVzc2lvbigpO1xuICAgICAgcmV0dXJuIG5ldyBJZihwcmVkaWNhdGUsIFthXSwgW2JdKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VMb2dpY2FsT3JFeHByZXNzaW9uKCkge1xuICAgIGxldCBsZWZ0ID0gcGFyc2VMb2dpY2FsQW5kRXhwcmVzc2lvbigpO1xuICAgIHdoaWxlIChpcyhUT0tFTl9UWVBFUy5PcikpIHtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gdG9rZW5zW2N1cnJlbnRdO1xuICAgICAgKytjdXJyZW50O1xuICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZUxvZ2ljYWxBbmRFeHByZXNzaW9uKCk7XG4gICAgICBsZWZ0ID0gbmV3IEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VMb2dpY2FsQW5kRXhwcmVzc2lvbigpIHtcbiAgICBsZXQgbGVmdCA9IHBhcnNlTG9naWNhbE5lZ2F0aW9uRXhwcmVzc2lvbigpO1xuICAgIHdoaWxlIChpcyhUT0tFTl9UWVBFUy5BbmQpKSB7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IHRva2Vuc1tjdXJyZW50XTtcbiAgICAgICsrY3VycmVudDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VMb2dpY2FsTmVnYXRpb25FeHByZXNzaW9uKCk7XG4gICAgICBsZWZ0ID0gbmV3IEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VMb2dpY2FsTmVnYXRpb25FeHByZXNzaW9uKCkge1xuICAgIGxldCByaWdodDtcbiAgICB3aGlsZSAoaXMoVE9LRU5fVFlQRVMuTm90KSkge1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0b2tlbnNbY3VycmVudF07XG4gICAgICArK2N1cnJlbnQ7XG4gICAgICBjb25zdCBhcmcgPSBwYXJzZUxvZ2ljYWxOZWdhdGlvbkV4cHJlc3Npb24oKTtcbiAgICAgIHJpZ2h0ID0gbmV3IFVuYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgYXJnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0ID8/IHBhcnNlQ29tcGFyaXNvbkV4cHJlc3Npb24oKTtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUNvbXBhcmlzb25FeHByZXNzaW9uKCkge1xuICAgIGxldCBsZWZ0ID0gcGFyc2VBZGRpdGl2ZUV4cHJlc3Npb24oKTtcbiAgICB3aGlsZSAoaXMoVE9LRU5fVFlQRVMuQ29tcGFyaXNvbkJpbmFyeU9wZXJhdG9yKSB8fCBpcyhUT0tFTl9UWVBFUy5JbikgfHwgaXMoVE9LRU5fVFlQRVMuTm90SW4pKSB7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IHRva2Vuc1tjdXJyZW50XTtcbiAgICAgICsrY3VycmVudDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VBZGRpdGl2ZUV4cHJlc3Npb24oKTtcbiAgICAgIGxlZnQgPSBuZXcgQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUFkZGl0aXZlRXhwcmVzc2lvbigpIHtcbiAgICBsZXQgbGVmdCA9IHBhcnNlTXVsdGlwbGljYXRpdmVFeHByZXNzaW9uKCk7XG4gICAgd2hpbGUgKGlzKFRPS0VOX1RZUEVTLkFkZGl0aXZlQmluYXJ5T3BlcmF0b3IpKSB7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IHRva2Vuc1tjdXJyZW50XTtcbiAgICAgICsrY3VycmVudDtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gcGFyc2VNdWx0aXBsaWNhdGl2ZUV4cHJlc3Npb24oKTtcbiAgICAgIGxlZnQgPSBuZXcgQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUNhbGxNZW1iZXJFeHByZXNzaW9uKCkge1xuICAgIGNvbnN0IG1lbWJlciA9IHBhcnNlTWVtYmVyRXhwcmVzc2lvbigpO1xuICAgIGlmIChpcyhUT0tFTl9UWVBFUy5PcGVuUGFyZW4pKSB7XG4gICAgICByZXR1cm4gcGFyc2VDYWxsRXhwcmVzc2lvbihtZW1iZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbWVtYmVyO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlQ2FsbEV4cHJlc3Npb24oY2FsbGVlKSB7XG4gICAgbGV0IGNhbGxFeHByZXNzaW9uID0gbmV3IENhbGxFeHByZXNzaW9uKGNhbGxlZSwgcGFyc2VBcmdzKCkpO1xuICAgIGlmIChpcyhUT0tFTl9UWVBFUy5PcGVuUGFyZW4pKSB7XG4gICAgICBjYWxsRXhwcmVzc2lvbiA9IHBhcnNlQ2FsbEV4cHJlc3Npb24oY2FsbEV4cHJlc3Npb24pO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbEV4cHJlc3Npb247XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VBcmdzKCkge1xuICAgIGV4cGVjdChUT0tFTl9UWVBFUy5PcGVuUGFyZW4sIFwiRXhwZWN0ZWQgb3BlbmluZyBwYXJlbnRoZXNpcyBmb3IgYXJndW1lbnRzIGxpc3RcIik7XG4gICAgY29uc3QgYXJncyA9IHBhcnNlQXJndW1lbnRzTGlzdCgpO1xuICAgIGV4cGVjdChUT0tFTl9UWVBFUy5DbG9zZVBhcmVuLCBcIkV4cGVjdGVkIGNsb3NpbmcgcGFyZW50aGVzaXMgZm9yIGFyZ3VtZW50cyBsaXN0XCIpO1xuICAgIHJldHVybiBhcmdzO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzTGlzdCgpIHtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgd2hpbGUgKCFpcyhUT0tFTl9UWVBFUy5DbG9zZVBhcmVuKSkge1xuICAgICAgbGV0IGFyZ3VtZW50ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBpZiAoaXMoVE9LRU5fVFlQRVMuRXF1YWxzKSkge1xuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgIGlmICghKGFyZ3VtZW50IGluc3RhbmNlb2YgSWRlbnRpZmllcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEV4cGVjdGVkIGlkZW50aWZpZXIgZm9yIGtleXdvcmQgYXJndW1lbnRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICBhcmd1bWVudCA9IG5ldyBLZXl3b3JkQXJndW1lbnRFeHByZXNzaW9uKGFyZ3VtZW50LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnQpO1xuICAgICAgaWYgKGlzKFRPS0VOX1RZUEVTLkNvbW1hKSkge1xuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlTWVtYmVyRXhwcmVzc2lvbkFyZ3VtZW50c0xpc3QoKSB7XG4gICAgY29uc3Qgc2xpY2VzID0gW107XG4gICAgbGV0IGlzU2xpY2UgPSBmYWxzZTtcbiAgICB3aGlsZSAoIWlzKFRPS0VOX1RZUEVTLkNsb3NlU3F1YXJlQnJhY2tldCkpIHtcbiAgICAgIGlmIChpcyhUT0tFTl9UWVBFUy5Db2xvbikpIHtcbiAgICAgICAgc2xpY2VzLnB1c2godm9pZCAwKTtcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICBpc1NsaWNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsaWNlcy5wdXNoKHBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgaWYgKGlzKFRPS0VOX1RZUEVTLkNvbG9uKSkge1xuICAgICAgICAgICsrY3VycmVudDtcbiAgICAgICAgICBpc1NsaWNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2xpY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQgZm9yIG1lbWJlci9zbGljZSBleHByZXNzaW9uYCk7XG4gICAgfVxuICAgIGlmIChpc1NsaWNlKSB7XG4gICAgICBpZiAoc2xpY2VzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCAwLTMgYXJndW1lbnRzIGZvciBzbGljZSBleHByZXNzaW9uYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFNsaWNlRXhwcmVzc2lvbiguLi5zbGljZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2xpY2VzWzBdO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlTWVtYmVyRXhwcmVzc2lvbigpIHtcbiAgICBsZXQgb2JqZWN0ID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuICAgIHdoaWxlIChpcyhUT0tFTl9UWVBFUy5Eb3QpIHx8IGlzKFRPS0VOX1RZUEVTLk9wZW5TcXVhcmVCcmFja2V0KSkge1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0b2tlbnNbY3VycmVudF07XG4gICAgICArK2N1cnJlbnQ7XG4gICAgICBsZXQgcHJvcGVydHk7XG4gICAgICBjb25zdCBjb21wdXRlZCA9IG9wZXJhdG9yLnR5cGUgIT09IFRPS0VOX1RZUEVTLkRvdDtcbiAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTWVtYmVyRXhwcmVzc2lvbkFyZ3VtZW50c0xpc3QoKTtcbiAgICAgICAgZXhwZWN0KFRPS0VOX1RZUEVTLkNsb3NlU3F1YXJlQnJhY2tldCwgXCJFeHBlY3RlZCBjbG9zaW5nIHNxdWFyZSBicmFja2V0XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcGVydHkgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgIGlmIChwcm9wZXJ0eS50eXBlICE9PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgRXhwZWN0ZWQgaWRlbnRpZmllciBmb2xsb3dpbmcgZG90IG9wZXJhdG9yYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG5ldyBNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHksIGNvbXB1dGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZU11bHRpcGxpY2F0aXZlRXhwcmVzc2lvbigpIHtcbiAgICBsZXQgbGVmdCA9IHBhcnNlVGVzdEV4cHJlc3Npb24oKTtcbiAgICB3aGlsZSAoaXMoVE9LRU5fVFlQRVMuTXVsdGlwbGljYXRpdmVCaW5hcnlPcGVyYXRvcikpIHtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gdG9rZW5zW2N1cnJlbnRdO1xuICAgICAgKytjdXJyZW50O1xuICAgICAgY29uc3QgcmlnaHQgPSBwYXJzZVRlc3RFeHByZXNzaW9uKCk7XG4gICAgICBsZWZ0ID0gbmV3IEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VUZXN0RXhwcmVzc2lvbigpIHtcbiAgICBsZXQgb3BlcmFuZCA9IHBhcnNlRmlsdGVyRXhwcmVzc2lvbigpO1xuICAgIHdoaWxlIChpcyhUT0tFTl9UWVBFUy5JcykpIHtcbiAgICAgICsrY3VycmVudDtcbiAgICAgIGNvbnN0IG5lZ2F0ZSA9IGlzKFRPS0VOX1RZUEVTLk5vdCk7XG4gICAgICBpZiAobmVnYXRlKSB7XG4gICAgICAgICsrY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGxldCBmaWx0ZXIgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG4gICAgICBpZiAoZmlsdGVyIGluc3RhbmNlb2YgQm9vbGVhbkxpdGVyYWwpIHtcbiAgICAgICAgZmlsdGVyID0gbmV3IElkZW50aWZpZXIoZmlsdGVyLnZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgaWYgKCEoZmlsdGVyIGluc3RhbmNlb2YgSWRlbnRpZmllcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBpZGVudGlmaWVyIGZvciB0aGUgdGVzdGApO1xuICAgICAgfVxuICAgICAgb3BlcmFuZCA9IG5ldyBUZXN0RXhwcmVzc2lvbihvcGVyYW5kLCBuZWdhdGUsIGZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiBvcGVyYW5kO1xuICB9XG4gIGZ1bmN0aW9uIHBhcnNlRmlsdGVyRXhwcmVzc2lvbigpIHtcbiAgICBsZXQgb3BlcmFuZCA9IHBhcnNlQ2FsbE1lbWJlckV4cHJlc3Npb24oKTtcbiAgICB3aGlsZSAoaXMoVE9LRU5fVFlQRVMuUGlwZSkpIHtcbiAgICAgICsrY3VycmVudDtcbiAgICAgIGxldCBmaWx0ZXIgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG4gICAgICBpZiAoIShmaWx0ZXIgaW5zdGFuY2VvZiBJZGVudGlmaWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEV4cGVjdGVkIGlkZW50aWZpZXIgZm9yIHRoZSBmaWx0ZXJgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpcyhUT0tFTl9UWVBFUy5PcGVuUGFyZW4pKSB7XG4gICAgICAgIGZpbHRlciA9IHBhcnNlQ2FsbEV4cHJlc3Npb24oZmlsdGVyKTtcbiAgICAgIH1cbiAgICAgIG9wZXJhbmQgPSBuZXcgRmlsdGVyRXhwcmVzc2lvbihvcGVyYW5kLCBmaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3BlcmFuZDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCkge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2N1cnJlbnRdO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgY2FzZSBUT0tFTl9UWVBFUy5OdW1lcmljTGl0ZXJhbDpcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICByZXR1cm4gbmV3IE51bWVyaWNMaXRlcmFsKE51bWJlcih0b2tlbi52YWx1ZSkpO1xuICAgICAgY2FzZSBUT0tFTl9UWVBFUy5TdHJpbmdMaXRlcmFsOlxuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nTGl0ZXJhbCh0b2tlbi52YWx1ZSk7XG4gICAgICBjYXNlIFRPS0VOX1RZUEVTLkJvb2xlYW5MaXRlcmFsOlxuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhbkxpdGVyYWwodG9rZW4udmFsdWUgPT09IFwidHJ1ZVwiKTtcbiAgICAgIGNhc2UgVE9LRU5fVFlQRVMuSWRlbnRpZmllcjpcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICByZXR1cm4gbmV3IElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICAgICAgY2FzZSBUT0tFTl9UWVBFUy5PcGVuUGFyZW46IHtcbiAgICAgICAgKytjdXJyZW50O1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uU2VxdWVuY2UoKTtcbiAgICAgICAgaWYgKHRva2Vuc1tjdXJyZW50XS50eXBlICE9PSBUT0tFTl9UWVBFUy5DbG9zZVBhcmVuKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBFeHBlY3RlZCBjbG9zaW5nIHBhcmVudGhlc2lzLCBnb3QgJHt0b2tlbnNbY3VycmVudF0udHlwZX0gaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgICsrY3VycmVudDtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgICB9XG4gICAgICBjYXNlIFRPS0VOX1RZUEVTLk9wZW5TcXVhcmVCcmFja2V0OiB7XG4gICAgICAgICsrY3VycmVudDtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgIHdoaWxlICghaXMoVE9LRU5fVFlQRVMuQ2xvc2VTcXVhcmVCcmFja2V0KSkge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHBhcnNlRXhwcmVzc2lvbigpKTtcbiAgICAgICAgICBpZiAoaXMoVE9LRU5fVFlQRVMuQ29tbWEpKSB7XG4gICAgICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICsrY3VycmVudDtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheUxpdGVyYWwodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgVE9LRU5fVFlQRVMuT3BlbkN1cmx5QnJhY2tldDoge1xuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHdoaWxlICghaXMoVE9LRU5fVFlQRVMuQ2xvc2VDdXJseUJyYWNrZXQpKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZXhwZWN0KFRPS0VOX1RZUEVTLkNvbG9uLCBcIkV4cGVjdGVkIGNvbG9uIGJldHdlZW4ga2V5IGFuZCB2YWx1ZSBpbiBvYmplY3QgbGl0ZXJhbFwiKTtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgIHZhbHVlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgaWYgKGlzKFRPS0VOX1RZUEVTLkNvbW1hKSkge1xuICAgICAgICAgICAgKytjdXJyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICArK2N1cnJlbnQ7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0TGl0ZXJhbCh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIHRva2VuOiAke3Rva2VuLnR5cGV9YCk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChjdXJyZW50IDwgdG9rZW5zLmxlbmd0aCkge1xuICAgIHByb2dyYW0uYm9keS5wdXNoKHBhcnNlQW55KCkpO1xuICB9XG4gIHJldHVybiBwcm9ncmFtO1xufVxuXG4vLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwID0gMSkge1xuICBpZiAoc3RvcCA9PT0gdm9pZCAwKSB7XG4gICAgc3RvcCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gMDtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RvcDsgaSArPSBzdGVwKSB7XG4gICAgcmVzdWx0LnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNsaWNlKGFycmF5LCBzdGFydCwgc3RvcCwgc3RlcCA9IDEpIHtcbiAgY29uc3QgZGlyZWN0aW9uID0gTWF0aC5zaWduKHN0ZXApO1xuICBpZiAoZGlyZWN0aW9uID49IDApIHtcbiAgICBzdGFydCA9IChzdGFydCA/Pz0gMCkgPCAwID8gTWF0aC5tYXgoYXJyYXkubGVuZ3RoICsgc3RhcnQsIDApIDogTWF0aC5taW4oc3RhcnQsIGFycmF5Lmxlbmd0aCk7XG4gICAgc3RvcCA9IChzdG9wID8/PSBhcnJheS5sZW5ndGgpIDwgMCA/IE1hdGgubWF4KGFycmF5Lmxlbmd0aCArIHN0b3AsIDApIDogTWF0aC5taW4oc3RvcCwgYXJyYXkubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IChzdGFydCA/Pz0gYXJyYXkubGVuZ3RoIC0gMSkgPCAwID8gTWF0aC5tYXgoYXJyYXkubGVuZ3RoICsgc3RhcnQsIC0xKSA6IE1hdGgubWluKHN0YXJ0LCBhcnJheS5sZW5ndGggLSAxKTtcbiAgICBzdG9wID0gKHN0b3AgPz89IC0xKSA8IC0xID8gTWF0aC5tYXgoYXJyYXkubGVuZ3RoICsgc3RvcCwgLTEpIDogTWF0aC5taW4oc3RvcCwgYXJyYXkubGVuZ3RoIC0gMSk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSBzdGFydDsgZGlyZWN0aW9uICogaSA8IGRpcmVjdGlvbiAqIHN0b3A7IGkgKz0gc3RlcCkge1xuICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdGl0bGVDYXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXGJcXHcvZywgKGMpID0+IGMudG9VcHBlckNhc2UoKSk7XG59XG5cbi8vIHNyYy9ydW50aW1lLnRzXG52YXIgUnVudGltZVZhbHVlID0gY2xhc3Mge1xuICB0eXBlID0gXCJSdW50aW1lVmFsdWVcIjtcbiAgdmFsdWU7XG4gIC8qKlxuICAgKiBBIGNvbGxlY3Rpb24gb2YgYnVpbHQtaW4gZnVuY3Rpb25zIGZvciB0aGlzIHR5cGUuXG4gICAqL1xuICBidWlsdGlucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJ1bnRpbWVWYWx1ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZhbHVlID0gdm9pZCAwKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRydXRoaW5lc3Mgb3IgZmFsc2luZXNzIG9mIHRoZSBydW50aW1lIHZhbHVlLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMgaWYgaXQgaGFzIGN1c3RvbSB0cnV0aGluZXNzIGNyaXRlcmlhLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhblZhbHVlfSBCb29sZWFuVmFsdWUodHJ1ZSkgaWYgdGhlIHZhbHVlIGlzIHRydXRoeSwgQm9vbGVhblZhbHVlKGZhbHNlKSBvdGhlcndpc2UuXG4gICAqL1xuICBfX2Jvb2xfXygpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZSghIXRoaXMudmFsdWUpO1xuICB9XG59O1xudmFyIE51bWVyaWNWYWx1ZSA9IGNsYXNzIGV4dGVuZHMgUnVudGltZVZhbHVlIHtcbiAgdHlwZSA9IFwiTnVtZXJpY1ZhbHVlXCI7XG59O1xudmFyIFN0cmluZ1ZhbHVlID0gY2xhc3MgZXh0ZW5kcyBSdW50aW1lVmFsdWUge1xuICB0eXBlID0gXCJTdHJpbmdWYWx1ZVwiO1xuICBidWlsdGlucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICBbXG4gICAgICBcInVwcGVyXCIsXG4gICAgICBuZXcgRnVuY3Rpb25WYWx1ZSgoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUodGhpcy52YWx1ZS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgIH0pXG4gICAgXSxcbiAgICBbXG4gICAgICBcImxvd2VyXCIsXG4gICAgICBuZXcgRnVuY3Rpb25WYWx1ZSgoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUodGhpcy52YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH0pXG4gICAgXSxcbiAgICBbXG4gICAgICBcInN0cmlwXCIsXG4gICAgICBuZXcgRnVuY3Rpb25WYWx1ZSgoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUodGhpcy52YWx1ZS50cmltKCkpO1xuICAgICAgfSlcbiAgICBdLFxuICAgIFtcbiAgICAgIFwidGl0bGVcIixcbiAgICAgIG5ldyBGdW5jdGlvblZhbHVlKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZSh0aXRsZUNhc2UodGhpcy52YWx1ZSkpO1xuICAgICAgfSlcbiAgICBdLFxuICAgIFtcImxlbmd0aFwiLCBuZXcgTnVtZXJpY1ZhbHVlKHRoaXMudmFsdWUubGVuZ3RoKV1cbiAgXSk7XG59O1xudmFyIEJvb2xlYW5WYWx1ZSA9IGNsYXNzIGV4dGVuZHMgUnVudGltZVZhbHVlIHtcbiAgdHlwZSA9IFwiQm9vbGVhblZhbHVlXCI7XG59O1xudmFyIE9iamVjdFZhbHVlID0gY2xhc3MgZXh0ZW5kcyBSdW50aW1lVmFsdWUge1xuICB0eXBlID0gXCJPYmplY3RWYWx1ZVwiO1xuICAvKipcbiAgICogTk9URTogbmVjZXNzYXJ5IHRvIG92ZXJyaWRlIHNpbmNlIGFsbCBKYXZhU2NyaXB0IGFycmF5cyBhcmUgY29uc2lkZXJlZCB0cnV0aHksXG4gICAqIHdoaWxlIG9ubHkgbm9uLWVtcHR5IFB5dGhvbiBhcnJheXMgYXJlIGNvbnNpZGVyIHRydXRoeS5cbiAgICpcbiAgICogZS5nLixcbiAgICogIC0gSmF2YVNjcmlwdDogIHt9ICYmIDUgLT4gNVxuICAgKiAgLSBQeXRob246ICAgICAge30gYW5kIDUgLT4ge31cbiAgICovXG4gIF9fYm9vbF9fKCkge1xuICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKHRoaXMudmFsdWUuc2l6ZSA+IDApO1xuICB9XG4gIGJ1aWx0aW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgIFtcbiAgICAgIFwiZ2V0XCIsXG4gICAgICBuZXcgRnVuY3Rpb25WYWx1ZSgoW2tleSwgZGVmYXVsdFZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAoIShrZXkgaW5zdGFuY2VvZiBTdHJpbmdWYWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBrZXkgbXVzdCBiZSBhIHN0cmluZzogZ290ICR7a2V5LnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZ2V0KGtleS52YWx1ZSkgPz8gZGVmYXVsdFZhbHVlID8/IG5ldyBOdWxsVmFsdWUoKTtcbiAgICAgIH0pXG4gICAgXSxcbiAgICBbXG4gICAgICBcIml0ZW1zXCIsXG4gICAgICBuZXcgRnVuY3Rpb25WYWx1ZSgoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlWYWx1ZShcbiAgICAgICAgICBBcnJheS5mcm9tKHRoaXMudmFsdWUuZW50cmllcygpKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gbmV3IEFycmF5VmFsdWUoW25ldyBTdHJpbmdWYWx1ZShrZXkpLCB2YWx1ZV0pKVxuICAgICAgICApO1xuICAgICAgfSlcbiAgICBdXG4gIF0pO1xufTtcbnZhciBBcnJheVZhbHVlID0gY2xhc3MgZXh0ZW5kcyBSdW50aW1lVmFsdWUge1xuICB0eXBlID0gXCJBcnJheVZhbHVlXCI7XG4gIGJ1aWx0aW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1tcImxlbmd0aFwiLCBuZXcgTnVtZXJpY1ZhbHVlKHRoaXMudmFsdWUubGVuZ3RoKV1dKTtcbiAgLyoqXG4gICAqIE5PVEU6IG5lY2Vzc2FyeSB0byBvdmVycmlkZSBzaW5jZSBhbGwgSmF2YVNjcmlwdCBhcnJheXMgYXJlIGNvbnNpZGVyZWQgdHJ1dGh5LFxuICAgKiB3aGlsZSBvbmx5IG5vbi1lbXB0eSBQeXRob24gYXJyYXlzIGFyZSBjb25zaWRlciB0cnV0aHkuXG4gICAqXG4gICAqIGUuZy4sXG4gICAqICAtIEphdmFTY3JpcHQ6ICBbXSAmJiA1IC0+IDVcbiAgICogIC0gUHl0aG9uOiAgICAgIFtdIGFuZCA1IC0+IFtdXG4gICAqL1xuICBfX2Jvb2xfXygpIHtcbiAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZSh0aGlzLnZhbHVlLmxlbmd0aCA+IDApO1xuICB9XG59O1xudmFyIFR1cGxlVmFsdWUgPSBjbGFzcyBleHRlbmRzIEFycmF5VmFsdWUge1xuICB0eXBlID0gXCJUdXBsZVZhbHVlXCI7XG59O1xudmFyIEZ1bmN0aW9uVmFsdWUgPSBjbGFzcyBleHRlbmRzIFJ1bnRpbWVWYWx1ZSB7XG4gIHR5cGUgPSBcIkZ1bmN0aW9uVmFsdWVcIjtcbn07XG52YXIgTnVsbFZhbHVlID0gY2xhc3MgZXh0ZW5kcyBSdW50aW1lVmFsdWUge1xuICB0eXBlID0gXCJOdWxsVmFsdWVcIjtcbn07XG52YXIgVW5kZWZpbmVkVmFsdWUgPSBjbGFzcyBleHRlbmRzIFJ1bnRpbWVWYWx1ZSB7XG4gIHR5cGUgPSBcIlVuZGVmaW5lZFZhbHVlXCI7XG59O1xudmFyIEVudmlyb25tZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuICAvKipcbiAgICogVGhlIHZhcmlhYmxlcyBkZWNsYXJlZCBpbiB0aGlzIGVudmlyb25tZW50LlxuICAgKi9cbiAgdmFyaWFibGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgIFtcbiAgICAgIFwibmFtZXNwYWNlXCIsXG4gICAgICBuZXcgRnVuY3Rpb25WYWx1ZSgoYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IE9iamVjdFZhbHVlKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSB8fCAhKGFyZ3NbMF0gaW5zdGFuY2VvZiBPYmplY3RWYWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgbmFtZXNwYWNlYCBleHBlY3RzIGVpdGhlciB6ZXJvIGFyZ3VtZW50cyBvciBhIHNpbmdsZSBvYmplY3QgYXJndW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9KVxuICAgIF1cbiAgXSk7XG4gIC8qKlxuICAgKiBUaGUgdGVzdHMgYXZhaWxhYmxlIGluIHRoaXMgZW52aXJvbm1lbnQuXG4gICAqL1xuICB0ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgICBbXCJib29sZWFuXCIsIChvcGVyYW5kKSA9PiBvcGVyYW5kLnR5cGUgPT09IFwiQm9vbGVhblZhbHVlXCJdLFxuICAgIFtcImNhbGxhYmxlXCIsIChvcGVyYW5kKSA9PiBvcGVyYW5kIGluc3RhbmNlb2YgRnVuY3Rpb25WYWx1ZV0sXG4gICAgW1xuICAgICAgXCJvZGRcIixcbiAgICAgIChvcGVyYW5kKSA9PiB7XG4gICAgICAgIGlmIChvcGVyYW5kLnR5cGUgIT09IFwiTnVtZXJpY1ZhbHVlXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhcHBseSB0ZXN0IFwib2RkXCIgdG8gdHlwZTogJHtvcGVyYW5kLnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhbmQudmFsdWUgJSAyICE9PSAwO1xuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJldmVuXCIsXG4gICAgICAob3BlcmFuZCkgPT4ge1xuICAgICAgICBpZiAob3BlcmFuZC50eXBlICE9PSBcIk51bWVyaWNWYWx1ZVwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYXBwbHkgdGVzdCBcImV2ZW5cIiB0byB0eXBlOiAke29wZXJhbmQudHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmFuZC52YWx1ZSAlIDIgPT09IDA7XG4gICAgICB9XG4gICAgXSxcbiAgICBbXCJmYWxzZVwiLCAob3BlcmFuZCkgPT4gb3BlcmFuZC50eXBlID09PSBcIkJvb2xlYW5WYWx1ZVwiICYmICFvcGVyYW5kLnZhbHVlXSxcbiAgICBbXCJ0cnVlXCIsIChvcGVyYW5kKSA9PiBvcGVyYW5kLnR5cGUgPT09IFwiQm9vbGVhblZhbHVlXCIgJiYgb3BlcmFuZC52YWx1ZV0sXG4gICAgW1wibnVtYmVyXCIsIChvcGVyYW5kKSA9PiBvcGVyYW5kLnR5cGUgPT09IFwiTnVtZXJpY1ZhbHVlXCJdLFxuICAgIFtcImludGVnZXJcIiwgKG9wZXJhbmQpID0+IG9wZXJhbmQudHlwZSA9PT0gXCJOdW1lcmljVmFsdWVcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKG9wZXJhbmQudmFsdWUpXSxcbiAgICBbXCJpdGVyYWJsZVwiLCAob3BlcmFuZCkgPT4gb3BlcmFuZCBpbnN0YW5jZW9mIEFycmF5VmFsdWUgfHwgb3BlcmFuZCBpbnN0YW5jZW9mIFN0cmluZ1ZhbHVlXSxcbiAgICBbXG4gICAgICBcImxvd2VyXCIsXG4gICAgICAob3BlcmFuZCkgPT4ge1xuICAgICAgICBjb25zdCBzdHIgPSBvcGVyYW5kLnZhbHVlO1xuICAgICAgICByZXR1cm4gb3BlcmFuZC50eXBlID09PSBcIlN0cmluZ1ZhbHVlXCIgJiYgc3RyID09PSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwidXBwZXJcIixcbiAgICAgIChvcGVyYW5kKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0ciA9IG9wZXJhbmQudmFsdWU7XG4gICAgICAgIHJldHVybiBvcGVyYW5kLnR5cGUgPT09IFwiU3RyaW5nVmFsdWVcIiAmJiBzdHIgPT09IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfVxuICAgIF0sXG4gICAgW1wibm9uZVwiLCAob3BlcmFuZCkgPT4gb3BlcmFuZC50eXBlID09PSBcIk51bGxWYWx1ZVwiXSxcbiAgICBbXCJkZWZpbmVkXCIsIChvcGVyYW5kKSA9PiBvcGVyYW5kLnR5cGUgIT09IFwiVW5kZWZpbmVkVmFsdWVcIl0sXG4gICAgW1widW5kZWZpbmVkXCIsIChvcGVyYW5kKSA9PiBvcGVyYW5kLnR5cGUgPT09IFwiVW5kZWZpbmVkVmFsdWVcIl0sXG4gICAgW1wiZXF1YWx0b1wiLCAoYSwgYikgPT4gYS52YWx1ZSA9PT0gYi52YWx1ZV1cbiAgXSk7XG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlIG9mIGEgdmFyaWFibGUgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXG4gICAqL1xuICBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNsYXJlVmFyaWFibGUobmFtZSwgY29udmVydFRvUnVudGltZVZhbHVlcyh2YWx1ZSkpO1xuICB9XG4gIGRlY2xhcmVWYXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLnZhcmlhYmxlcy5oYXMobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVmFyaWFibGUgYWxyZWFkeSBkZWNsYXJlZDogJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnZhcmlhYmxlcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvLyBwcml2YXRlIGFzc2lnblZhcmlhYmxlKG5hbWU6IHN0cmluZywgdmFsdWU6IEFueVJ1bnRpbWVWYWx1ZSk6IEFueVJ1bnRpbWVWYWx1ZSB7XG4gIC8vIFx0Y29uc3QgZW52ID0gdGhpcy5yZXNvbHZlKG5hbWUpO1xuICAvLyBcdGVudi52YXJpYWJsZXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgLy8gXHRyZXR1cm4gdmFsdWU7XG4gIC8vIH1cbiAgLyoqXG4gICAqIFNldCB2YXJpYWJsZSBpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgICogU2VlIGh0dHBzOi8vamluamEucGFsbGV0c3Byb2plY3RzLmNvbS9lbi8zLjAueC90ZW1wbGF0ZXMvI2Fzc2lnbm1lbnRzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgc2V0VmFyaWFibGUobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLnZhcmlhYmxlcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgZW52aXJvbm1lbnQgaW4gd2hpY2ggdGhlIHZhcmlhYmxlIGlzIGRlY2xhcmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUuXG4gICAqIEByZXR1cm5zIHtFbnZpcm9ubWVudH0gVGhlIGVudmlyb25tZW50IGluIHdoaWNoIHRoZSB2YXJpYWJsZSBpcyBkZWNsYXJlZC5cbiAgICovXG4gIHJlc29sdmUobmFtZSkge1xuICAgIGlmICh0aGlzLnZhcmlhYmxlcy5oYXMobmFtZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5yZXNvbHZlKG5hbWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdmFyaWFibGU6ICR7bmFtZX1gKTtcbiAgfVxuICBsb29rdXBWYXJpYWJsZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnJlc29sdmUobmFtZSkudmFyaWFibGVzLmdldChuYW1lKSA/PyBuZXcgVW5kZWZpbmVkVmFsdWUoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBuZXcgVW5kZWZpbmVkVmFsdWUoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgSW50ZXJwcmV0ZXIgPSBjbGFzcyB7XG4gIGdsb2JhbDtcbiAgY29uc3RydWN0b3IoZW52KSB7XG4gICAgdGhpcy5nbG9iYWwgPSBlbnYgPz8gbmV3IEVudmlyb25tZW50KCk7XG4gIH1cbiAgLyoqXG4gICAqIFJ1biB0aGUgcHJvZ3JhbS5cbiAgICovXG4gIHJ1bihwcm9ncmFtKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZhbHVhdGUocHJvZ3JhbSwgdGhpcy5nbG9iYWwpO1xuICB9XG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgZXhwcmVzc2lvbnMgZm9sbG93aW5nIHRoZSBiaW5hcnkgb3BlcmF0aW9uIHR5cGUuXG4gICAqL1xuICBldmFsdWF0ZUJpbmFyeUV4cHJlc3Npb24obm9kZSwgZW52aXJvbm1lbnQpIHtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5ldmFsdWF0ZShub2RlLmxlZnQsIGVudmlyb25tZW50KTtcbiAgICBzd2l0Y2ggKG5vZGUub3BlcmF0b3IudmFsdWUpIHtcbiAgICAgIGNhc2UgXCJhbmRcIjpcbiAgICAgICAgcmV0dXJuIGxlZnQuX19ib29sX18oKS52YWx1ZSA/IHRoaXMuZXZhbHVhdGUobm9kZS5yaWdodCwgZW52aXJvbm1lbnQpIDogbGVmdDtcbiAgICAgIGNhc2UgXCJvclwiOlxuICAgICAgICByZXR1cm4gbGVmdC5fX2Jvb2xfXygpLnZhbHVlID8gbGVmdCA6IHRoaXMuZXZhbHVhdGUobm9kZS5yaWdodCwgZW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICBjb25zdCByaWdodCA9IHRoaXMuZXZhbHVhdGUobm9kZS5yaWdodCwgZW52aXJvbm1lbnQpO1xuICAgIHN3aXRjaCAobm9kZS5vcGVyYXRvci52YWx1ZSkge1xuICAgICAgY2FzZSBcIj09XCI6XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKGxlZnQudmFsdWUgPT0gcmlnaHQudmFsdWUpO1xuICAgICAgY2FzZSBcIiE9XCI6XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKGxlZnQudmFsdWUgIT0gcmlnaHQudmFsdWUpO1xuICAgIH1cbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFVuZGVmaW5lZFZhbHVlIHx8IHJpZ2h0IGluc3RhbmNlb2YgVW5kZWZpbmVkVmFsdWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBvbiB1bmRlZmluZWQgdmFsdWVzXCIpO1xuICAgIH0gZWxzZSBpZiAobGVmdCBpbnN0YW5jZW9mIE51bGxWYWx1ZSB8fCByaWdodCBpbnN0YW5jZW9mIE51bGxWYWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIG9uIG51bGwgdmFsdWVzXCIpO1xuICAgIH0gZWxzZSBpZiAobGVmdCBpbnN0YW5jZW9mIE51bWVyaWNWYWx1ZSAmJiByaWdodCBpbnN0YW5jZW9mIE51bWVyaWNWYWx1ZSkge1xuICAgICAgc3dpdGNoIChub2RlLm9wZXJhdG9yLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmljVmFsdWUobGVmdC52YWx1ZSArIHJpZ2h0LnZhbHVlKTtcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICByZXR1cm4gbmV3IE51bWVyaWNWYWx1ZShsZWZ0LnZhbHVlIC0gcmlnaHQudmFsdWUpO1xuICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgIHJldHVybiBuZXcgTnVtZXJpY1ZhbHVlKGxlZnQudmFsdWUgKiByaWdodC52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmljVmFsdWUobGVmdC52YWx1ZSAvIHJpZ2h0LnZhbHVlKTtcbiAgICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgICByZXR1cm4gbmV3IE51bWVyaWNWYWx1ZShsZWZ0LnZhbHVlICUgcmlnaHQudmFsdWUpO1xuICAgICAgICBjYXNlIFwiPFwiOlxuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKGxlZnQudmFsdWUgPCByaWdodC52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuVmFsdWUobGVmdC52YWx1ZSA+IHJpZ2h0LnZhbHVlKTtcbiAgICAgICAgY2FzZSBcIj49XCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuVmFsdWUobGVmdC52YWx1ZSA+PSByaWdodC52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKGxlZnQudmFsdWUgPD0gcmlnaHQudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVmdCBpbnN0YW5jZW9mIEFycmF5VmFsdWUgJiYgcmlnaHQgaW5zdGFuY2VvZiBBcnJheVZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUub3BlcmF0b3IudmFsdWUpIHtcbiAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICByZXR1cm4gbmV3IEFycmF5VmFsdWUobGVmdC52YWx1ZS5jb25jYXQocmlnaHQudmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJpZ2h0IGluc3RhbmNlb2YgQXJyYXlWYWx1ZSkge1xuICAgICAgY29uc3QgbWVtYmVyID0gcmlnaHQudmFsdWUuZmluZCgoeCkgPT4geC52YWx1ZSA9PT0gbGVmdC52YWx1ZSkgIT09IHZvaWQgMDtcbiAgICAgIHN3aXRjaCAobm9kZS5vcGVyYXRvci52YWx1ZSkge1xuICAgICAgICBjYXNlIFwiaW5cIjpcbiAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZShtZW1iZXIpO1xuICAgICAgICBjYXNlIFwibm90IGluXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuVmFsdWUoIW1lbWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgU3RyaW5nVmFsdWUgfHwgcmlnaHQgaW5zdGFuY2VvZiBTdHJpbmdWYWx1ZSkge1xuICAgICAgc3dpdGNoIChub2RlLm9wZXJhdG9yLnZhbHVlKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShsZWZ0LnZhbHVlLnRvU3RyaW5nKCkgKyByaWdodC52YWx1ZS50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBTdHJpbmdWYWx1ZSAmJiByaWdodCBpbnN0YW5jZW9mIFN0cmluZ1ZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUub3BlcmF0b3IudmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImluXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuVmFsdWUocmlnaHQudmFsdWUuaW5jbHVkZXMobGVmdC52YWx1ZSkpO1xuICAgICAgICBjYXNlIFwibm90IGluXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuVmFsdWUoIXJpZ2h0LnZhbHVlLmluY2x1ZGVzKGxlZnQudmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBTdHJpbmdWYWx1ZSAmJiByaWdodCBpbnN0YW5jZW9mIE9iamVjdFZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKG5vZGUub3BlcmF0b3IudmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImluXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuVmFsdWUocmlnaHQudmFsdWUuaGFzKGxlZnQudmFsdWUpKTtcbiAgICAgICAgY2FzZSBcIm5vdCBpblwiOlxuICAgICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKCFyaWdodC52YWx1ZS5oYXMobGVmdC52YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVua25vd24gb3BlcmF0b3IgXCIke25vZGUub3BlcmF0b3IudmFsdWV9XCIgYmV0d2VlbiAke2xlZnQudHlwZX0gYW5kICR7cmlnaHQudHlwZX1gKTtcbiAgfVxuICAvKipcbiAgICogRXZhbHVhdGVzIGV4cHJlc3Npb25zIGZvbGxvd2luZyB0aGUgZmlsdGVyIG9wZXJhdGlvbiB0eXBlLlxuICAgKi9cbiAgZXZhbHVhdGVGaWx0ZXJFeHByZXNzaW9uKG5vZGUsIGVudmlyb25tZW50KSB7XG4gICAgY29uc3Qgb3BlcmFuZCA9IHRoaXMuZXZhbHVhdGUobm9kZS5vcGVyYW5kLCBlbnZpcm9ubWVudCk7XG4gICAgaWYgKG5vZGUuZmlsdGVyLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBub2RlLmZpbHRlcjtcbiAgICAgIGlmIChvcGVyYW5kIGluc3RhbmNlb2YgQXJyYXlWYWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKGZpbHRlci52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJsaXN0XCI6XG4gICAgICAgICAgICByZXR1cm4gb3BlcmFuZDtcbiAgICAgICAgICBjYXNlIFwiZmlyc3RcIjpcbiAgICAgICAgICAgIHJldHVybiBvcGVyYW5kLnZhbHVlWzBdO1xuICAgICAgICAgIGNhc2UgXCJsYXN0XCI6XG4gICAgICAgICAgICByZXR1cm4gb3BlcmFuZC52YWx1ZVtvcGVyYW5kLnZhbHVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGNhc2UgXCJsZW5ndGhcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtZXJpY1ZhbHVlKG9wZXJhbmQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICBjYXNlIFwicmV2ZXJzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheVZhbHVlKG9wZXJhbmQudmFsdWUucmV2ZXJzZSgpKTtcbiAgICAgICAgICBjYXNlIFwic29ydFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheVZhbHVlKFxuICAgICAgICAgICAgICBvcGVyYW5kLnZhbHVlLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYS50eXBlICE9PSBiLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbXBhcmUgZGlmZmVyZW50IHR5cGVzOiAke2EudHlwZX0gYW5kICR7Yi50eXBlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIk51bWVyaWNWYWx1ZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS52YWx1ZSAtIGIudmFsdWU7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiU3RyaW5nVmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEudmFsdWUubG9jYWxlQ29tcGFyZShiLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbXBhcmUgdHlwZTogJHthLnR5cGV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIEFycmF5VmFsdWUgZmlsdGVyOiAke2ZpbHRlci52YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvcGVyYW5kIGluc3RhbmNlb2YgU3RyaW5nVmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChmaWx0ZXIudmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwibGVuZ3RoXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWVyaWNWYWx1ZShvcGVyYW5kLnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgY2FzZSBcInVwcGVyXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKG9wZXJhbmQudmFsdWUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgY2FzZSBcImxvd2VyXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKG9wZXJhbmQudmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKHRpdGxlQ2FzZShvcGVyYW5kLnZhbHVlKSk7XG4gICAgICAgICAgY2FzZSBcImNhcGl0YWxpemVcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUob3BlcmFuZC52YWx1ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG9wZXJhbmQudmFsdWUuc2xpY2UoMSkpO1xuICAgICAgICAgIGNhc2UgXCJ0cmltXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKG9wZXJhbmQudmFsdWUudHJpbSgpKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFN0cmluZ1ZhbHVlIGZpbHRlcjogJHtmaWx0ZXIudmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob3BlcmFuZCBpbnN0YW5jZW9mIE51bWVyaWNWYWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKGZpbHRlci52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJhYnNcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtZXJpY1ZhbHVlKE1hdGguYWJzKG9wZXJhbmQudmFsdWUpKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIE51bWVyaWNWYWx1ZSBmaWx0ZXI6ICR7ZmlsdGVyLnZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9wZXJhbmQgaW5zdGFuY2VvZiBPYmplY3RWYWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKGZpbHRlci52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCJpdGVtc1wiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheVZhbHVlKFxuICAgICAgICAgICAgICBBcnJheS5mcm9tKG9wZXJhbmQudmFsdWUuZW50cmllcygpKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gbmV3IEFycmF5VmFsdWUoW25ldyBTdHJpbmdWYWx1ZShrZXkpLCB2YWx1ZV0pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICBjYXNlIFwibGVuZ3RoXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IE51bWVyaWNWYWx1ZShvcGVyYW5kLnZhbHVlLnNpemUpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gT2JqZWN0VmFsdWUgZmlsdGVyOiAke2ZpbHRlci52YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYXBwbHkgZmlsdGVyIFwiJHtmaWx0ZXIudmFsdWV9XCIgdG8gdHlwZTogJHtvcGVyYW5kLnR5cGV9YCk7XG4gICAgfSBlbHNlIGlmIChub2RlLmZpbHRlci50eXBlID09PSBcIkNhbGxFeHByZXNzaW9uXCIpIHtcbiAgICAgIGNvbnN0IGZpbHRlciA9IG5vZGUuZmlsdGVyO1xuICAgICAgaWYgKGZpbHRlci5jYWxsZWUudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZpbHRlcjogJHtmaWx0ZXIuY2FsbGVlLnR5cGV9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBmaWx0ZXJOYW1lID0gZmlsdGVyLmNhbGxlZS52YWx1ZTtcbiAgICAgIGlmIChvcGVyYW5kIGluc3RhbmNlb2YgQXJyYXlWYWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKGZpbHRlck5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwic2VsZWN0YXR0clwiOiB7XG4gICAgICAgICAgICBpZiAob3BlcmFuZC52YWx1ZS5zb21lKCh4KSA9PiAhKHggaW5zdGFuY2VvZiBPYmplY3RWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBzZWxlY3RhdHRyYCBjYW4gb25seSBiZSBhcHBsaWVkIHRvIGFycmF5IG9mIG9iamVjdHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmFyZ3Muc29tZSgoeCkgPT4geC50eXBlICE9PSBcIlN0cmluZ0xpdGVyYWxcIikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJndW1lbnRzIG9mIGBzZWxlY3RhdHRyYCBtdXN0IGJlIHN0cmluZ3NcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbYXR0ciwgdGVzdE5hbWUsIHZhbHVlXSA9IGZpbHRlci5hcmdzLm1hcCgoeCkgPT4gdGhpcy5ldmFsdWF0ZSh4LCBlbnZpcm9ubWVudCkpO1xuICAgICAgICAgICAgbGV0IHRlc3RGdW5jdGlvbjtcbiAgICAgICAgICAgIGlmICh0ZXN0TmFtZSkge1xuICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gZW52aXJvbm1lbnQudGVzdHMuZ2V0KHRlc3ROYW1lLnZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKCF0ZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRlc3Q6ICR7dGVzdE5hbWUudmFsdWV9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGVzdEZ1bmN0aW9uID0gdGVzdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRlc3RGdW5jdGlvbiA9ICguLi54KSA9PiB4WzBdLl9fYm9vbF9fKCkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IG9wZXJhbmQudmFsdWUuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGEgPSBpdGVtLnZhbHVlLmdldChhdHRyLnZhbHVlKTtcbiAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVzdEZ1bmN0aW9uKGEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlWYWx1ZShmaWx0ZXJlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBBcnJheVZhbHVlIGZpbHRlcjogJHtmaWx0ZXJOYW1lfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYXBwbHkgZmlsdGVyIFwiJHtmaWx0ZXJOYW1lfVwiIHRvIHR5cGU6ICR7b3BlcmFuZC50eXBlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmlsdGVyOiAke25vZGUuZmlsdGVyLnR5cGV9YCk7XG4gIH1cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyBleHByZXNzaW9ucyBmb2xsb3dpbmcgdGhlIHRlc3Qgb3BlcmF0aW9uIHR5cGUuXG4gICAqL1xuICBldmFsdWF0ZVRlc3RFeHByZXNzaW9uKG5vZGUsIGVudmlyb25tZW50KSB7XG4gICAgY29uc3Qgb3BlcmFuZCA9IHRoaXMuZXZhbHVhdGUobm9kZS5vcGVyYW5kLCBlbnZpcm9ubWVudCk7XG4gICAgY29uc3QgdGVzdCA9IGVudmlyb25tZW50LnRlc3RzLmdldChub2RlLnRlc3QudmFsdWUpO1xuICAgIGlmICghdGVzdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRlc3Q6ICR7bm9kZS50ZXN0LnZhbHVlfWApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0ZXN0KG9wZXJhbmQpO1xuICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKG5vZGUubmVnYXRlID8gIXJlc3VsdCA6IHJlc3VsdCk7XG4gIH1cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyBleHByZXNzaW9ucyBmb2xsb3dpbmcgdGhlIHVuYXJ5IG9wZXJhdGlvbiB0eXBlLlxuICAgKi9cbiAgZXZhbHVhdGVVbmFyeUV4cHJlc3Npb24obm9kZSwgZW52aXJvbm1lbnQpIHtcbiAgICBjb25zdCBhcmd1bWVudCA9IHRoaXMuZXZhbHVhdGUobm9kZS5hcmd1bWVudCwgZW52aXJvbm1lbnQpO1xuICAgIHN3aXRjaCAobm9kZS5vcGVyYXRvci52YWx1ZSkge1xuICAgICAgY2FzZSBcIm5vdFwiOlxuICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5WYWx1ZSghYXJndW1lbnQudmFsdWUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmtub3duIG9wZXJhdG9yOiAke25vZGUub3BlcmF0b3IudmFsdWV9YCk7XG4gICAgfVxuICB9XG4gIGV2YWxQcm9ncmFtKHByb2dyYW0sIGVudmlyb25tZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVCbG9jayhwcm9ncmFtLmJvZHksIGVudmlyb25tZW50KTtcbiAgfVxuICBldmFsdWF0ZUJsb2NrKHN0YXRlbWVudHMsIGVudmlyb25tZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBzdGF0ZW1lbnQgb2Ygc3RhdGVtZW50cykge1xuICAgICAgY29uc3QgbGFzdEV2YWx1YXRlZCA9IHRoaXMuZXZhbHVhdGUoc3RhdGVtZW50LCBlbnZpcm9ubWVudCk7XG4gICAgICBpZiAobGFzdEV2YWx1YXRlZC50eXBlICE9PSBcIk51bGxWYWx1ZVwiICYmIGxhc3RFdmFsdWF0ZWQudHlwZSAhPT0gXCJVbmRlZmluZWRWYWx1ZVwiKSB7XG4gICAgICAgIHJlc3VsdCArPSBsYXN0RXZhbHVhdGVkLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKHJlc3VsdCk7XG4gIH1cbiAgZXZhbHVhdGVJZGVudGlmaWVyKG5vZGUsIGVudmlyb25tZW50KSB7XG4gICAgcmV0dXJuIGVudmlyb25tZW50Lmxvb2t1cFZhcmlhYmxlKG5vZGUudmFsdWUpO1xuICB9XG4gIGV2YWx1YXRlQ2FsbEV4cHJlc3Npb24oZXhwciwgZW52aXJvbm1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgY29uc3Qga3dhcmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGFyZ3VtZW50IG9mIGV4cHIuYXJncykge1xuICAgICAgaWYgKGFyZ3VtZW50LnR5cGUgPT09IFwiS2V5d29yZEFyZ3VtZW50RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGNvbnN0IGt3YXJnID0gYXJndW1lbnQ7XG4gICAgICAgIGt3YXJncy5zZXQoa3dhcmcua2V5LnZhbHVlLCB0aGlzLmV2YWx1YXRlKGt3YXJnLnZhbHVlLCBlbnZpcm9ubWVudCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJncy5wdXNoKHRoaXMuZXZhbHVhdGUoYXJndW1lbnQsIGVudmlyb25tZW50KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrd2FyZ3Muc2l6ZSA+IDApIHtcbiAgICAgIGFyZ3MucHVzaChuZXcgT2JqZWN0VmFsdWUoa3dhcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZuID0gdGhpcy5ldmFsdWF0ZShleHByLmNhbGxlZSwgZW52aXJvbm1lbnQpO1xuICAgIGlmIChmbi50eXBlICE9PSBcIkZ1bmN0aW9uVmFsdWVcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY2FsbCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBmdW5jdGlvbjogZ290ICR7Zm4udHlwZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLnZhbHVlKGFyZ3MsIGVudmlyb25tZW50KTtcbiAgfVxuICBldmFsdWF0ZVNsaWNlRXhwcmVzc2lvbihvYmplY3QsIGV4cHIsIGVudmlyb25tZW50KSB7XG4gICAgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlWYWx1ZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmdWYWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNsaWNlIG9iamVjdCBtdXN0IGJlIGFuIGFycmF5IG9yIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmV2YWx1YXRlKGV4cHIuc3RhcnQsIGVudmlyb25tZW50KTtcbiAgICBjb25zdCBzdG9wID0gdGhpcy5ldmFsdWF0ZShleHByLnN0b3AsIGVudmlyb25tZW50KTtcbiAgICBjb25zdCBzdGVwID0gdGhpcy5ldmFsdWF0ZShleHByLnN0ZXAsIGVudmlyb25tZW50KTtcbiAgICBpZiAoIShzdGFydCBpbnN0YW5jZW9mIE51bWVyaWNWYWx1ZSB8fCBzdGFydCBpbnN0YW5jZW9mIFVuZGVmaW5lZFZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xpY2Ugc3RhcnQgbXVzdCBiZSBudW1lcmljIG9yIHVuZGVmaW5lZFwiKTtcbiAgICB9XG4gICAgaWYgKCEoc3RvcCBpbnN0YW5jZW9mIE51bWVyaWNWYWx1ZSB8fCBzdG9wIGluc3RhbmNlb2YgVW5kZWZpbmVkVmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGljZSBzdG9wIG11c3QgYmUgbnVtZXJpYyBvciB1bmRlZmluZWRcIik7XG4gICAgfVxuICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBOdW1lcmljVmFsdWUgfHwgc3RlcCBpbnN0YW5jZW9mIFVuZGVmaW5lZFZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2xpY2Ugc3RlcCBtdXN0IGJlIG51bWVyaWMgb3IgdW5kZWZpbmVkXCIpO1xuICAgIH1cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQXJyYXlWYWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheVZhbHVlKHNsaWNlKG9iamVjdC52YWx1ZSwgc3RhcnQudmFsdWUsIHN0b3AudmFsdWUsIHN0ZXAudmFsdWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShzbGljZShBcnJheS5mcm9tKG9iamVjdC52YWx1ZSksIHN0YXJ0LnZhbHVlLCBzdG9wLnZhbHVlLCBzdGVwLnZhbHVlKS5qb2luKFwiXCIpKTtcbiAgICB9XG4gIH1cbiAgZXZhbHVhdGVNZW1iZXJFeHByZXNzaW9uKGV4cHIsIGVudmlyb25tZW50KSB7XG4gICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5ldmFsdWF0ZShleHByLm9iamVjdCwgZW52aXJvbm1lbnQpO1xuICAgIGxldCBwcm9wZXJ0eTtcbiAgICBpZiAoZXhwci5jb21wdXRlZCkge1xuICAgICAgaWYgKGV4cHIucHJvcGVydHkudHlwZSA9PT0gXCJTbGljZUV4cHJlc3Npb25cIikge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZVNsaWNlRXhwcmVzc2lvbihvYmplY3QsIGV4cHIucHJvcGVydHksIGVudmlyb25tZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BlcnR5ID0gdGhpcy5ldmFsdWF0ZShleHByLnByb3BlcnR5LCBlbnZpcm9ubWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BlcnR5ID0gbmV3IFN0cmluZ1ZhbHVlKGV4cHIucHJvcGVydHkudmFsdWUpO1xuICAgIH1cbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdFZhbHVlKSB7XG4gICAgICBpZiAoIShwcm9wZXJ0eSBpbnN0YW5jZW9mIFN0cmluZ1ZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBhY2Nlc3MgcHJvcGVydHkgd2l0aCBub24tc3RyaW5nOiBnb3QgJHtwcm9wZXJ0eS50eXBlfWApO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBvYmplY3QudmFsdWUuZ2V0KHByb3BlcnR5LnZhbHVlKSA/PyBvYmplY3QuYnVpbHRpbnMuZ2V0KHByb3BlcnR5LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFycmF5VmFsdWUgfHwgb2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nVmFsdWUpIHtcbiAgICAgIGlmIChwcm9wZXJ0eSBpbnN0YW5jZW9mIE51bWVyaWNWYWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IG9iamVjdC52YWx1ZS5hdChwcm9wZXJ0eS52YWx1ZSk7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmdWYWx1ZSkge1xuICAgICAgICAgIHZhbHVlID0gbmV3IFN0cmluZ1ZhbHVlKG9iamVjdC52YWx1ZS5hdChwcm9wZXJ0eS52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5IGluc3RhbmNlb2YgU3RyaW5nVmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBvYmplY3QuYnVpbHRpbnMuZ2V0KHByb3BlcnR5LnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGFjY2VzcyBwcm9wZXJ0eSB3aXRoIG5vbi1zdHJpbmcvbm9uLW51bWJlcjogZ290ICR7cHJvcGVydHkudHlwZX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEocHJvcGVydHkgaW5zdGFuY2VvZiBTdHJpbmdWYWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgYWNjZXNzIHByb3BlcnR5IHdpdGggbm9uLXN0cmluZzogZ290ICR7cHJvcGVydHkudHlwZX1gKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gb2JqZWN0LmJ1aWx0aW5zLmdldChwcm9wZXJ0eS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJ1bnRpbWVWYWx1ZSA/IHZhbHVlIDogbmV3IFVuZGVmaW5lZFZhbHVlKCk7XG4gIH1cbiAgZXZhbHVhdGVTZXQobm9kZSwgZW52aXJvbm1lbnQpIHtcbiAgICBjb25zdCByaHMgPSB0aGlzLmV2YWx1YXRlKG5vZGUudmFsdWUsIGVudmlyb25tZW50KTtcbiAgICBpZiAobm9kZS5hc3NpZ25lZS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgY29uc3QgdmFyaWFibGVOYW1lID0gbm9kZS5hc3NpZ25lZS52YWx1ZTtcbiAgICAgIGVudmlyb25tZW50LnNldFZhcmlhYmxlKHZhcmlhYmxlTmFtZSwgcmhzKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuYXNzaWduZWUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgIGNvbnN0IG1lbWJlciA9IG5vZGUuYXNzaWduZWU7XG4gICAgICBjb25zdCBvYmplY3QgPSB0aGlzLmV2YWx1YXRlKG1lbWJlci5vYmplY3QsIGVudmlyb25tZW50KTtcbiAgICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIE9iamVjdFZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXNzaWduIHRvIG1lbWJlciBvZiBub24tb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG1lbWJlci5wcm9wZXJ0eS50eXBlICE9PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXNzaWduIHRvIG1lbWJlciB3aXRoIG5vbi1pZGVudGlmaWVyIHByb3BlcnR5XCIpO1xuICAgICAgfVxuICAgICAgb2JqZWN0LnZhbHVlLnNldChtZW1iZXIucHJvcGVydHkudmFsdWUsIHJocyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBMSFMgaW5zaWRlIGFzc2lnbm1lbnQgZXhwcmVzc2lvbjogJHtKU09OLnN0cmluZ2lmeShub2RlLmFzc2lnbmVlKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOdWxsVmFsdWUoKTtcbiAgfVxuICBldmFsdWF0ZUlmKG5vZGUsIGVudmlyb25tZW50KSB7XG4gICAgY29uc3QgdGVzdCA9IHRoaXMuZXZhbHVhdGUobm9kZS50ZXN0LCBlbnZpcm9ubWVudCk7XG4gICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVCbG9jayh0ZXN0Ll9fYm9vbF9fKCkudmFsdWUgPyBub2RlLmJvZHkgOiBub2RlLmFsdGVybmF0ZSwgZW52aXJvbm1lbnQpO1xuICB9XG4gIGV2YWx1YXRlRm9yKG5vZGUsIGVudmlyb25tZW50KSB7XG4gICAgY29uc3Qgc2NvcGUgPSBuZXcgRW52aXJvbm1lbnQoZW52aXJvbm1lbnQpO1xuICAgIGNvbnN0IGl0ZXJhYmxlID0gdGhpcy5ldmFsdWF0ZShub2RlLml0ZXJhYmxlLCBzY29wZSk7XG4gICAgaWYgKCEoaXRlcmFibGUgaW5zdGFuY2VvZiBBcnJheVZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBpdGVyYWJsZSB0eXBlIGluIGZvciBsb29wOiBnb3QgJHtpdGVyYWJsZS50eXBlfWApO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhYmxlLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBsb29wID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICAgICAgICBbXCJpbmRleFwiLCBuZXcgTnVtZXJpY1ZhbHVlKGkgKyAxKV0sXG4gICAgICAgIFtcImluZGV4MFwiLCBuZXcgTnVtZXJpY1ZhbHVlKGkpXSxcbiAgICAgICAgW1wicmV2aW5kZXhcIiwgbmV3IE51bWVyaWNWYWx1ZShpdGVyYWJsZS52YWx1ZS5sZW5ndGggLSBpKV0sXG4gICAgICAgIFtcInJldmluZGV4MFwiLCBuZXcgTnVtZXJpY1ZhbHVlKGl0ZXJhYmxlLnZhbHVlLmxlbmd0aCAtIGkgLSAxKV0sXG4gICAgICAgIFtcImZpcnN0XCIsIG5ldyBCb29sZWFuVmFsdWUoaSA9PT0gMCldLFxuICAgICAgICBbXCJsYXN0XCIsIG5ldyBCb29sZWFuVmFsdWUoaSA9PT0gaXRlcmFibGUudmFsdWUubGVuZ3RoIC0gMSldLFxuICAgICAgICBbXCJsZW5ndGhcIiwgbmV3IE51bWVyaWNWYWx1ZShpdGVyYWJsZS52YWx1ZS5sZW5ndGgpXSxcbiAgICAgICAgW1wicHJldml0ZW1cIiwgaSA+IDAgPyBpdGVyYWJsZS52YWx1ZVtpIC0gMV0gOiBuZXcgVW5kZWZpbmVkVmFsdWUoKV0sXG4gICAgICAgIFtcIm5leHRpdGVtXCIsIGkgPCBpdGVyYWJsZS52YWx1ZS5sZW5ndGggLSAxID8gaXRlcmFibGUudmFsdWVbaSArIDFdIDogbmV3IFVuZGVmaW5lZFZhbHVlKCldXG4gICAgICBdKTtcbiAgICAgIHNjb3BlLnNldFZhcmlhYmxlKFwibG9vcFwiLCBuZXcgT2JqZWN0VmFsdWUobG9vcCkpO1xuICAgICAgY29uc3QgY3VycmVudCA9IGl0ZXJhYmxlLnZhbHVlW2ldO1xuICAgICAgaWYgKG5vZGUubG9vcHZhci50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICBzY29wZS5zZXRWYXJpYWJsZShub2RlLmxvb3B2YXIudmFsdWUsIGN1cnJlbnQpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmxvb3B2YXIudHlwZSA9PT0gXCJUdXBsZUxpdGVyYWxcIikge1xuICAgICAgICBjb25zdCBsb29wdmFyID0gbm9kZS5sb29wdmFyO1xuICAgICAgICBpZiAoY3VycmVudC50eXBlICE9PSBcIkFycmF5VmFsdWVcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVucGFjayBub24taXRlcmFibGUgdHlwZTogJHtjdXJyZW50LnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IGN1cnJlbnQ7XG4gICAgICAgIGlmIChsb29wdmFyLnZhbHVlLmxlbmd0aCAhPT0gYy52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyAke2xvb3B2YXIudmFsdWUubGVuZ3RoID4gYy52YWx1ZS5sZW5ndGggPyBcImZld1wiIDogXCJtYW55XCJ9IGl0ZW1zIHRvIHVucGFja2ApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9vcHZhci52YWx1ZS5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGlmIChsb29wdmFyLnZhbHVlW2pdLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB1bnBhY2sgbm9uLWlkZW50aWZpZXIgdHlwZTogJHtsb29wdmFyLnZhbHVlW2pdLnR5cGV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjb3BlLnNldFZhcmlhYmxlKGxvb3B2YXIudmFsdWVbal0udmFsdWUsIGMudmFsdWVbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBldmFsdWF0ZWQgPSB0aGlzLmV2YWx1YXRlQmxvY2sobm9kZS5ib2R5LCBzY29wZSk7XG4gICAgICByZXN1bHQgKz0gZXZhbHVhdGVkLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKHJlc3VsdCk7XG4gIH1cbiAgZXZhbHVhdGUoc3RhdGVtZW50LCBlbnZpcm9ubWVudCkge1xuICAgIGlmIChzdGF0ZW1lbnQgPT09IHZvaWQgMClcbiAgICAgIHJldHVybiBuZXcgVW5kZWZpbmVkVmFsdWUoKTtcbiAgICBzd2l0Y2ggKHN0YXRlbWVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiUHJvZ3JhbVwiOlxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsUHJvZ3JhbShzdGF0ZW1lbnQsIGVudmlyb25tZW50KTtcbiAgICAgIGNhc2UgXCJTZXRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVTZXQoc3RhdGVtZW50LCBlbnZpcm9ubWVudCk7XG4gICAgICBjYXNlIFwiSWZcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVJZihzdGF0ZW1lbnQsIGVudmlyb25tZW50KTtcbiAgICAgIGNhc2UgXCJGb3JcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVGb3Ioc3RhdGVtZW50LCBlbnZpcm9ubWVudCk7XG4gICAgICBjYXNlIFwiTnVtZXJpY0xpdGVyYWxcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBOdW1lcmljVmFsdWUoTnVtYmVyKHN0YXRlbWVudC52YWx1ZSkpO1xuICAgICAgY2FzZSBcIlN0cmluZ0xpdGVyYWxcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShzdGF0ZW1lbnQudmFsdWUpO1xuICAgICAgY2FzZSBcIkJvb2xlYW5MaXRlcmFsXCI6XG4gICAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKHN0YXRlbWVudC52YWx1ZSk7XG4gICAgICBjYXNlIFwiQXJyYXlMaXRlcmFsXCI6XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlWYWx1ZShzdGF0ZW1lbnQudmFsdWUubWFwKCh4KSA9PiB0aGlzLmV2YWx1YXRlKHgsIGVudmlyb25tZW50KSkpO1xuICAgICAgY2FzZSBcIlR1cGxlTGl0ZXJhbFwiOlxuICAgICAgICByZXR1cm4gbmV3IFR1cGxlVmFsdWUoc3RhdGVtZW50LnZhbHVlLm1hcCgoeCkgPT4gdGhpcy5ldmFsdWF0ZSh4LCBlbnZpcm9ubWVudCkpKTtcbiAgICAgIGNhc2UgXCJPYmplY3RMaXRlcmFsXCI6IHtcbiAgICAgICAgY29uc3QgbWFwcGluZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN0YXRlbWVudC52YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGV2YWx1YXRlZEtleSA9IHRoaXMuZXZhbHVhdGUoa2V5LCBlbnZpcm9ubWVudCk7XG4gICAgICAgICAgaWYgKCEoZXZhbHVhdGVkS2V5IGluc3RhbmNlb2YgU3RyaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBrZXlzIG11c3QgYmUgc3RyaW5nczogZ290ICR7ZXZhbHVhdGVkS2V5LnR5cGV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hcHBpbmcuc2V0KGV2YWx1YXRlZEtleS52YWx1ZSwgdGhpcy5ldmFsdWF0ZSh2YWx1ZSwgZW52aXJvbm1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFZhbHVlKG1hcHBpbmcpO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVJZGVudGlmaWVyKHN0YXRlbWVudCwgZW52aXJvbm1lbnQpO1xuICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlQ2FsbEV4cHJlc3Npb24oc3RhdGVtZW50LCBlbnZpcm9ubWVudCk7XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZU1lbWJlckV4cHJlc3Npb24oc3RhdGVtZW50LCBlbnZpcm9ubWVudCk7XG4gICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlVW5hcnlFeHByZXNzaW9uKHN0YXRlbWVudCwgZW52aXJvbm1lbnQpO1xuICAgICAgY2FzZSBcIkJpbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVCaW5hcnlFeHByZXNzaW9uKHN0YXRlbWVudCwgZW52aXJvbm1lbnQpO1xuICAgICAgY2FzZSBcIkZpbHRlckV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGVGaWx0ZXJFeHByZXNzaW9uKHN0YXRlbWVudCwgZW52aXJvbm1lbnQpO1xuICAgICAgY2FzZSBcIlRlc3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlVGVzdEV4cHJlc3Npb24oc3RhdGVtZW50LCBlbnZpcm9ubWVudCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVua25vd24gbm9kZSB0eXBlOiAke3N0YXRlbWVudC50eXBlfWApO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGNvbnZlcnRUb1J1bnRpbWVWYWx1ZXMoaW5wdXQpIHtcbiAgc3dpdGNoICh0eXBlb2YgaW5wdXQpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gbmV3IE51bWVyaWNWYWx1ZShpbnB1dCk7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShpbnB1dCk7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBuZXcgQm9vbGVhblZhbHVlKGlucHV0KTtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOdWxsVmFsdWUoKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVZhbHVlKGlucHV0Lm1hcChjb252ZXJ0VG9SdW50aW1lVmFsdWVzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFZhbHVlKFxuICAgICAgICAgIG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoaW5wdXQpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBba2V5LCBjb252ZXJ0VG9SdW50aW1lVmFsdWVzKHZhbHVlKV0pKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvblZhbHVlKChhcmdzLCBfc2NvcGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5wdXQoLi4uYXJncy5tYXAoKHgpID0+IHgudmFsdWUpKSA/PyBudWxsO1xuICAgICAgICByZXR1cm4gY29udmVydFRvUnVudGltZVZhbHVlcyhyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGNvbnZlcnQgdG8gcnVudGltZSB2YWx1ZTogJHtpbnB1dH1gKTtcbiAgfVxufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBUZW1wbGF0ZSA9IGNsYXNzIHtcbiAgcGFyc2VkO1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSBzdHJpbmdcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRlbXBsYXRlKSB7XG4gICAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUodGVtcGxhdGUsIHtcbiAgICAgIGxzdHJpcF9ibG9ja3M6IHRydWUsXG4gICAgICB0cmltX2Jsb2NrczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMucGFyc2VkID0gcGFyc2UodG9rZW5zKTtcbiAgfVxuICByZW5kZXIoaXRlbXMpIHtcbiAgICBjb25zdCBlbnYgPSBuZXcgRW52aXJvbm1lbnQoKTtcbiAgICBlbnYuc2V0KFwiZmFsc2VcIiwgZmFsc2UpO1xuICAgIGVudi5zZXQoXCJ0cnVlXCIsIHRydWUpO1xuICAgIGVudi5zZXQoXCJyYWlzZV9leGNlcHRpb25cIiwgKGFyZ3MpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihhcmdzKTtcbiAgICB9KTtcbiAgICBlbnYuc2V0KFwicmFuZ2VcIiwgcmFuZ2UpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGl0ZW1zKSkge1xuICAgICAgZW52LnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJwcmV0ZXIgPSBuZXcgSW50ZXJwcmV0ZXIoZW52KTtcbiAgICBjb25zdCByZXN1bHQgPSBpbnRlcnByZXRlci5ydW4odGhpcy5wYXJzZWQpO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH1cbn07XG5leHBvcnQge1xuICBFbnZpcm9ubWVudCxcbiAgSW50ZXJwcmV0ZXIsXG4gIFRlbXBsYXRlLFxuICBwYXJzZSxcbiAgdG9rZW5pemVcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@huggingface/jinja/dist/index.js\n");

/***/ })

};
;